# Generated by ffi-gen. Please do not change this file by hand.

require 'ffi'

module Cairo
  extend FFI::Library
  ffi_lib 'cairo'
  
  def self.attach_function(name, *_)
    begin; super; rescue FFI::NotFoundError => e
      (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
    end
  end
  
  MIME_TYPE_JPEG = "image/jpeg"
  
  MIME_TYPE_PNG = "image/png"
  
  MIME_TYPE_JP2 = "image/jp2"
  
  MIME_TYPE_URI = "text/x-uri"
  
  # (Not documented)
  # 
  # @method version()
  # @return [Integer] 
  # @scope class
  attach_function :version, :cairo_version, [], :int
  
  # (Not documented)
  # 
  # @method version_string()
  # @return [String] 
  # @scope class
  attach_function :version_string, :cairo_version_string, [], :string
  
  # cairo_t:
  # 
  # A #cairo_t contains the current state of the rendering device,
  # including coordinates of yet to be drawn shapes.
  # 
  # Cairo contexts, as #cairo_t objects are named, are central to
  # cairo and all drawing with cairo is always done to a #cairo_t
  # object.
  # 
  # Memory management of #cairo_t is done with
  # cairo_reference() and cairo_destroy().
  class Cairo < FFI::Struct
    layout :dummy, :char
  end
  
  # cairo_surface_t:
  # 
  # A #cairo_surface_t represents an image, either as the destination
  # of a drawing operation or as source when drawing onto another
  # surface.  To draw to a #cairo_surface_t, create a cairo context
  # with the surface as the target, using cairo_create().
  # 
  # There are different subtypes of #cairo_surface_t for
  # different drawing backends; for example, cairo_image_surface_create()
  # creates a bitmap image in memory.
  # The type of a surface can be queried with cairo_surface_get_type().
  # 
  # The initial contents of a surface after creation depend upon the manner
  # of its creation. If cairo creates the surface and backing storage for
  # the user, it will be initially cleared; for example,
  # cairo_image_surface_create() and cairo_surface_create_similar().
  # Alternatively, if the user passes in a reference to some backing storage
  # and asks cairo to wrap that in a #cairo_surface_t, then the contents are
  # not modified; for example, cairo_image_surface_create_for_data() and
  # cairo_xlib_surface_create().
  # 
  # Memory management of #cairo_surface_t is done with
  # cairo_surface_reference() and cairo_surface_destroy().
  module SurfaceWrappers
    def create_similar(content, width, height)
      Surface.new Cairo.surface_create_similar(self, content, width, height)
    end
    
    def create_for_rectangle(x, y, width, height)
      Surface.new Cairo.surface_create_for_rectangle(self, x, y, width, height)
    end
    
    def reference()
      Surface.new Cairo.surface_reference(self)
    end
    
    def finish()
      Cairo.surface_finish(self)
    end
    
    def destroy()
      Cairo.surface_destroy(self)
    end
    
    def get_device()
      Device.new Cairo.surface_get_device(self)
    end
    
    def get_reference_count()
      Cairo.surface_get_reference_count(self)
    end
    
    def status()
      Cairo.surface_status(self)
    end
    
    def get_type()
      Cairo.surface_get_type(self)
    end
    
    def get_content()
      Cairo.surface_get_content(self)
    end
    
    def write_to_png(filename)
      Cairo.surface_write_to_png(self, filename)
    end
    
    def write_to_png_stream(write_func, closure)
      Cairo.surface_write_to_png_stream(self, write_func, closure)
    end
    
    def get_user_data(key)
      Cairo.surface_get_user_data(self, key)
    end
    
    def set_user_data(key, user_data, destroy)
      Cairo.surface_set_user_data(self, key, user_data, destroy)
    end
    
    def get_mime_data(mime_type, data, length)
      Cairo.surface_get_mime_data(self, mime_type, data, length)
    end
    
    def set_mime_data(mime_type, data, length, destroy, closure)
      Cairo.surface_set_mime_data(self, mime_type, data, length, destroy, closure)
    end
    
    def get_font_options(options)
      Cairo.surface_get_font_options(self, options)
    end
    
    def flush()
      Cairo.surface_flush(self)
    end
    
    def mark_dirty()
      Cairo.surface_mark_dirty(self)
    end
    
    def mark_dirty_rectangle(x, y, width, height)
      Cairo.surface_mark_dirty_rectangle(self, x, y, width, height)
    end
    
    def set_device_offset(x_offset, y_offset)
      Cairo.surface_set_device_offset(self, x_offset, y_offset)
    end
    
    def get_device_offset(x_offset, y_offset)
      Cairo.surface_get_device_offset(self, x_offset, y_offset)
    end
    
    def set_fallback_resolution(x_pixels_per_inch, y_pixels_per_inch)
      Cairo.surface_set_fallback_resolution(self, x_pixels_per_inch, y_pixels_per_inch)
    end
    
    def get_fallback_resolution(x_pixels_per_inch, y_pixels_per_inch)
      Cairo.surface_get_fallback_resolution(self, x_pixels_per_inch, y_pixels_per_inch)
    end
    
    def copy_page()
      Cairo.surface_copy_page(self)
    end
    
    def show_page()
      Cairo.surface_show_page(self)
    end
    
    def has_show_text_glyphs()
      Cairo.surface_has_show_text_glyphs(self)
    end
  end
  
  class Surface < FFI::Struct
    include SurfaceWrappers
    layout :dummy, :char
  end
  
  # cairo_device_t:
  # 
  # A #cairo_device_t represents the driver interface for drawing
  # operations to a #cairo_surface_t.  There are different subtypes of
  # #cairo_device_t for different drawing backends; for example,
  # cairo_xcb_device_create() creates a device that wraps the connection
  # to an X Windows System using the XCB library.
  # 
  # The type of a device can be queried with cairo_device_get_type().
  # 
  # Memory management of #cairo_device_t is done with
  # cairo_device_reference() and cairo_device_destroy().
  # 
  # Since: 1.10
  module DeviceWrappers
    def reference()
      Device.new Cairo.device_reference(self)
    end
    
    def get_type()
      Cairo.device_get_type(self)
    end
    
    def status()
      Cairo.device_status(self)
    end
    
    def acquire()
      Cairo.device_acquire(self)
    end
    
    def release()
      Cairo.device_release(self)
    end
    
    def flush()
      Cairo.device_flush(self)
    end
    
    def finish()
      Cairo.device_finish(self)
    end
    
    def destroy()
      Cairo.device_destroy(self)
    end
    
    def get_reference_count()
      Cairo.device_get_reference_count(self)
    end
    
    def get_user_data(key)
      Cairo.device_get_user_data(self, key)
    end
    
    def set_user_data(key, user_data, destroy)
      Cairo.device_set_user_data(self, key, user_data, destroy)
    end
  end
  
  class Device < FFI::Struct
    include DeviceWrappers
    layout :dummy, :char
  end
  
  # cairo_matrix_t:
  # @xx: xx component of the affine transformation
  # @yx: yx component of the affine transformation
  # @xy: xy component of the affine transformation
  # @yy: yy component of the affine transformation
  # @x0: X translation component of the affine transformation
  # @y0: Y translation component of the affine transformation
  # 
  # A #cairo_matrix_t holds an affine transformation, such as a scale,
  # rotation, shear, or a combination of those. The transformation of
  # a point (x, y) is given by:
  # <programlisting>
  #     x_new = xx * x + xy * y + x0;
  #     y_new = yx * x + yy * y + y0;
  # </programlisting>
  # 
  # = Fields:
  # :xx ::
  #   (Float) 
  # :yx ::
  #   (Float) 
  # :xy ::
  #   (Float) 
  # :yy ::
  #   (Float) 
  # :x0 ::
  #   (Float) 
  # :y0 ::
  #   (Float) 
  module MatrixWrappers
    def init(xx, yx, xy, yy, x0, y0)
      Cairo.matrix_init(self, xx, yx, xy, yy, x0, y0)
    end
    
    def init_identity()
      Cairo.matrix_init_identity(self)
    end
    
    def init_translate(tx, ty)
      Cairo.matrix_init_translate(self, tx, ty)
    end
    
    def init_scale(sx, sy)
      Cairo.matrix_init_scale(self, sx, sy)
    end
    
    def init_rotate(radians)
      Cairo.matrix_init_rotate(self, radians)
    end
    
    def translate(tx, ty)
      Cairo.matrix_translate(self, tx, ty)
    end
    
    def scale(sx, sy)
      Cairo.matrix_scale(self, sx, sy)
    end
    
    def rotate(radians)
      Cairo.matrix_rotate(self, radians)
    end
    
    def invert()
      Cairo.matrix_invert(self)
    end
    
    def multiply(a, b)
      Cairo.matrix_multiply(self, a, b)
    end
    
    def transform_distance(dx, dy)
      Cairo.matrix_transform_distance(self, dx, dy)
    end
    
    def transform_point(x, y)
      Cairo.matrix_transform_point(self, x, y)
    end
  end
  
  class Matrix < FFI::Struct
    include MatrixWrappers
    layout :xx, :double,
           :yx, :double,
           :xy, :double,
           :yy, :double,
           :x0, :double,
           :y0, :double
  end
  
  # cairo_pattern_t:
  # 
  # A #cairo_pattern_t represents a source when drawing onto a
  # surface. There are different subtypes of #cairo_pattern_t,
  # for different types of sources; for example,
  # cairo_pattern_create_rgb() creates a pattern for a solid
  # opaque color.
  # 
  # Other than various cairo_pattern_create_<emphasis>type</emphasis>()
  # functions, some of the pattern types can be implicitly created
  # using various cairo_set_source_<emphasis>type</emphasis>() functions;
  # for example cairo_set_source_rgb().
  # 
  # The type of a pattern can be queried with cairo_pattern_get_type().
  # 
  # Memory management of #cairo_pattern_t is done with
  # cairo_pattern_reference() and cairo_pattern_destroy().
  module PatternWrappers
    def reference()
      Pattern.new Cairo.pattern_reference(self)
    end
    
    def destroy()
      Cairo.pattern_destroy(self)
    end
    
    def get_reference_count()
      Cairo.pattern_get_reference_count(self)
    end
    
    def status()
      Cairo.pattern_status(self)
    end
    
    def get_user_data(key)
      Cairo.pattern_get_user_data(self, key)
    end
    
    def set_user_data(key, user_data, destroy)
      Cairo.pattern_set_user_data(self, key, user_data, destroy)
    end
    
    def get_type()
      Cairo.pattern_get_type(self)
    end
    
    def add_color_stop_rgb(offset, red, green, blue)
      Cairo.pattern_add_color_stop_rgb(self, offset, red, green, blue)
    end
    
    def add_color_stop_rgba(offset, red, green, blue, alpha)
      Cairo.pattern_add_color_stop_rgba(self, offset, red, green, blue, alpha)
    end
    
    def set_matrix(matrix)
      Cairo.pattern_set_matrix(self, matrix)
    end
    
    def get_matrix(matrix)
      Cairo.pattern_get_matrix(self, matrix)
    end
    
    def set_extend(extend)
      Cairo.pattern_set_extend(self, extend)
    end
    
    def get_extend()
      Cairo.pattern_get_extend(self)
    end
    
    def set_filter(filter)
      Cairo.pattern_set_filter(self, filter)
    end
    
    def get_filter()
      Cairo.pattern_get_filter(self)
    end
    
    def get_rgba(red, green, blue, alpha)
      Cairo.pattern_get_rgba(self, red, green, blue, alpha)
    end
    
    def get_surface(surface)
      Cairo.pattern_get_surface(self, surface)
    end
    
    def get_color_stop_rgba(index, offset, red, green, blue, alpha)
      Cairo.pattern_get_color_stop_rgba(self, index, offset, red, green, blue, alpha)
    end
    
    def get_color_stop_count(count)
      Cairo.pattern_get_color_stop_count(self, count)
    end
    
    def get_linear_points(x0, y0, x1, y1)
      Cairo.pattern_get_linear_points(self, x0, y0, x1, y1)
    end
    
    def get_radial_circles(x0, y0, r0, x1, y1, r1)
      Cairo.pattern_get_radial_circles(self, x0, y0, r0, x1, y1, r1)
    end
  end
  
  class Pattern < FFI::Struct
    include PatternWrappers
    layout :dummy, :char
  end
  
  # cairo_user_data_key_t:
  # @unused: not used; ignore.
  # 
  # #cairo_user_data_key_t is used for attaching user data to cairo
  # data structures.  The actual contents of the struct is never used,
  # and there is no need to initialize the object; only the unique
  # address of a #cairo_data_key_t object is used.  Typically, you
  # would just use the address of a static #cairo_data_key_t object.
  # 
  # = Fields:
  # :unused ::
  #   (Integer) 
  class UserDataKey < FFI::Struct
    layout :unused, :int
  end
  
  # cairo_status_t:
  # 
  # #cairo_status_t is used to indicate errors that can occur when
  # using Cairo. In some cases it is returned directly by functions.
  # but when using #cairo_t, the last error, if any, is stored in
  # the context and can be retrieved with cairo_status().
  # 
  # New entries may be added in future versions.  Use cairo_status_to_string()
  # to get a human-readable representation of an error message.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:status).</em>
  # 
  # === Options:
  # :success ::
  #   no error has occurred
  # :no_memory ::
  #   out of memory
  # :invalid_restore ::
  #   cairo_restore() called without matching cairo_save()
  # :invalid_pop_group ::
  #   no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group()
  # :no_current_point ::
  #   no current point defined
  # :invalid_matrix ::
  #   invalid matrix (not invertible)
  # :invalid_status ::
  #   invalid value for an input #cairo_status_t
  # :null_pointer ::
  #   %NULL pointer
  # :invalid_string ::
  #   input string not valid UTF-8
  # :invalid_path_data ::
  #   input path data not valid
  # :read_error ::
  #   error while reading from input stream
  # :write_error ::
  #   error while writing to output stream
  # :surface_finished ::
  #   target surface has been finished
  # :surface_type_mismatch ::
  #   the surface type is not appropriate for the operation
  # :pattern_type_mismatch ::
  #   the pattern type is not appropriate for the operation
  # :invalid_content ::
  #   invalid value for an input #cairo_content_t
  # :invalid_format ::
  #   invalid value for an input #cairo_format_t
  # :invalid_visual ::
  #   invalid value for an input Visual*
  # :file_not_found ::
  #   file not found
  # :invalid_dash ::
  #   invalid value for a dash setting
  # :invalid_dsc_comment ::
  #   invalid value for a DSC comment (Since 1.2)
  # :invalid_index ::
  #   invalid index passed to getter (Since 1.4)
  # :clip_not_representable ::
  #   clip region not representable in desired format (Since 1.4)
  # :temp_file_error ::
  #   error creating or writing to a temporary file (Since 1.6)
  # :invalid_stride ::
  #   invalid value for stride (Since 1.6)
  # :font_type_mismatch ::
  #   the font type is not appropriate for the operation (Since 1.8)
  # :user_font_immutable ::
  #   the user-font is immutable (Since 1.8)
  # :user_font_error ::
  #   error occurred in a user-font callback function (Since 1.8)
  # :negative_count ::
  #   negative number used where it is not allowed (Since 1.8)
  # :invalid_clusters ::
  #   input clusters do not represent the accompanying text and glyph array (Since 1.8)
  # :invalid_slant ::
  #   invalid value for an input #cairo_font_slant_t (Since 1.8)
  # :invalid_weight ::
  #   invalid value for an input #cairo_font_weight_t (Since 1.8)
  # :invalid_size ::
  #   invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
  # :user_font_not_implemented ::
  #   user-font method not implemented (Since 1.10)
  # :device_type_mismatch ::
  #   the device type is not appropriate for the operation (Since 1.10)
  # :device_error ::
  #   an operation to the device caused an unspecified error (Since 1.10)
  # :last_status ::
  #   this is a special value indicating the number of
  #     status values defined in this enumeration.  When using this value, note
  #     that the version of cairo at run-time may have additional status values
  #     defined than the value of this symbol at compile-time. (Since 1.10)
  # 
  # @method _enum_status_
  # @return [Symbol]
  # @scope class
  enum :status, [
    :success, 0,
    :no_memory, 1,
    :invalid_restore, 2,
    :invalid_pop_group, 3,
    :no_current_point, 4,
    :invalid_matrix, 5,
    :invalid_status, 6,
    :null_pointer, 7,
    :invalid_string, 8,
    :invalid_path_data, 9,
    :read_error, 10,
    :write_error, 11,
    :surface_finished, 12,
    :surface_type_mismatch, 13,
    :pattern_type_mismatch, 14,
    :invalid_content, 15,
    :invalid_format, 16,
    :invalid_visual, 17,
    :file_not_found, 18,
    :invalid_dash, 19,
    :invalid_dsc_comment, 20,
    :invalid_index, 21,
    :clip_not_representable, 22,
    :temp_file_error, 23,
    :invalid_stride, 24,
    :font_type_mismatch, 25,
    :user_font_immutable, 26,
    :user_font_error, 27,
    :negative_count, 28,
    :invalid_clusters, 29,
    :invalid_slant, 30,
    :invalid_weight, 31,
    :invalid_size, 32,
    :user_font_not_implemented, 33,
    :device_type_mismatch, 34,
    :device_error, 35,
    :last_status, 36
  ]
  
  # cairo_content_t:
  # 
  # #cairo_content_t is used to describe the content that a surface will
  # contain, whether color information, alpha information (translucence
  # vs. opacity), or both.
  # 
  # Note: The large values here are designed to keep #cairo_content_t
  # values distinct from #cairo_format_t values so that the
  # implementation can detect the error if users confuse the two types.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:content).</em>
  # 
  # === Options:
  # :color ::
  #   The surface will hold color content only.
  # :alpha ::
  #   The surface will hold alpha content only.
  # :color_alpha ::
  #   The surface will hold color and alpha content.
  # 
  # @method _enum_content_
  # @return [Symbol]
  # @scope class
  enum :content, [
    :color, 4096,
    :alpha, 8192,
    :color_alpha, 12288
  ]
  
  # cairo_write_func_t:
  # @closure: the output closure
  # @data: the buffer containing the data to write
  # @length: the amount of data to write
  # 
  # #cairo_write_func_t is the type of function which is called when a
  # backend needs to write data to an output stream.  It is passed the
  # closure which was specified by the user at the time the write
  # function was registered, the data to write and the length of the
  # data in bytes.  The write function should return
  # %CAIRO_STATUS_SUCCESS if all the data was successfully written,
  # %CAIRO_STATUS_WRITE_ERROR otherwise.
  # 
  # Returns: the status code of the write operation
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_write_func_t_(closure, data, length)
  # @param [FFI::Pointer(*Void)] closure 
  # @param [FFI::Pointer(*UChar)] data 
  # @param [Integer] length 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :write_func_t, [:pointer, :pointer, :uint], :status
  
  # cairo_read_func_t:
  # @closure: the input closure
  # @data: the buffer into which to read the data
  # @length: the amount of data to read
  # 
  # #cairo_read_func_t is the type of function which is called when a
  # backend needs to read data from an input stream.  It is passed the
  # closure which was specified by the user at the time the read
  # function was registered, the buffer to read the data into and the
  # length of the data in bytes.  The read function should return
  # %CAIRO_STATUS_SUCCESS if all the data was successfully read,
  # %CAIRO_STATUS_READ_ERROR otherwise.
  # 
  # Returns: the status code of the read operation
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_read_func_t_(closure, data, length)
  # @param [FFI::Pointer(*Void)] closure 
  # @param [FFI::Pointer(*UChar)] data 
  # @param [Integer] length 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :read_func_t, [:pointer, :pointer, :uint], :status
  
  # Functions for manipulating state objects
  # 
  # @method create(target)
  # @param [Surface] target 
  # @return [Cairo] 
  # @scope class
  attach_function :create, :cairo_create, [Surface], Cairo
  
  # (Not documented)
  # 
  # @method reference(cr)
  # @param [Cairo] cr 
  # @return [Cairo] 
  # @scope class
  attach_function :reference, :cairo_reference, [Cairo], Cairo
  
  # (Not documented)
  # 
  # @method destroy(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :destroy, :cairo_destroy, [Cairo], :void
  
  # (Not documented)
  # 
  # @method get_reference_count(cr)
  # @param [Cairo] cr 
  # @return [Integer] 
  # @scope class
  attach_function :get_reference_count, :cairo_get_reference_count, [Cairo], :uint
  
  # (Not documented)
  # 
  # @method get_user_data(cr, key)
  # @param [Cairo] cr 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :get_user_data, :cairo_get_user_data, [Cairo, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method set_user_data(cr, key, user_data, destroy)
  # @param [Cairo] cr 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :set_user_data, :cairo_set_user_data, [Cairo, UserDataKey, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method save(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :save, :cairo_save, [Cairo], :void
  
  # (Not documented)
  # 
  # @method restore(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :restore, :cairo_restore, [Cairo], :void
  
  # (Not documented)
  # 
  # @method push_group(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :push_group, :cairo_push_group, [Cairo], :void
  
  # (Not documented)
  # 
  # @method push_group_with_content(cr, content)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_content_] content 
  # @return [nil] 
  # @scope class
  attach_function :push_group_with_content, :cairo_push_group_with_content, [Cairo, :content], :void
  
  # (Not documented)
  # 
  # @method pop_group(cr)
  # @param [Cairo] cr 
  # @return [Pattern] 
  # @scope class
  attach_function :pop_group, :cairo_pop_group, [Cairo], Pattern
  
  # (Not documented)
  # 
  # @method pop_group_to_source(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :pop_group_to_source, :cairo_pop_group_to_source, [Cairo], :void
  
  # cairo_operator_t:
  # 
  # #cairo_operator_t is used to set the compositing operator for all cairo
  # drawing operations.
  # 
  # The default operator is %CAIRO_OPERATOR_OVER.
  # 
  # The operators marked as <firstterm>unbounded</firstterm> modify their
  # destination even outside of the mask layer (that is, their effect is not
  # bound by the mask layer).  However, their effect can still be limited by
  # way of clipping.
  # 
  # To keep things simple, the operator descriptions here
  # document the behavior for when both source and destination are either fully
  # transparent or fully opaque.  The actual implementation works for
  # translucent layers too.
  # For a more detailed explanation of the effects of each operator, including
  # the mathematical definitions, see
  # <ulink url="http://cairographics.org/operators/">http://cairographics.org/operators/</ulink>.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:operator).</em>
  # 
  # === Options:
  # :clear ::
  #   clear destination layer (bounded)
  # :source ::
  #   replace destination layer (bounded)
  # :over ::
  #   draw source layer on top of destination layer
  #   (bounded)
  # :in_ ::
  #   draw source where there was destination content
  #   (unbounded)
  # :out ::
  #   draw source where there was no destination
  #   content (unbounded)
  # :atop ::
  #   draw source on top of destination content and
  #   only there
  # :dest ::
  #   ignore the source
  # :dest_over ::
  #   draw destination on top of source
  # :dest_in ::
  #   leave destination only where there was
  #   source content (unbounded)
  # :dest_out ::
  #   leave destination only where there was no
  #   source content
  # :dest_atop ::
  #   leave destination on top of source content
  #   and only there (unbounded)
  # :xor ::
  #   source and destination are shown where there is only
  #   one of them
  # :add ::
  #   source and destination layers are accumulated
  # :saturate ::
  #   like over, but assuming source and dest are
  #   disjoint geometries
  # :multiply ::
  #   source and destination layers are multiplied.
  #   This causes the result to be at least as dark as the darker inputs.
  # :screen ::
  #   source and destination are complemented and
  #   multiplied. This causes the result to be at least as light as the lighter
  #   inputs.
  # :overlay ::
  #   multiplies or screens, depending on the
  #   lightness of the destination color.
  # :darken ::
  #   replaces the destination with the source if it
  #   is darker, otherwise keeps the source.
  # :lighten ::
  #   replaces the destination with the source if it
  #   is lighter, otherwise keeps the source.
  # :color_dodge ::
  #   brightens the destination color to reflect
  #   the source color.
  # :color_burn ::
  #   darkens the destination color to reflect
  #   the source color.
  # :hard_light ::
  #   Multiplies or screens, dependant on source
  #   color.
  # :soft_light ::
  #   Darkens or lightens, dependant on source
  #   color.
  # :difference ::
  #   Takes the difference of the source and
  #   destination color.
  # :exclusion ::
  #   Produces an effect similar to difference, but
  #   with lower contrast.
  # :hsl_hue ::
  #   Creates a color with the hue of the source
  #   and the saturation and luminosity of the target.
  # :hsl_saturation ::
  #   Creates a color with the saturation
  #   of the source and the hue and luminosity of the target. Painting with
  #   this mode onto a gray area prduces no change.
  # :hsl_color ::
  #   Creates a color with the hue and saturation
  #   of the source and the luminosity of the target. This preserves the gray
  #   levels of the target and is useful for coloring monochrome images or
  #   tinting color images.
  # :hsl_luminosity ::
  #   Creates a color with the luminosity of
  #   the source and the hue and saturation of the target. This produces an
  #   inverse effect to @CAIRO_OPERATOR_HSL_COLOR.
  # 
  # @method _enum_operator_
  # @return [Symbol]
  # @scope class
  enum :operator, [
    :clear, 0,
    :source, 1,
    :over, 2,
    :in_, 3,
    :out, 4,
    :atop, 5,
    :dest, 6,
    :dest_over, 7,
    :dest_in, 8,
    :dest_out, 9,
    :dest_atop, 10,
    :xor, 11,
    :add, 12,
    :saturate, 13,
    :multiply, 14,
    :screen, 15,
    :overlay, 16,
    :darken, 17,
    :lighten, 18,
    :color_dodge, 19,
    :color_burn, 20,
    :hard_light, 21,
    :soft_light, 22,
    :difference, 23,
    :exclusion, 24,
    :hsl_hue, 25,
    :hsl_saturation, 26,
    :hsl_color, 27,
    :hsl_luminosity, 28
  ]
  
  # (Not documented)
  # 
  # @method set_operator(cr, op)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_operator_] op 
  # @return [nil] 
  # @scope class
  attach_function :set_operator, :cairo_set_operator, [Cairo, :operator], :void
  
  # (Not documented)
  # 
  # @method set_source(cr, source)
  # @param [Cairo] cr 
  # @param [Pattern] source 
  # @return [nil] 
  # @scope class
  attach_function :set_source, :cairo_set_source, [Cairo, Pattern], :void
  
  # (Not documented)
  # 
  # @method set_source_rgb(cr, red, green, blue)
  # @param [Cairo] cr 
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @return [nil] 
  # @scope class
  attach_function :set_source_rgb, :cairo_set_source_rgb, [Cairo, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method set_source_rgba(cr, red, green, blue, alpha)
  # @param [Cairo] cr 
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @param [Float] alpha 
  # @return [nil] 
  # @scope class
  attach_function :set_source_rgba, :cairo_set_source_rgba, [Cairo, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method set_source_surface(cr, surface, x, y)
  # @param [Cairo] cr 
  # @param [Surface] surface 
  # @param [Float] x 
  # @param [Float] y 
  # @return [nil] 
  # @scope class
  attach_function :set_source_surface, :cairo_set_source_surface, [Cairo, Surface, :double, :double], :void
  
  # (Not documented)
  # 
  # @method set_tolerance(cr, tolerance)
  # @param [Cairo] cr 
  # @param [Float] tolerance 
  # @return [nil] 
  # @scope class
  attach_function :set_tolerance, :cairo_set_tolerance, [Cairo, :double], :void
  
  # cairo_antialias_t:
  # 
  # Specifies the type of antialiasing to do when rendering text or shapes.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:antialias).</em>
  # 
  # === Options:
  # :default ::
  #   Use the default antialiasing for
  #     the subsystem and target device
  # :none ::
  #   Use a bilevel alpha mask
  # :gray ::
  #   Perform single-color antialiasing (using
  #    shades of gray for black text on a white background, for example).
  # :subpixel ::
  #   Perform antialiasing by taking
  #    advantage of the order of subpixel elements on devices
  #    such as LCD panels
  # 
  # @method _enum_antialias_
  # @return [Symbol]
  # @scope class
  enum :antialias, [
    :default, 0,
    :none, 1,
    :gray, 2,
    :subpixel, 3
  ]
  
  # (Not documented)
  # 
  # @method set_antialias(cr, antialias)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_antialias_] antialias 
  # @return [nil] 
  # @scope class
  attach_function :set_antialias, :cairo_set_antialias, [Cairo, :antialias], :void
  
  # cairo_fill_rule_t:
  # 
  # #cairo_fill_rule_t is used to select how paths are filled. For both
  # fill rules, whether or not a point is included in the fill is
  # determined by taking a ray from that point to infinity and looking
  # at intersections with the path. The ray can be in any direction,
  # as long as it doesn't pass through the end point of a segment
  # or have a tricky intersection such as intersecting tangent to the path.
  # (Note that filling is not actually implemented in this way. This
  # is just a description of the rule that is applied.)
  # 
  # The default fill rule is %CAIRO_FILL_RULE_WINDING.
  # 
  # New entries may be added in future versions.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fill_rule).</em>
  # 
  # === Options:
  # :winding ::
  #   If the path crosses the ray from
  #   left-to-right, counts +1. If the path crosses the ray
  #   from right to left, counts -1. (Left and right are determined
  #   from the perspective of looking along the ray from the starting
  #   point.) If the total count is non-zero, the point will be filled.
  # :even_odd ::
  #   Counts the total number of
  #   intersections, without regard to the orientation of the contour. If
  #   the total number of intersections is odd, the point will be
  #   filled.
  # 
  # @method _enum_fill_rule_
  # @return [Symbol]
  # @scope class
  enum :fill_rule, [
    :winding, 0,
    :even_odd, 1
  ]
  
  # (Not documented)
  # 
  # @method set_fill_rule(cr, fill_rule)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_fill_rule_] fill_rule 
  # @return [nil] 
  # @scope class
  attach_function :set_fill_rule, :cairo_set_fill_rule, [Cairo, :fill_rule], :void
  
  # (Not documented)
  # 
  # @method set_line_width(cr, width)
  # @param [Cairo] cr 
  # @param [Float] width 
  # @return [nil] 
  # @scope class
  attach_function :set_line_width, :cairo_set_line_width, [Cairo, :double], :void
  
  # cairo_line_cap_t:
  # 
  # Specifies how to render the endpoints of the path when stroking.
  # 
  # The default line cap style is %CAIRO_LINE_CAP_BUTT.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:line_cap).</em>
  # 
  # === Options:
  # :butt ::
  #   start(stop) the line exactly at the start(end) point
  # :round ::
  #   use a round ending, the center of the circle is the end point
  # :square ::
  #   use squared ending, the center of the square is the end point
  # 
  # @method _enum_line_cap_
  # @return [Symbol]
  # @scope class
  enum :line_cap, [
    :butt, 0,
    :round, 1,
    :square, 2
  ]
  
  # (Not documented)
  # 
  # @method set_line_cap(cr, line_cap)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_line_cap_] line_cap 
  # @return [nil] 
  # @scope class
  attach_function :set_line_cap, :cairo_set_line_cap, [Cairo, :line_cap], :void
  
  # cairo_line_join_t:
  # 
  # Specifies how to render the junction of two lines when stroking.
  # 
  # The default line join style is %CAIRO_LINE_JOIN_MITER.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:line_join).</em>
  # 
  # === Options:
  # :miter ::
  #   use a sharp (angled) corner, see
  #   cairo_set_miter_limit()
  # :round ::
  #   use a rounded join, the center of the circle is the
  #   joint point
  # :bevel ::
  #   use a cut-off join, the join is cut off at half
  #   the line width from the joint point
  # 
  # @method _enum_line_join_
  # @return [Symbol]
  # @scope class
  enum :line_join, [
    :miter, 0,
    :round, 1,
    :bevel, 2
  ]
  
  # (Not documented)
  # 
  # @method set_line_join(cr, line_join)
  # @param [Cairo] cr 
  # @param [Symbol from _enum_line_join_] line_join 
  # @return [nil] 
  # @scope class
  attach_function :set_line_join, :cairo_set_line_join, [Cairo, :line_join], :void
  
  # (Not documented)
  # 
  # @method set_dash(cr, dashes, num_dashes, offset)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] dashes 
  # @param [Integer] num_dashes 
  # @param [Float] offset 
  # @return [nil] 
  # @scope class
  attach_function :set_dash, :cairo_set_dash, [Cairo, :pointer, :int, :double], :void
  
  # (Not documented)
  # 
  # @method set_miter_limit(cr, limit)
  # @param [Cairo] cr 
  # @param [Float] limit 
  # @return [nil] 
  # @scope class
  attach_function :set_miter_limit, :cairo_set_miter_limit, [Cairo, :double], :void
  
  # (Not documented)
  # 
  # @method translate(cr, tx, ty)
  # @param [Cairo] cr 
  # @param [Float] tx 
  # @param [Float] ty 
  # @return [nil] 
  # @scope class
  attach_function :translate, :cairo_translate, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method scale(cr, sx, sy)
  # @param [Cairo] cr 
  # @param [Float] sx 
  # @param [Float] sy 
  # @return [nil] 
  # @scope class
  attach_function :scale, :cairo_scale, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method rotate(cr, angle)
  # @param [Cairo] cr 
  # @param [Float] angle 
  # @return [nil] 
  # @scope class
  attach_function :rotate, :cairo_rotate, [Cairo, :double], :void
  
  # (Not documented)
  # 
  # @method transform(cr, matrix)
  # @param [Cairo] cr 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :transform, :cairo_transform, [Cairo, Matrix], :void
  
  # (Not documented)
  # 
  # @method set_matrix(cr, matrix)
  # @param [Cairo] cr 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :set_matrix, :cairo_set_matrix, [Cairo, Matrix], :void
  
  # (Not documented)
  # 
  # @method identity_matrix(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :identity_matrix, :cairo_identity_matrix, [Cairo], :void
  
  # (Not documented)
  # 
  # @method user_to_device(cr, x, y)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x 
  # @param [FFI::Pointer(*Double)] y 
  # @return [nil] 
  # @scope class
  attach_function :user_to_device, :cairo_user_to_device, [Cairo, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method user_to_device_distance(cr, dx, dy)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] dx 
  # @param [FFI::Pointer(*Double)] dy 
  # @return [nil] 
  # @scope class
  attach_function :user_to_device_distance, :cairo_user_to_device_distance, [Cairo, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method device_to_user(cr, x, y)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x 
  # @param [FFI::Pointer(*Double)] y 
  # @return [nil] 
  # @scope class
  attach_function :device_to_user, :cairo_device_to_user, [Cairo, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method device_to_user_distance(cr, dx, dy)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] dx 
  # @param [FFI::Pointer(*Double)] dy 
  # @return [nil] 
  # @scope class
  attach_function :device_to_user_distance, :cairo_device_to_user_distance, [Cairo, :pointer, :pointer], :void
  
  # Path creation functions
  # 
  # @method new_path(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :new_path, :cairo_new_path, [Cairo], :void
  
  # (Not documented)
  # 
  # @method move_to(cr, x, y)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @return [nil] 
  # @scope class
  attach_function :move_to, :cairo_move_to, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method new_sub_path(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :new_sub_path, :cairo_new_sub_path, [Cairo], :void
  
  # (Not documented)
  # 
  # @method line_to(cr, x, y)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @return [nil] 
  # @scope class
  attach_function :line_to, :cairo_line_to, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method curve_to(cr, x1, y1, x2, y2, x3, y3)
  # @param [Cairo] cr 
  # @param [Float] x1 
  # @param [Float] y1 
  # @param [Float] x2 
  # @param [Float] y2 
  # @param [Float] x3 
  # @param [Float] y3 
  # @return [nil] 
  # @scope class
  attach_function :curve_to, :cairo_curve_to, [Cairo, :double, :double, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method arc(cr, xc, yc, radius, angle1, angle2)
  # @param [Cairo] cr 
  # @param [Float] xc 
  # @param [Float] yc 
  # @param [Float] radius 
  # @param [Float] angle1 
  # @param [Float] angle2 
  # @return [nil] 
  # @scope class
  attach_function :arc, :cairo_arc, [Cairo, :double, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method arc_negative(cr, xc, yc, radius, angle1, angle2)
  # @param [Cairo] cr 
  # @param [Float] xc 
  # @param [Float] yc 
  # @param [Float] radius 
  # @param [Float] angle1 
  # @param [Float] angle2 
  # @return [nil] 
  # @scope class
  attach_function :arc_negative, :cairo_arc_negative, [Cairo, :double, :double, :double, :double, :double], :void
  
  # XXX: NYI
  # cairo_public void
  # cairo_arc_to (cairo_t *cr,
  #           double x1, double y1,
  #           double x2, double y2,
  #           double radius);
  # 
  # @method rel_move_to(cr, dx, dy)
  # @param [Cairo] cr 
  # @param [Float] dx 
  # @param [Float] dy 
  # @return [nil] 
  # @scope class
  attach_function :rel_move_to, :cairo_rel_move_to, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method rel_line_to(cr, dx, dy)
  # @param [Cairo] cr 
  # @param [Float] dx 
  # @param [Float] dy 
  # @return [nil] 
  # @scope class
  attach_function :rel_line_to, :cairo_rel_line_to, [Cairo, :double, :double], :void
  
  # (Not documented)
  # 
  # @method rel_curve_to(cr, dx1, dy1, dx2, dy2, dx3, dy3)
  # @param [Cairo] cr 
  # @param [Float] dx1 
  # @param [Float] dy1 
  # @param [Float] dx2 
  # @param [Float] dy2 
  # @param [Float] dx3 
  # @param [Float] dy3 
  # @return [nil] 
  # @scope class
  attach_function :rel_curve_to, :cairo_rel_curve_to, [Cairo, :double, :double, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method rectangle(cr, x, y, width, height)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @param [Float] width 
  # @param [Float] height 
  # @return [nil] 
  # @scope class
  attach_function :rectangle, :cairo_rectangle, [Cairo, :double, :double, :double, :double], :void
  
  # XXX: NYI
  # cairo_public void
  # cairo_stroke_to_path (cairo_t *cr);
  # 
  # @method close_path(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :close_path, :cairo_close_path, [Cairo], :void
  
  # (Not documented)
  # 
  # @method path_extents(cr, x1, y1, x2, y2)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @param [FFI::Pointer(*Double)] x2 
  # @param [FFI::Pointer(*Double)] y2 
  # @return [nil] 
  # @scope class
  attach_function :path_extents, :cairo_path_extents, [Cairo, :pointer, :pointer, :pointer, :pointer], :void
  
  # Painting functions
  # 
  # @method paint(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :paint, :cairo_paint, [Cairo], :void
  
  # (Not documented)
  # 
  # @method paint_with_alpha(cr, alpha)
  # @param [Cairo] cr 
  # @param [Float] alpha 
  # @return [nil] 
  # @scope class
  attach_function :paint_with_alpha, :cairo_paint_with_alpha, [Cairo, :double], :void
  
  # (Not documented)
  # 
  # @method mask(cr, pattern)
  # @param [Cairo] cr 
  # @param [Pattern] pattern 
  # @return [nil] 
  # @scope class
  attach_function :mask, :cairo_mask, [Cairo, Pattern], :void
  
  # (Not documented)
  # 
  # @method mask_surface(cr, surface, surface_x, surface_y)
  # @param [Cairo] cr 
  # @param [Surface] surface 
  # @param [Float] surface_x 
  # @param [Float] surface_y 
  # @return [nil] 
  # @scope class
  attach_function :mask_surface, :cairo_mask_surface, [Cairo, Surface, :double, :double], :void
  
  # (Not documented)
  # 
  # @method stroke(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :stroke, :cairo_stroke, [Cairo], :void
  
  # (Not documented)
  # 
  # @method stroke_preserve(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :stroke_preserve, :cairo_stroke_preserve, [Cairo], :void
  
  # (Not documented)
  # 
  # @method fill(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :fill, :cairo_fill, [Cairo], :void
  
  # (Not documented)
  # 
  # @method fill_preserve(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :fill_preserve, :cairo_fill_preserve, [Cairo], :void
  
  # (Not documented)
  # 
  # @method copy_page(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :copy_page, :cairo_copy_page, [Cairo], :void
  
  # (Not documented)
  # 
  # @method show_page(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :show_page, :cairo_show_page, [Cairo], :void
  
  # Insideness testing
  # 
  # @method in_stroke(cr, x, y)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @return [Integer] 
  # @scope class
  attach_function :in_stroke, :cairo_in_stroke, [Cairo, :double, :double], :int
  
  # (Not documented)
  # 
  # @method in_fill(cr, x, y)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @return [Integer] 
  # @scope class
  attach_function :in_fill, :cairo_in_fill, [Cairo, :double, :double], :int
  
  # (Not documented)
  # 
  # @method in_clip(cr, x, y)
  # @param [Cairo] cr 
  # @param [Float] x 
  # @param [Float] y 
  # @return [Integer] 
  # @scope class
  attach_function :in_clip, :cairo_in_clip, [Cairo, :double, :double], :int
  
  # Rectangular extents
  # 
  # @method stroke_extents(cr, x1, y1, x2, y2)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @param [FFI::Pointer(*Double)] x2 
  # @param [FFI::Pointer(*Double)] y2 
  # @return [nil] 
  # @scope class
  attach_function :stroke_extents, :cairo_stroke_extents, [Cairo, :pointer, :pointer, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method fill_extents(cr, x1, y1, x2, y2)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @param [FFI::Pointer(*Double)] x2 
  # @param [FFI::Pointer(*Double)] y2 
  # @return [nil] 
  # @scope class
  attach_function :fill_extents, :cairo_fill_extents, [Cairo, :pointer, :pointer, :pointer, :pointer], :void
  
  # Clipping
  # 
  # @method reset_clip(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :reset_clip, :cairo_reset_clip, [Cairo], :void
  
  # (Not documented)
  # 
  # @method clip(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :clip, :cairo_clip, [Cairo], :void
  
  # (Not documented)
  # 
  # @method clip_preserve(cr)
  # @param [Cairo] cr 
  # @return [nil] 
  # @scope class
  attach_function :clip_preserve, :cairo_clip_preserve, [Cairo], :void
  
  # (Not documented)
  # 
  # @method clip_extents(cr, x1, y1, x2, y2)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @param [FFI::Pointer(*Double)] x2 
  # @param [FFI::Pointer(*Double)] y2 
  # @return [nil] 
  # @scope class
  attach_function :clip_extents, :cairo_clip_extents, [Cairo, :pointer, :pointer, :pointer, :pointer], :void
  
  # cairo_rectangle_t:
  # @x: X coordinate of the left side of the rectangle
  # @y: Y coordinate of the the top side of the rectangle
  # @width: width of the rectangle
  # @height: height of the rectangle
  # 
  # A data structure for holding a rectangle.
  # 
  # Since: 1.4
  # 
  # = Fields:
  # :x ::
  #   (Float) 
  # :y ::
  #   (Float) 
  # :width ::
  #   (Float) 
  # :height ::
  #   (Float) 
  class Rectangle < FFI::Struct
    layout :x, :double,
           :y, :double,
           :width, :double,
           :height, :double
  end
  
  # cairo_rectangle_list_t:
  # @status: Error status of the rectangle list
  # @rectangles: Array containing the rectangles
  # @num_rectangles: Number of rectangles in this list
  # 
  # A data structure for holding a dynamically allocated
  # array of rectangles.
  # 
  # Since: 1.4
  # 
  # = Fields:
  # :status ::
  #   (Symbol from _enum_status_) 
  # :rectangles ::
  #   (Rectangle) 
  # :num_rectangles ::
  #   (Integer) 
  module RectangleListWrappers
    def destroy()
      Cairo.rectangle_list_destroy(self)
    end
  end
  
  class RectangleList < FFI::Struct
    include RectangleListWrappers
    layout :status, :status,
           :rectangles, Rectangle,
           :num_rectangles, :int
  end
  
  # (Not documented)
  # 
  # @method copy_clip_rectangle_list(cr)
  # @param [Cairo] cr 
  # @return [RectangleList] 
  # @scope class
  attach_function :copy_clip_rectangle_list, :cairo_copy_clip_rectangle_list, [Cairo], RectangleList
  
  # (Not documented)
  # 
  # @method rectangle_list_destroy(rectangle_list)
  # @param [RectangleList] rectangle_list 
  # @return [nil] 
  # @scope class
  attach_function :rectangle_list_destroy, :cairo_rectangle_list_destroy, [RectangleList], :void
  
  # cairo_scaled_font_t:
  # 
  # A #cairo_scaled_font_t is a font scaled to a particular size and device
  # resolution. A #cairo_scaled_font_t is most useful for low-level font
  # usage where a library or application wants to cache a reference
  # to a scaled font to speed up the computation of metrics.
  # 
  # There are various types of scaled fonts, depending on the
  # <firstterm>font backend</firstterm> they use. The type of a
  # scaled font can be queried using cairo_scaled_font_get_type().
  # 
  # Memory management of #cairo_scaled_font_t is done with
  # cairo_scaled_font_reference() and cairo_scaled_font_destroy().
  module ScaledFontWrappers
    def reference()
      ScaledFont.new Cairo.scaled_font_reference(self)
    end
    
    def destroy()
      Cairo.scaled_font_destroy(self)
    end
    
    def get_reference_count()
      Cairo.scaled_font_get_reference_count(self)
    end
    
    def status()
      Cairo.scaled_font_status(self)
    end
    
    def get_type()
      Cairo.scaled_font_get_type(self)
    end
    
    def get_user_data(key)
      Cairo.scaled_font_get_user_data(self, key)
    end
    
    def set_user_data(key, user_data, destroy)
      Cairo.scaled_font_set_user_data(self, key, user_data, destroy)
    end
    
    def extents(extents)
      Cairo.scaled_font_extents(self, extents)
    end
    
    def text_extents(utf8, extents)
      Cairo.scaled_font_text_extents(self, utf8, extents)
    end
    
    def glyph_extents(glyphs, num_glyphs, extents)
      Cairo.scaled_font_glyph_extents(self, glyphs, num_glyphs, extents)
    end
    
    def text_to_glyphs(x, y, utf8, utf8_len, glyphs, num_glyphs, clusters, num_clusters, cluster_flags)
      Cairo.scaled_font_text_to_glyphs(self, x, y, utf8, utf8_len, glyphs, num_glyphs, clusters, num_clusters, cluster_flags)
    end
    
    def get_font_face()
      FontFace.new Cairo.scaled_font_get_font_face(self)
    end
    
    def get_font_matrix(font_matrix)
      Cairo.scaled_font_get_font_matrix(self, font_matrix)
    end
    
    def get_ctm(ctm)
      Cairo.scaled_font_get_ctm(self, ctm)
    end
    
    def get_scale_matrix(scale_matrix)
      Cairo.scaled_font_get_scale_matrix(self, scale_matrix)
    end
    
    def get_font_options(options)
      Cairo.scaled_font_get_font_options(self, options)
    end
  end
  
  class ScaledFont < FFI::Struct
    include ScaledFontWrappers
    layout :dummy, :char
  end
  
  # cairo_font_face_t:
  # 
  # A #cairo_font_face_t specifies all aspects of a font other
  # than the size or font matrix (a font matrix is used to distort
  # a font by sheering it or scaling it unequally in the two
  # directions) . A font face can be set on a #cairo_t by using
  # cairo_set_font_face(); the size and font matrix are set with
  # cairo_set_font_size() and cairo_set_font_matrix().
  # 
  # There are various types of font faces, depending on the
  # <firstterm>font backend</firstterm> they use. The type of a
  # font face can be queried using cairo_font_face_get_type().
  # 
  # Memory management of #cairo_font_face_t is done with
  # cairo_font_face_reference() and cairo_font_face_destroy().
  module FontFaceWrappers
    def reference()
      FontFace.new Cairo.font_face_reference(self)
    end
    
    def destroy()
      Cairo.font_face_destroy(self)
    end
    
    def get_reference_count()
      Cairo.font_face_get_reference_count(self)
    end
    
    def status()
      Cairo.font_face_status(self)
    end
    
    def get_type()
      Cairo.font_face_get_type(self)
    end
    
    def get_user_data(key)
      Cairo.font_face_get_user_data(self, key)
    end
    
    def set_user_data(key, user_data, destroy)
      Cairo.font_face_set_user_data(self, key, user_data, destroy)
    end
  end
  
  class FontFace < FFI::Struct
    include FontFaceWrappers
    layout :dummy, :char
  end
  
  # cairo_glyph_t:
  # @index: glyph index in the font. The exact interpretation of the
  #      glyph index depends on the font technology being used.
  # @x: the offset in the X direction between the origin used for
  #     drawing or measuring the string and the origin of this glyph.
  # @y: the offset in the Y direction between the origin used for
  #     drawing or measuring the string and the origin of this glyph.
  # 
  # The #cairo_glyph_t structure holds information about a single glyph
  # when drawing or measuring text. A font is (in simple terms) a
  # collection of shapes used to draw text. A glyph is one of these
  # shapes. There can be multiple glyphs for a single character
  # (alternates to be used in different contexts, for example), or a
  # glyph can be a <firstterm>ligature</firstterm> of multiple
  # characters. Cairo doesn't expose any way of converting input text
  # into glyphs, so in order to use the Cairo interfaces that take
  # arrays of glyphs, you must directly access the appropriate
  # underlying font system.
  # 
  # Note that the offsets given by @x and @y are not cumulative. When
  # drawing or measuring text, each glyph is individually positioned
  # with respect to the overall origin
  # 
  # = Fields:
  # :index ::
  #   (Integer) 
  # :x ::
  #   (Float) 
  # :y ::
  #   (Float) 
  class GlyphT < FFI::Struct
    layout :index, :ulong,
           :x, :double,
           :y, :double
  end
  
  # (Not documented)
  # 
  # @method glyph_allocate(num_glyphs)
  # @param [Integer] num_glyphs 
  # @return [GlyphT] 
  # @scope class
  attach_function :glyph_allocate, :cairo_glyph_allocate, [:int], GlyphT
  
  # (Not documented)
  # 
  # @method glyph_free(glyphs)
  # @param [GlyphT] glyphs 
  # @return [nil] 
  # @scope class
  attach_function :glyph_free, :cairo_glyph_free, [GlyphT], :void
  
  # cairo_text_cluster_t:
  # @num_bytes: the number of bytes of UTF-8 text covered by cluster
  # @num_glyphs: the number of glyphs covered by cluster
  # 
  # The #cairo_text_cluster_t structure holds information about a single
  # <firstterm>text cluster</firstterm>.  A text cluster is a minimal
  # mapping of some glyphs corresponding to some UTF-8 text.
  # 
  # For a cluster to be valid, both @num_bytes and @num_glyphs should
  # be non-negative, and at least one should be non-zero.
  # Note that clusters with zero glyphs are not as well supported as
  # normal clusters.  For example, PDF rendering applications typically
  # ignore those clusters when PDF text is being selected.
  # 
  # See cairo_show_text_glyphs() for how clusters are used in advanced
  # text operations.
  # 
  # Since: 1.8
  # 
  # = Fields:
  # :num_bytes ::
  #   (Integer) 
  # :num_glyphs ::
  #   (Integer) 
  class TextClusterT < FFI::Struct
    layout :num_bytes, :int,
           :num_glyphs, :int
  end
  
  # (Not documented)
  # 
  # @method text_cluster_allocate(num_clusters)
  # @param [Integer] num_clusters 
  # @return [TextClusterT] 
  # @scope class
  attach_function :text_cluster_allocate, :cairo_text_cluster_allocate, [:int], TextClusterT
  
  # (Not documented)
  # 
  # @method text_cluster_free(clusters)
  # @param [TextClusterT] clusters 
  # @return [nil] 
  # @scope class
  attach_function :text_cluster_free, :cairo_text_cluster_free, [TextClusterT], :void
  
  # cairo_text_cluster_flags_t:
  # 
  # Specifies properties of a text cluster mapping.
  # 
  # Since: 1.8
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:text_cluster_flags).</em>
  # 
  # === Options:
  # :text_cluster_flag_backward ::
  #   The clusters in the cluster array
  #   map to glyphs in the glyph array from end to start.
  # 
  # @method _enum_text_cluster_flags_
  # @return [Symbol]
  # @scope class
  enum :text_cluster_flags, [
    :text_cluster_flag_backward, 1
  ]
  
  # cairo_text_extents_t:
  # @x_bearing: the horizontal distance from the origin to the
  #   leftmost part of the glyphs as drawn. Positive if the
  #   glyphs lie entirely to the right of the origin.
  # @y_bearing: the vertical distance from the origin to the
  #   topmost part of the glyphs as drawn. Positive only if the
  #   glyphs lie completely below the origin; will usually be
  #   negative.
  # @width: width of the glyphs as drawn
  # @height: height of the glyphs as drawn
  # @x_advance:distance to advance in the X direction
  #    after drawing these glyphs
  # @y_advance: distance to advance in the Y direction
  #   after drawing these glyphs. Will typically be zero except
  #   for vertical text layout as found in East-Asian languages.
  # 
  # The #cairo_text_extents_t structure stores the extents of a single
  # glyph or a string of glyphs in user-space coordinates. Because text
  # extents are in user-space coordinates, they are mostly, but not
  # entirely, independent of the current transformation matrix. If you call
  # <literal>cairo_scale(cr, 2.0, 2.0)</literal>, text will
  # be drawn twice as big, but the reported text extents will not be
  # doubled. They will change slightly due to hinting (so you can't
  # assume that metrics are independent of the transformation matrix),
  # but otherwise will remain unchanged.
  # 
  # = Fields:
  # :x_bearing ::
  #   (Float) 
  # :y_bearing ::
  #   (Float) 
  # :width ::
  #   (Float) 
  # :height ::
  #   (Float) 
  # :x_advance ::
  #   (Float) 
  # :y_advance ::
  #   (Float) 
  class TextExtentsT < FFI::Struct
    layout :x_bearing, :double,
           :y_bearing, :double,
           :width, :double,
           :height, :double,
           :x_advance, :double,
           :y_advance, :double
  end
  
  # cairo_font_extents_t:
  # @ascent: the distance that the font extends above the baseline.
  #          Note that this is not always exactly equal to the maximum
  #          of the extents of all the glyphs in the font, but rather
  #          is picked to express the font designer's intent as to
  #          how the font should align with elements above it.
  # @descent: the distance that the font extends below the baseline.
  #           This value is positive for typical fonts that include
  #           portions below the baseline. Note that this is not always
  #           exactly equal to the maximum of the extents of all the
  #           glyphs in the font, but rather is picked to express the
  #           font designer's intent as to how the the font should
  #           align with elements below it.
  # @height: the recommended vertical distance between baselines when
  #          setting consecutive lines of text with the font. This
  #          is greater than @ascent+@descent by a
  #          quantity known as the <firstterm>line spacing</firstterm>
  #          or <firstterm>external leading</firstterm>. When space
  #          is at a premium, most fonts can be set with only
  #          a distance of @ascent+@descent between lines.
  # @max_x_advance: the maximum distance in the X direction that
  #         the the origin is advanced for any glyph in the font.
  # @max_y_advance: the maximum distance in the Y direction that
  #         the the origin is advanced for any glyph in the font.
  #         this will be zero for normal fonts used for horizontal
  #         writing. (The scripts of East Asia are sometimes written
  #         vertically.)
  # 
  # The #cairo_font_extents_t structure stores metric information for
  # a font. Values are given in the current user-space coordinate
  # system.
  # 
  # Because font metrics are in user-space coordinates, they are
  # mostly, but not entirely, independent of the current transformation
  # matrix. If you call <literal>cairo_scale(cr, 2.0, 2.0)</literal>,
  # text will be drawn twice as big, but the reported text extents will
  # not be doubled. They will change slightly due to hinting (so you
  # can't assume that metrics are independent of the transformation
  # matrix), but otherwise will remain unchanged.
  # 
  # = Fields:
  # :ascent ::
  #   (Float) 
  # :descent ::
  #   (Float) 
  # :height ::
  #   (Float) 
  # :max_x_advance ::
  #   (Float) 
  # :max_y_advance ::
  #   (Float) 
  class FontExtentsT < FFI::Struct
    layout :ascent, :double,
           :descent, :double,
           :height, :double,
           :max_x_advance, :double,
           :max_y_advance, :double
  end
  
  # cairo_font_slant_t:
  # 
  # Specifies variants of a font face based on their slant.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:font_slant).</em>
  # 
  # === Options:
  # :normal ::
  #   Upright font style
  # :italic ::
  #   Italic font style
  # :oblique ::
  #   Oblique font style
  # 
  # @method _enum_font_slant_
  # @return [Symbol]
  # @scope class
  enum :font_slant, [
    :normal, 0,
    :italic, 1,
    :oblique, 2
  ]
  
  # cairo_font_weight_t:
  # 
  # Specifies variants of a font face based on their weight.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:font_weight).</em>
  # 
  # === Options:
  # :normal ::
  #   Normal font weight
  # :bold ::
  #   Bold font weight
  # 
  # @method _enum_font_weight_
  # @return [Symbol]
  # @scope class
  enum :font_weight, [
    :normal, 0,
    :bold, 1
  ]
  
  # cairo_subpixel_order_t:
  # 
  # The subpixel order specifies the order of color elements within
  # each pixel on the display device when rendering with an
  # antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:subpixel_order).</em>
  # 
  # === Options:
  # :default ::
  #   Use the default subpixel order for
  #     for the target device
  # :rgb ::
  #   Subpixel elements are arranged horizontally
  #     with red at the left
  # :bgr ::
  #   Subpixel elements are arranged horizontally
  #    with blue at the left
  # :vrgb ::
  #   Subpixel elements are arranged vertically
  #     with red at the top
  # :vbgr ::
  #   Subpixel elements are arranged vertically
  #     with blue at the top
  # 
  # @method _enum_subpixel_order_
  # @return [Symbol]
  # @scope class
  enum :subpixel_order, [
    :default, 0,
    :rgb, 1,
    :bgr, 2,
    :vrgb, 3,
    :vbgr, 4
  ]
  
  # cairo_hint_style_t:
  # 
  # Specifies the type of hinting to do on font outlines. Hinting
  # is the process of fitting outlines to the pixel grid in order
  # to improve the appearance of the result. Since hinting outlines
  # involves distorting them, it also reduces the faithfulness
  # to the original outline shapes. Not all of the outline hinting
  # styles are supported by all font backends.
  # 
  # New entries may be added in future versions.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:hint_style).</em>
  # 
  # === Options:
  # :default ::
  #   Use the default hint style for
  #     font backend and target device
  # :none ::
  #   Do not hint outlines
  # :slight ::
  #   Hint outlines slightly to improve
  #     contrast while retaining good fidelity to the original
  #     shapes.
  # :medium ::
  #   Hint outlines with medium strength
  #     giving a compromise between fidelity to the original shapes
  #     and contrast
  # :full ::
  #   Hint outlines to maximize contrast
  # 
  # @method _enum_hint_style_
  # @return [Symbol]
  # @scope class
  enum :hint_style, [
    :default, 0,
    :none, 1,
    :slight, 2,
    :medium, 3,
    :full, 4
  ]
  
  # cairo_hint_metrics_t:
  # 
  # Specifies whether to hint font metrics; hinting font metrics
  # means quantizing them so that they are integer values in
  # device space. Doing this improves the consistency of
  # letter and line spacing, however it also means that text
  # will be laid out differently at different zoom factors.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:hint_metrics).</em>
  # 
  # === Options:
  # :default ::
  #   Hint metrics in the default
  #    manner for the font backend and target device
  # :off ::
  #   Do not hint font metrics
  # :on ::
  #   Hint font metrics
  # 
  # @method _enum_hint_metrics_
  # @return [Symbol]
  # @scope class
  enum :hint_metrics, [
    :default, 0,
    :off, 1,
    :on, 2
  ]
  
  # cairo_font_options_t:
  # 
  # An opaque structure holding all options that are used when
  # rendering fonts.
  # 
  # Individual features of a #cairo_font_options_t can be set or
  # accessed using functions named
  # cairo_font_options_set_<emphasis>feature_name</emphasis> and
  # cairo_font_options_get_<emphasis>feature_name</emphasis>, like
  # cairo_font_options_set_antialias() and
  # cairo_font_options_get_antialias().
  # 
  # New features may be added to a #cairo_font_options_t in the
  # future.  For this reason, cairo_font_options_copy(),
  # cairo_font_options_equal(), cairo_font_options_merge(), and
  # cairo_font_options_hash() should be used to copy, check
  # for equality, merge, or compute a hash value of
  # #cairo_font_options_t objects.
  module FontOptionsWrappers
    def copy()
      FontOptions.new Cairo.font_options_copy(self)
    end
    
    def destroy()
      Cairo.font_options_destroy(self)
    end
    
    def status()
      Cairo.font_options_status(self)
    end
    
    def merge(other)
      Cairo.font_options_merge(self, other)
    end
    
    def equal(other)
      Cairo.font_options_equal(self, other)
    end
    
    def hash()
      Cairo.font_options_hash(self)
    end
    
    def set_antialias(antialias)
      Cairo.font_options_set_antialias(self, antialias)
    end
    
    def get_antialias()
      Cairo.font_options_get_antialias(self)
    end
    
    def set_subpixel_order(subpixel_order)
      Cairo.font_options_set_subpixel_order(self, subpixel_order)
    end
    
    def get_subpixel_order()
      Cairo.font_options_get_subpixel_order(self)
    end
    
    def set_hint_style(hint_style)
      Cairo.font_options_set_hint_style(self, hint_style)
    end
    
    def get_hint_style()
      Cairo.font_options_get_hint_style(self)
    end
    
    def set_hint_metrics(hint_metrics)
      Cairo.font_options_set_hint_metrics(self, hint_metrics)
    end
    
    def get_hint_metrics()
      Cairo.font_options_get_hint_metrics(self)
    end
  end
  
  class FontOptions < FFI::Struct
    include FontOptionsWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method font_options_create()
  # @return [FontOptions] 
  # @scope class
  attach_function :font_options_create, :cairo_font_options_create, [], FontOptions
  
  # (Not documented)
  # 
  # @method font_options_copy(original)
  # @param [FontOptions] original 
  # @return [FontOptions] 
  # @scope class
  attach_function :font_options_copy, :cairo_font_options_copy, [FontOptions], FontOptions
  
  # (Not documented)
  # 
  # @method font_options_destroy(options)
  # @param [FontOptions] options 
  # @return [nil] 
  # @scope class
  attach_function :font_options_destroy, :cairo_font_options_destroy, [FontOptions], :void
  
  # (Not documented)
  # 
  # @method font_options_status(options)
  # @param [FontOptions] options 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :font_options_status, :cairo_font_options_status, [FontOptions], :status
  
  # (Not documented)
  # 
  # @method font_options_merge(options, other)
  # @param [FontOptions] options 
  # @param [FontOptions] other 
  # @return [nil] 
  # @scope class
  attach_function :font_options_merge, :cairo_font_options_merge, [FontOptions, FontOptions], :void
  
  # (Not documented)
  # 
  # @method font_options_equal(options, other)
  # @param [FontOptions] options 
  # @param [FontOptions] other 
  # @return [Integer] 
  # @scope class
  attach_function :font_options_equal, :cairo_font_options_equal, [FontOptions, FontOptions], :int
  
  # (Not documented)
  # 
  # @method font_options_hash(options)
  # @param [FontOptions] options 
  # @return [Integer] 
  # @scope class
  attach_function :font_options_hash, :cairo_font_options_hash, [FontOptions], :ulong
  
  # (Not documented)
  # 
  # @method font_options_set_antialias(options, antialias)
  # @param [FontOptions] options 
  # @param [Symbol from _enum_antialias_] antialias 
  # @return [nil] 
  # @scope class
  attach_function :font_options_set_antialias, :cairo_font_options_set_antialias, [FontOptions, :antialias], :void
  
  # (Not documented)
  # 
  # @method font_options_get_antialias(options)
  # @param [FontOptions] options 
  # @return [Symbol from _enum_antialias_] 
  # @scope class
  attach_function :font_options_get_antialias, :cairo_font_options_get_antialias, [FontOptions], :antialias
  
  # (Not documented)
  # 
  # @method font_options_set_subpixel_order(options, subpixel_order)
  # @param [FontOptions] options 
  # @param [Symbol from _enum_subpixel_order_] subpixel_order 
  # @return [nil] 
  # @scope class
  attach_function :font_options_set_subpixel_order, :cairo_font_options_set_subpixel_order, [FontOptions, :subpixel_order], :void
  
  # (Not documented)
  # 
  # @method font_options_get_subpixel_order(options)
  # @param [FontOptions] options 
  # @return [Symbol from _enum_subpixel_order_] 
  # @scope class
  attach_function :font_options_get_subpixel_order, :cairo_font_options_get_subpixel_order, [FontOptions], :subpixel_order
  
  # (Not documented)
  # 
  # @method font_options_set_hint_style(options, hint_style)
  # @param [FontOptions] options 
  # @param [Symbol from _enum_hint_style_] hint_style 
  # @return [nil] 
  # @scope class
  attach_function :font_options_set_hint_style, :cairo_font_options_set_hint_style, [FontOptions, :hint_style], :void
  
  # (Not documented)
  # 
  # @method font_options_get_hint_style(options)
  # @param [FontOptions] options 
  # @return [Symbol from _enum_hint_style_] 
  # @scope class
  attach_function :font_options_get_hint_style, :cairo_font_options_get_hint_style, [FontOptions], :hint_style
  
  # (Not documented)
  # 
  # @method font_options_set_hint_metrics(options, hint_metrics)
  # @param [FontOptions] options 
  # @param [Symbol from _enum_hint_metrics_] hint_metrics 
  # @return [nil] 
  # @scope class
  attach_function :font_options_set_hint_metrics, :cairo_font_options_set_hint_metrics, [FontOptions, :hint_metrics], :void
  
  # (Not documented)
  # 
  # @method font_options_get_hint_metrics(options)
  # @param [FontOptions] options 
  # @return [Symbol from _enum_hint_metrics_] 
  # @scope class
  attach_function :font_options_get_hint_metrics, :cairo_font_options_get_hint_metrics, [FontOptions], :hint_metrics
  
  # This interface is for dealing with text as text, not caring about the
  #    font object inside the the cairo_t.
  # 
  # @method select_font_face(cr, family, slant, weight)
  # @param [Cairo] cr 
  # @param [String] family 
  # @param [Symbol from _enum_font_slant_] slant 
  # @param [Symbol from _enum_font_weight_] weight 
  # @return [nil] 
  # @scope class
  attach_function :select_font_face, :cairo_select_font_face, [Cairo, :string, :font_slant, :font_weight], :void
  
  # (Not documented)
  # 
  # @method set_font_size(cr, size)
  # @param [Cairo] cr 
  # @param [Float] size 
  # @return [nil] 
  # @scope class
  attach_function :set_font_size, :cairo_set_font_size, [Cairo, :double], :void
  
  # (Not documented)
  # 
  # @method set_font_matrix(cr, matrix)
  # @param [Cairo] cr 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :set_font_matrix, :cairo_set_font_matrix, [Cairo, Matrix], :void
  
  # (Not documented)
  # 
  # @method get_font_matrix(cr, matrix)
  # @param [Cairo] cr 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :get_font_matrix, :cairo_get_font_matrix, [Cairo, Matrix], :void
  
  # (Not documented)
  # 
  # @method set_font_options(cr, options)
  # @param [Cairo] cr 
  # @param [FontOptions] options 
  # @return [nil] 
  # @scope class
  attach_function :set_font_options, :cairo_set_font_options, [Cairo, FontOptions], :void
  
  # (Not documented)
  # 
  # @method get_font_options(cr, options)
  # @param [Cairo] cr 
  # @param [FontOptions] options 
  # @return [nil] 
  # @scope class
  attach_function :get_font_options, :cairo_get_font_options, [Cairo, FontOptions], :void
  
  # (Not documented)
  # 
  # @method set_font_face(cr, font_face)
  # @param [Cairo] cr 
  # @param [FontFace] font_face 
  # @return [nil] 
  # @scope class
  attach_function :set_font_face, :cairo_set_font_face, [Cairo, FontFace], :void
  
  # (Not documented)
  # 
  # @method get_font_face(cr)
  # @param [Cairo] cr 
  # @return [FontFace] 
  # @scope class
  attach_function :get_font_face, :cairo_get_font_face, [Cairo], FontFace
  
  # (Not documented)
  # 
  # @method set_scaled_font(cr, scaled_font)
  # @param [Cairo] cr 
  # @param [ScaledFont] scaled_font 
  # @return [nil] 
  # @scope class
  attach_function :set_scaled_font, :cairo_set_scaled_font, [Cairo, ScaledFont], :void
  
  # (Not documented)
  # 
  # @method get_scaled_font(cr)
  # @param [Cairo] cr 
  # @return [ScaledFont] 
  # @scope class
  attach_function :get_scaled_font, :cairo_get_scaled_font, [Cairo], ScaledFont
  
  # (Not documented)
  # 
  # @method show_text(cr, utf8)
  # @param [Cairo] cr 
  # @param [String] utf8 
  # @return [nil] 
  # @scope class
  attach_function :show_text, :cairo_show_text, [Cairo, :string], :void
  
  # (Not documented)
  # 
  # @method show_glyphs(cr, glyphs, num_glyphs)
  # @param [Cairo] cr 
  # @param [GlyphT] glyphs 
  # @param [Integer] num_glyphs 
  # @return [nil] 
  # @scope class
  attach_function :show_glyphs, :cairo_show_glyphs, [Cairo, GlyphT, :int], :void
  
  # (Not documented)
  # 
  # @method show_text_glyphs(cr, utf8, utf8_len, glyphs, num_glyphs, clusters, num_clusters, cluster_flags)
  # @param [Cairo] cr 
  # @param [String] utf8 
  # @param [Integer] utf8_len 
  # @param [GlyphT] glyphs 
  # @param [Integer] num_glyphs 
  # @param [TextClusterT] clusters 
  # @param [Integer] num_clusters 
  # @param [Symbol from _enum_text_cluster_flags_] cluster_flags 
  # @return [nil] 
  # @scope class
  attach_function :show_text_glyphs, :cairo_show_text_glyphs, [Cairo, :string, :int, GlyphT, :int, TextClusterT, :int, :text_cluster_flags], :void
  
  # (Not documented)
  # 
  # @method text_path(cr, utf8)
  # @param [Cairo] cr 
  # @param [String] utf8 
  # @return [nil] 
  # @scope class
  attach_function :text_path, :cairo_text_path, [Cairo, :string], :void
  
  # (Not documented)
  # 
  # @method glyph_path(cr, glyphs, num_glyphs)
  # @param [Cairo] cr 
  # @param [GlyphT] glyphs 
  # @param [Integer] num_glyphs 
  # @return [nil] 
  # @scope class
  attach_function :glyph_path, :cairo_glyph_path, [Cairo, GlyphT, :int], :void
  
  # (Not documented)
  # 
  # @method text_extents(cr, utf8, extents)
  # @param [Cairo] cr 
  # @param [String] utf8 
  # @param [TextExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :text_extents, :cairo_text_extents, [Cairo, :string, TextExtentsT], :void
  
  # (Not documented)
  # 
  # @method glyph_extents(cr, glyphs, num_glyphs, extents)
  # @param [Cairo] cr 
  # @param [GlyphT] glyphs 
  # @param [Integer] num_glyphs 
  # @param [TextExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :glyph_extents, :cairo_glyph_extents, [Cairo, GlyphT, :int, TextExtentsT], :void
  
  # (Not documented)
  # 
  # @method font_extents(cr, extents)
  # @param [Cairo] cr 
  # @param [FontExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :font_extents, :cairo_font_extents, [Cairo, FontExtentsT], :void
  
  # Generic identifier for a font style
  # 
  # @method font_face_reference(font_face)
  # @param [FontFace] font_face 
  # @return [FontFace] 
  # @scope class
  attach_function :font_face_reference, :cairo_font_face_reference, [FontFace], FontFace
  
  # (Not documented)
  # 
  # @method font_face_destroy(font_face)
  # @param [FontFace] font_face 
  # @return [nil] 
  # @scope class
  attach_function :font_face_destroy, :cairo_font_face_destroy, [FontFace], :void
  
  # (Not documented)
  # 
  # @method font_face_get_reference_count(font_face)
  # @param [FontFace] font_face 
  # @return [Integer] 
  # @scope class
  attach_function :font_face_get_reference_count, :cairo_font_face_get_reference_count, [FontFace], :uint
  
  # (Not documented)
  # 
  # @method font_face_status(font_face)
  # @param [FontFace] font_face 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :font_face_status, :cairo_font_face_status, [FontFace], :status
  
  # cairo_font_type_t:
  # 
  # #cairo_font_type_t is used to describe the type of a given font
  # face or scaled font. The font types are also known as "font
  # backends" within cairo.
  # 
  # The type of a font face is determined by the function used to
  # create it, which will generally be of the form
  # cairo_<emphasis>type</emphasis>_font_face_create(). The font face type can be queried
  # with cairo_font_face_get_type()
  # 
  # The various #cairo_font_face_t functions can be used with a font face
  # of any type.
  # 
  # The type of a scaled font is determined by the type of the font
  # face passed to cairo_scaled_font_create(). The scaled font type can
  # be queried with cairo_scaled_font_get_type()
  # 
  # The various #cairo_scaled_font_t functions can be used with scaled
  # fonts of any type, but some font backends also provide
  # type-specific functions that must only be called with a scaled font
  # of the appropriate type. These functions have names that begin with
  # cairo_<emphasis>type</emphasis>_scaled_font() such as cairo_ft_scaled_font_lock_face().
  # 
  # The behavior of calling a type-specific function with a scaled font
  # of the wrong type is undefined.
  # 
  # New entries may be added in future versions.
  # 
  # Since: 1.2
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:font_type).</em>
  # 
  # === Options:
  # :toy ::
  #   The font was created using cairo's toy font api
  # :ft ::
  #   The font is of type FreeType
  # :win32 ::
  #   The font is of type Win32
  # :quartz ::
  #   The font is of type Quartz (Since: 1.6)
  # :user ::
  #   The font was create using cairo's user font api (Since: 1.8)
  # 
  # @method _enum_font_type_
  # @return [Symbol]
  # @scope class
  enum :font_type, [
    :toy, 0,
    :ft, 1,
    :win32, 2,
    :quartz, 3,
    :user, 4
  ]
  
  # (Not documented)
  # 
  # @method font_face_get_type(font_face)
  # @param [FontFace] font_face 
  # @return [Symbol from _enum_font_type_] 
  # @scope class
  attach_function :font_face_get_type, :cairo_font_face_get_type, [FontFace], :font_type
  
  # (Not documented)
  # 
  # @method font_face_get_user_data(font_face, key)
  # @param [FontFace] font_face 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :font_face_get_user_data, :cairo_font_face_get_user_data, [FontFace, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method font_face_set_user_data(font_face, key, user_data, destroy)
  # @param [FontFace] font_face 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :font_face_set_user_data, :cairo_font_face_set_user_data, [FontFace, UserDataKey, :pointer, :pointer], :status
  
  # Portable interface to general font features.
  # 
  # @method scaled_font_create(font_face, font_matrix, ctm, options)
  # @param [FontFace] font_face 
  # @param [Matrix] font_matrix 
  # @param [Matrix] ctm 
  # @param [FontOptions] options 
  # @return [ScaledFont] 
  # @scope class
  attach_function :scaled_font_create, :cairo_scaled_font_create, [FontFace, Matrix, Matrix, FontOptions], ScaledFont
  
  # (Not documented)
  # 
  # @method scaled_font_reference(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [ScaledFont] 
  # @scope class
  attach_function :scaled_font_reference, :cairo_scaled_font_reference, [ScaledFont], ScaledFont
  
  # (Not documented)
  # 
  # @method scaled_font_destroy(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_destroy, :cairo_scaled_font_destroy, [ScaledFont], :void
  
  # (Not documented)
  # 
  # @method scaled_font_get_reference_count(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [Integer] 
  # @scope class
  attach_function :scaled_font_get_reference_count, :cairo_scaled_font_get_reference_count, [ScaledFont], :uint
  
  # (Not documented)
  # 
  # @method scaled_font_status(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :scaled_font_status, :cairo_scaled_font_status, [ScaledFont], :status
  
  # (Not documented)
  # 
  # @method scaled_font_get_type(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [Symbol from _enum_font_type_] 
  # @scope class
  attach_function :scaled_font_get_type, :cairo_scaled_font_get_type, [ScaledFont], :font_type
  
  # (Not documented)
  # 
  # @method scaled_font_get_user_data(scaled_font, key)
  # @param [ScaledFont] scaled_font 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :scaled_font_get_user_data, :cairo_scaled_font_get_user_data, [ScaledFont, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method scaled_font_set_user_data(scaled_font, key, user_data, destroy)
  # @param [ScaledFont] scaled_font 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :scaled_font_set_user_data, :cairo_scaled_font_set_user_data, [ScaledFont, UserDataKey, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method scaled_font_extents(scaled_font, extents)
  # @param [ScaledFont] scaled_font 
  # @param [FontExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_extents, :cairo_scaled_font_extents, [ScaledFont, FontExtentsT], :void
  
  # (Not documented)
  # 
  # @method scaled_font_text_extents(scaled_font, utf8, extents)
  # @param [ScaledFont] scaled_font 
  # @param [String] utf8 
  # @param [TextExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_text_extents, :cairo_scaled_font_text_extents, [ScaledFont, :string, TextExtentsT], :void
  
  # (Not documented)
  # 
  # @method scaled_font_glyph_extents(scaled_font, glyphs, num_glyphs, extents)
  # @param [ScaledFont] scaled_font 
  # @param [GlyphT] glyphs 
  # @param [Integer] num_glyphs 
  # @param [TextExtentsT] extents 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_glyph_extents, :cairo_scaled_font_glyph_extents, [ScaledFont, GlyphT, :int, TextExtentsT], :void
  
  # (Not documented)
  # 
  # @method scaled_font_text_to_glyphs(scaled_font, x, y, utf8, utf8_len, glyphs, num_glyphs, clusters, num_clusters, cluster_flags)
  # @param [ScaledFont] scaled_font 
  # @param [Float] x 
  # @param [Float] y 
  # @param [String] utf8 
  # @param [Integer] utf8_len 
  # @param [FFI::Pointer(**GlyphT)] glyphs 
  # @param [FFI::Pointer(*Int)] num_glyphs 
  # @param [FFI::Pointer(**TextClusterT)] clusters 
  # @param [FFI::Pointer(*Int)] num_clusters 
  # @param [FFI::Pointer(*TextClusterFlagsT)] cluster_flags 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :scaled_font_text_to_glyphs, :cairo_scaled_font_text_to_glyphs, [ScaledFont, :double, :double, :string, :int, :pointer, :pointer, :pointer, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method scaled_font_get_font_face(scaled_font)
  # @param [ScaledFont] scaled_font 
  # @return [FontFace] 
  # @scope class
  attach_function :scaled_font_get_font_face, :cairo_scaled_font_get_font_face, [ScaledFont], FontFace
  
  # (Not documented)
  # 
  # @method scaled_font_get_font_matrix(scaled_font, font_matrix)
  # @param [ScaledFont] scaled_font 
  # @param [Matrix] font_matrix 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_get_font_matrix, :cairo_scaled_font_get_font_matrix, [ScaledFont, Matrix], :void
  
  # (Not documented)
  # 
  # @method scaled_font_get_ctm(scaled_font, ctm)
  # @param [ScaledFont] scaled_font 
  # @param [Matrix] ctm 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_get_ctm, :cairo_scaled_font_get_ctm, [ScaledFont, Matrix], :void
  
  # (Not documented)
  # 
  # @method scaled_font_get_scale_matrix(scaled_font, scale_matrix)
  # @param [ScaledFont] scaled_font 
  # @param [Matrix] scale_matrix 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_get_scale_matrix, :cairo_scaled_font_get_scale_matrix, [ScaledFont, Matrix], :void
  
  # (Not documented)
  # 
  # @method scaled_font_get_font_options(scaled_font, options)
  # @param [ScaledFont] scaled_font 
  # @param [FontOptions] options 
  # @return [nil] 
  # @scope class
  attach_function :scaled_font_get_font_options, :cairo_scaled_font_get_font_options, [ScaledFont, FontOptions], :void
  
  # Toy fonts
  # 
  # @method toy_font_face_create(family, slant, weight)
  # @param [String] family 
  # @param [Symbol from _enum_font_slant_] slant 
  # @param [Symbol from _enum_font_weight_] weight 
  # @return [FontFace] 
  # @scope class
  attach_function :toy_font_face_create, :cairo_toy_font_face_create, [:string, :font_slant, :font_weight], FontFace
  
  # (Not documented)
  # 
  # @method toy_font_face_get_family(font_face)
  # @param [FontFace] font_face 
  # @return [String] 
  # @scope class
  attach_function :toy_font_face_get_family, :cairo_toy_font_face_get_family, [FontFace], :string
  
  # (Not documented)
  # 
  # @method toy_font_face_get_slant(font_face)
  # @param [FontFace] font_face 
  # @return [Symbol from _enum_font_slant_] 
  # @scope class
  attach_function :toy_font_face_get_slant, :cairo_toy_font_face_get_slant, [FontFace], :font_slant
  
  # (Not documented)
  # 
  # @method toy_font_face_get_weight(font_face)
  # @param [FontFace] font_face 
  # @return [Symbol from _enum_font_weight_] 
  # @scope class
  attach_function :toy_font_face_get_weight, :cairo_toy_font_face_get_weight, [FontFace], :font_weight
  
  # User fonts
  # 
  # @method user_font_face_create()
  # @return [FontFace] 
  # @scope class
  attach_function :user_font_face_create, :cairo_user_font_face_create, [], FontFace
  
  # cairo_user_scaled_font_init_func_t:
  # @scaled_font: the scaled-font being created
  # @cr: a cairo context, in font space
  # @extents: font extents to fill in, in font space
  # 
  # #cairo_user_scaled_font_init_func_t is the type of function which is
  # called when a scaled-font needs to be created for a user font-face.
  # 
  # The cairo context @cr is not used by the caller, but is prepared in font
  # space, similar to what the cairo contexts passed to the render_glyph
  # method will look like.  The callback can use this context for extents
  # computation for example.  After the callback is called, @cr is checked
  # for any error status.
  # 
  # The @extents argument is where the user font sets the font extents for
  # @scaled_font.  It is in font space, which means that for most cases its
  # ascent and descent members should add to 1.0.  @extents is preset to
  # hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
  # descent and max_y_advance members.
  # 
  # The callback is optional.  If not set, default font extents as described
  # in the previous paragraph will be used.
  # 
  # Note that @scaled_font is not fully initialized at this
  # point and trying to use it for text operations in the callback will result
  # in deadlock.
  # 
  # Returns: %CAIRO_STATUS_SUCCESS upon success, or an error status on error.
  # 
  # Since: 1.8
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_user_scaled_font_init_func_t_(scaled_font, cr, extents)
  # @param [ScaledFont] scaled_font 
  # @param [Cairo] cr 
  # @param [FontExtentsT] extents 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :user_scaled_font_init_func_t, [ScaledFont, Cairo, FontExtentsT], :status
  
  # cairo_user_scaled_font_render_glyph_func_t:
  # @scaled_font: user scaled-font
  # @glyph: glyph code to render
  # @cr: cairo context to draw to, in font space
  # @extents: glyph extents to fill in, in font space
  # 
  # #cairo_user_scaled_font_render_glyph_func_t is the type of function which
  # is called when a user scaled-font needs to render a glyph.
  # 
  # The callback is mandatory, and expected to draw the glyph with code @glyph to
  # the cairo context @cr.  @cr is prepared such that the glyph drawing is done in
  # font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font,
  # The @extents argument is where the user font sets the font extents for
  # @scaled_font.  However, if user prefers to draw in user space, they can
  # achieve that by changing the matrix on @cr.  All cairo rendering operations
  # to @cr are permitted, however, the result is undefined if any source other
  # than the default source on @cr is used.  That means, glyph bitmaps should
  # be rendered using cairo_mask() instead of cairo_paint().
  # 
  # Other non-default settings on @cr include a font size of 1.0 (given that
  # it is set up to be in font space), and font options corresponding to
  # @scaled_font.
  # 
  # The @extents argument is preset to have <literal>x_bearing</literal>,
  # <literal>width</literal>, and <literal>y_advance</literal> of zero,
  # <literal>y_bearing</literal> set to <literal>-font_extents.ascent</literal>,
  # <literal>height</literal> to <literal>font_extents.ascent+font_extents.descent</literal>,
  # and <literal>x_advance</literal> to <literal>font_extents.max_x_advance</literal>.
  # The only field user needs to set in majority of cases is
  # <literal>x_advance</literal>.
  # If the <literal>width</literal> field is zero upon the callback returning
  # (which is its preset value), the glyph extents are automatically computed
  # based on the drawings done to @cr.  This is in most cases exactly what the
  # desired behavior is.  However, if for any reason the callback sets the
  # extents, it must be ink extents, and include the extents of all drawing
  # done to @cr in the callback.
  # 
  # Returns: %CAIRO_STATUS_SUCCESS upon success, or
  # %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  # 
  # Since: 1.8
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_user_scaled_font_render_glyph_func_t_(scaled_font, glyph, cr, extents)
  # @param [ScaledFont] scaled_font 
  # @param [Integer] glyph 
  # @param [Cairo] cr 
  # @param [TextExtentsT] extents 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :user_scaled_font_render_glyph_func_t, [ScaledFont, :ulong, Cairo, TextExtentsT], :status
  
  # cairo_user_scaled_font_text_to_glyphs_func_t:
  # @scaled_font: the scaled-font being created
  # @utf8: a string of text encoded in UTF-8
  # @utf8_len: length of @utf8 in bytes
  # @glyphs: pointer to array of glyphs to fill, in font space
  # @num_glyphs: pointer to number of glyphs
  # @clusters: pointer to array of cluster mapping information to fill, or %NULL
  # @num_clusters: pointer to number of clusters
  # @cluster_flags: pointer to location to store cluster flags corresponding to the
  #                 output @clusters
  # 
  # #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
  # is called to convert input text to an array of glyphs.  This is used by the
  # cairo_show_text() operation.
  # 
  # Using this callback the user-font has full control on glyphs and their
  # positions.  That means, it allows for features like ligatures and kerning,
  # as well as complex <firstterm>shaping</firstterm> required for scripts like
  # Arabic and Indic.
  # 
  # The @num_glyphs argument is preset to the number of glyph entries available
  # in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of
  # @num_glyphs will be zero.  If the provided glyph array is too short for
  # the conversion (or for convenience), a new glyph array may be allocated
  # using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
  # @num_glyphs should contain the number of generated glyphs.  If the value
  # @glyphs points at has changed after the call, the caller will free the
  # allocated glyph array using cairo_glyph_free().
  # The callback should populate the glyph indices and positions (in font space)
  # assuming that the text is to be shown at the origin.
  # 
  # If @clusters is not %NULL, @num_clusters and @cluster_flags are also
  # non-%NULL, and cluster mapping should be computed. The semantics of how
  # cluster array allocation works is similar to the glyph array.  That is,
  # if @clusters initially points to a non-%NULL value, that array may be used
  # as a cluster buffer, and @num_clusters points to the number of cluster
  # entries available there.  If the provided cluster array is too short for
  # the conversion (or for convenience), a new cluster array may be allocated
  # using cairo_text_cluster_allocate() and placed in @clusters.  Upon return,
  # @num_clusters should contain the number of generated clusters.
  # If the value @clusters points at has changed after the call, the caller
  # will free the allocated cluster array using cairo_text_cluster_free().
  # 
  # The callback is optional.  If @num_glyphs is negative upon
  # the callback returning or if the return value
  # is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback
  # is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.
  # 
  # Note: While cairo does not impose any limitation on glyph indices,
  # some applications may assume that a glyph index fits in a 16-bit
  # unsigned integer.  As such, it is advised that user-fonts keep their
  # glyphs in the 0 to 65535 range.  Furthermore, some applications may
  # assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
  # are advised to use glyph 0 for such purposes and do not use that
  # glyph value for other purposes.
  # 
  # Returns: %CAIRO_STATUS_SUCCESS upon success,
  # %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
  # or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  # 
  # Since: 1.8
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_user_scaled_font_text_to_glyphs_func_t_(scaled_font, utf8, utf8_len, glyphs, num_glyphs, clusters, num_clusters, cluster_flags)
  # @param [ScaledFont] scaled_font 
  # @param [String] utf8 
  # @param [Integer] utf8_len 
  # @param [FFI::Pointer(**GlyphT)] glyphs 
  # @param [FFI::Pointer(*Int)] num_glyphs 
  # @param [FFI::Pointer(**TextClusterT)] clusters 
  # @param [FFI::Pointer(*Int)] num_clusters 
  # @param [FFI::Pointer(*TextClusterFlagsT)] cluster_flags 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :user_scaled_font_text_to_glyphs_func_t, [ScaledFont, :string, :int, :pointer, :pointer, :pointer, :pointer, :pointer], :status
  
  # cairo_user_scaled_font_unicode_to_glyph_func_t:
  # @scaled_font: the scaled-font being created
  # @unicode: input unicode character code-point
  # @glyph_index: output glyph index
  # 
  # #cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which
  # is called to convert an input Unicode character to a single glyph.
  # This is used by the cairo_show_text() operation.
  # 
  # This callback is used to provide the same functionality as the
  # text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)
  # but has much less control on the output,
  # in exchange for increased ease of use.  The inherent assumption to using
  # this callback is that each character maps to one glyph, and that the
  # mapping is context independent.  It also assumes that glyphs are positioned
  # according to their advance width.  These mean no ligatures, kerning, or
  # complex scripts can be implemented using this callback.
  # 
  # The callback is optional, and only used if text_to_glyphs callback is not
  # set or fails to return glyphs.  If this callback is not set or if it returns
  # %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode
  # code-points to glyph indices is assumed.
  # 
  # Note: While cairo does not impose any limitation on glyph indices,
  # some applications may assume that a glyph index fits in a 16-bit
  # unsigned integer.  As such, it is advised that user-fonts keep their
  # glyphs in the 0 to 65535 range.  Furthermore, some applications may
  # assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
  # are advised to use glyph 0 for such purposes and do not use that
  # glyph value for other purposes.
  # 
  # Returns: %CAIRO_STATUS_SUCCESS upon success,
  # %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
  # or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
  # 
  # Since: 1.8
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_user_scaled_font_unicode_to_glyph_func_t_(scaled_font, unicode, glyph_index)
  # @param [ScaledFont] scaled_font 
  # @param [Integer] unicode 
  # @param [FFI::Pointer(*ULong)] glyph_index 
  # @return [Symbol from _enum_status_] 
  # @scope class
  callback :user_scaled_font_unicode_to_glyph_func_t, [ScaledFont, :ulong, :pointer], :status
  
  # User-font method setters
  # 
  # @method user_font_face_set_init_func(font_face, init_func)
  # @param [FontFace] font_face 
  # @param [Proc(_callback_user_scaled_font_init_func_t_)] init_func 
  # @return [nil] 
  # @scope class
  attach_function :user_font_face_set_init_func, :cairo_user_font_face_set_init_func, [FontFace, :user_scaled_font_init_func_t], :void
  
  # (Not documented)
  # 
  # @method user_font_face_set_render_glyph_func(font_face, render_glyph_func)
  # @param [FontFace] font_face 
  # @param [Proc(_callback_user_scaled_font_render_glyph_func_t_)] render_glyph_func 
  # @return [nil] 
  # @scope class
  attach_function :user_font_face_set_render_glyph_func, :cairo_user_font_face_set_render_glyph_func, [FontFace, :user_scaled_font_render_glyph_func_t], :void
  
  # (Not documented)
  # 
  # @method user_font_face_set_text_to_glyphs_func(font_face, text_to_glyphs_func)
  # @param [FontFace] font_face 
  # @param [Proc(_callback_user_scaled_font_text_to_glyphs_func_t_)] text_to_glyphs_func 
  # @return [nil] 
  # @scope class
  attach_function :user_font_face_set_text_to_glyphs_func, :cairo_user_font_face_set_text_to_glyphs_func, [FontFace, :user_scaled_font_text_to_glyphs_func_t], :void
  
  # (Not documented)
  # 
  # @method user_font_face_set_unicode_to_glyph_func(font_face, unicode_to_glyph_func)
  # @param [FontFace] font_face 
  # @param [Proc(_callback_user_scaled_font_unicode_to_glyph_func_t_)] unicode_to_glyph_func 
  # @return [nil] 
  # @scope class
  attach_function :user_font_face_set_unicode_to_glyph_func, :cairo_user_font_face_set_unicode_to_glyph_func, [FontFace, :user_scaled_font_unicode_to_glyph_func_t], :void
  
  # User-font method getters
  # 
  # @method user_font_face_get_init_func(font_face)
  # @param [FontFace] font_face 
  # @return [Proc(_callback_user_scaled_font_init_func_t_)] 
  # @scope class
  attach_function :user_font_face_get_init_func, :cairo_user_font_face_get_init_func, [FontFace], :user_scaled_font_init_func_t
  
  # (Not documented)
  # 
  # @method user_font_face_get_render_glyph_func(font_face)
  # @param [FontFace] font_face 
  # @return [Proc(_callback_user_scaled_font_render_glyph_func_t_)] 
  # @scope class
  attach_function :user_font_face_get_render_glyph_func, :cairo_user_font_face_get_render_glyph_func, [FontFace], :user_scaled_font_render_glyph_func_t
  
  # (Not documented)
  # 
  # @method user_font_face_get_text_to_glyphs_func(font_face)
  # @param [FontFace] font_face 
  # @return [Proc(_callback_user_scaled_font_text_to_glyphs_func_t_)] 
  # @scope class
  attach_function :user_font_face_get_text_to_glyphs_func, :cairo_user_font_face_get_text_to_glyphs_func, [FontFace], :user_scaled_font_text_to_glyphs_func_t
  
  # (Not documented)
  # 
  # @method user_font_face_get_unicode_to_glyph_func(font_face)
  # @param [FontFace] font_face 
  # @return [Proc(_callback_user_scaled_font_unicode_to_glyph_func_t_)] 
  # @scope class
  attach_function :user_font_face_get_unicode_to_glyph_func, :cairo_user_font_face_get_unicode_to_glyph_func, [FontFace], :user_scaled_font_unicode_to_glyph_func_t
  
  # Query functions
  # 
  # @method get_operator(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_operator_] 
  # @scope class
  attach_function :get_operator, :cairo_get_operator, [Cairo], :operator
  
  # (Not documented)
  # 
  # @method get_source(cr)
  # @param [Cairo] cr 
  # @return [Pattern] 
  # @scope class
  attach_function :get_source, :cairo_get_source, [Cairo], Pattern
  
  # (Not documented)
  # 
  # @method get_tolerance(cr)
  # @param [Cairo] cr 
  # @return [Float] 
  # @scope class
  attach_function :get_tolerance, :cairo_get_tolerance, [Cairo], :double
  
  # (Not documented)
  # 
  # @method get_antialias(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_antialias_] 
  # @scope class
  attach_function :get_antialias, :cairo_get_antialias, [Cairo], :antialias
  
  # (Not documented)
  # 
  # @method has_current_point(cr)
  # @param [Cairo] cr 
  # @return [Integer] 
  # @scope class
  attach_function :has_current_point, :cairo_has_current_point, [Cairo], :int
  
  # (Not documented)
  # 
  # @method get_current_point(cr, x, y)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] x 
  # @param [FFI::Pointer(*Double)] y 
  # @return [nil] 
  # @scope class
  attach_function :get_current_point, :cairo_get_current_point, [Cairo, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method get_fill_rule(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_fill_rule_] 
  # @scope class
  attach_function :get_fill_rule, :cairo_get_fill_rule, [Cairo], :fill_rule
  
  # (Not documented)
  # 
  # @method get_line_width(cr)
  # @param [Cairo] cr 
  # @return [Float] 
  # @scope class
  attach_function :get_line_width, :cairo_get_line_width, [Cairo], :double
  
  # (Not documented)
  # 
  # @method get_line_cap(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_line_cap_] 
  # @scope class
  attach_function :get_line_cap, :cairo_get_line_cap, [Cairo], :line_cap
  
  # (Not documented)
  # 
  # @method get_line_join(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_line_join_] 
  # @scope class
  attach_function :get_line_join, :cairo_get_line_join, [Cairo], :line_join
  
  # (Not documented)
  # 
  # @method get_miter_limit(cr)
  # @param [Cairo] cr 
  # @return [Float] 
  # @scope class
  attach_function :get_miter_limit, :cairo_get_miter_limit, [Cairo], :double
  
  # (Not documented)
  # 
  # @method get_dash_count(cr)
  # @param [Cairo] cr 
  # @return [Integer] 
  # @scope class
  attach_function :get_dash_count, :cairo_get_dash_count, [Cairo], :int
  
  # (Not documented)
  # 
  # @method get_dash(cr, dashes, offset)
  # @param [Cairo] cr 
  # @param [FFI::Pointer(*Double)] dashes 
  # @param [FFI::Pointer(*Double)] offset 
  # @return [nil] 
  # @scope class
  attach_function :get_dash, :cairo_get_dash, [Cairo, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method get_matrix(cr, matrix)
  # @param [Cairo] cr 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :get_matrix, :cairo_get_matrix, [Cairo, Matrix], :void
  
  # (Not documented)
  # 
  # @method get_target(cr)
  # @param [Cairo] cr 
  # @return [Surface] 
  # @scope class
  attach_function :get_target, :cairo_get_target, [Cairo], Surface
  
  # (Not documented)
  # 
  # @method get_group_target(cr)
  # @param [Cairo] cr 
  # @return [Surface] 
  # @scope class
  attach_function :get_group_target, :cairo_get_group_target, [Cairo], Surface
  
  # cairo_path_data_type_t:
  # 
  # #cairo_path_data_t is used to describe the type of one portion
  # of a path when represented as a #cairo_path_t.
  # See #cairo_path_data_t for details.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:path_data_type).</em>
  # 
  # === Options:
  # :move_to ::
  #   A move-to operation
  # :line_to ::
  #   A line-to operation
  # :curve_to ::
  #   A curve-to operation
  # :close_path ::
  #   A close-path operation
  # 
  # @method _enum_path_data_type_
  # @return [Symbol]
  # @scope class
  enum :path_data_type, [
    :move_to, 0,
    :line_to, 1,
    :curve_to, 2,
    :close_path, 3
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :type ::
  #   (Symbol from _enum_path_data_type_) 
  # :length ::
  #   (Integer) 
  class PathDataTHeader < FFI::Struct
    layout :type, :path_data_type,
           :length, :int
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :x ::
  #   (Float) 
  # :y ::
  #   (Float) 
  class PathDataTPoint < FFI::Struct
    layout :x, :double,
           :y, :double
  end
  
  # cairo_path_data_t:
  # 
  # #cairo_path_data_t is used to represent the path data inside a
  # #cairo_path_t.
  # 
  # The data structure is designed to try to balance the demands of
  # efficiency and ease-of-use. A path is represented as an array of
  # #cairo_path_data_t, which is a union of headers and points.
  # 
  # Each portion of the path is represented by one or more elements in
  # the array, (one header followed by 0 or more points). The length
  # value of the header is the number of array elements for the current
  # portion including the header, (ie. length == 1 + # of points), and
  # where the number of points for each element type is as follows:
  # 
  # <programlisting>
  #     %CAIRO_PATH_MOVE_TO:     1 point
  #     %CAIRO_PATH_LINE_TO:     1 point
  #     %CAIRO_PATH_CURVE_TO:    3 points
  #     %CAIRO_PATH_CLOSE_PATH:  0 points
  # </programlisting>
  # 
  # The semantics and ordering of the coordinate values are consistent
  # with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
  # cairo_close_path().
  # 
  # Here is sample code for iterating through a #cairo_path_t:
  # 
  # <informalexample><programlisting>
  #      int i;
  #      cairo_path_t *path;
  #      cairo_path_data_t *data;
  # &nbsp;
  #      path = cairo_copy_path (cr);
  # &nbsp;
  #      for (i=0; i < path->num_data; i += path->data(i).header.length) {
  #          data = &amp;path->data(i);
  #          switch (data->header.type) {
  #          case CAIRO_PATH_MOVE_TO:
  #              do_move_to_things (data(1).point.x, data(1).point.y);
  #              break;
  #          case CAIRO_PATH_LINE_TO:
  #              do_line_to_things (data(1).point.x, data(1).point.y);
  #              break;
  #          case CAIRO_PATH_CURVE_TO:
  #              do_curve_to_things (data(1).point.x, data(1).point.y,
  #                                  data(2).point.x, data(2).point.y,
  #                                  data(3).point.x, data(3).point.y);
  #              break;
  #          case CAIRO_PATH_CLOSE_PATH:
  #              do_close_path_things ();
  #              break;
  #          }
  #      }
  #      cairo_path_destroy (path);
  # </programlisting></informalexample>
  # 
  # As of cairo 1.4, cairo does not mind if there are more elements in
  # a portion of the path than needed.  Such elements can be used by
  # users of the cairo API to hold extra values in the path data
  # structure.  For this reason, it is recommended that applications
  # always use <literal>data->header.length</literal> to
  # iterate over the path data, instead of hardcoding the number of
  # elements for each element type.
  # 
  # = Fields:
  # :header ::
  #   (PathDataTHeader) 
  # :point ::
  #   (PathDataTPoint) 
  class PathDataT < FFI::Union
    layout :header, PathDataTHeader.by_value,
           :point, PathDataTPoint.by_value
  end
  
  # cairo_path_t:
  # @status: the current error status
  # @data: the elements in the path
  # @num_data: the number of elements in the data array
  # 
  # A data structure for holding a path. This data structure serves as
  # the return value for cairo_copy_path() and
  # cairo_copy_path_flat() as well the input value for
  # cairo_append_path().
  # 
  # See #cairo_path_data_t for hints on how to iterate over the
  # actual data within the path.
  # 
  # The num_data member gives the number of elements in the data
  # array. This number is larger than the number of independent path
  # portions (defined in #cairo_path_data_type_t), since the data
  # includes both headers and coordinates for each portion.
  # 
  # = Fields:
  # :status ::
  #   (Symbol from _enum_status_) 
  # :data ::
  #   (PathDataT) 
  # :num_data ::
  #   (Integer) 
  module PathWrappers
    def destroy()
      Cairo.path_destroy(self)
    end
  end
  
  class Path < FFI::Struct
    include PathWrappers
    layout :status, :status,
           :data, PathDataT,
           :num_data, :int
  end
  
  # (Not documented)
  # 
  # @method copy_path(cr)
  # @param [Cairo] cr 
  # @return [Path] 
  # @scope class
  attach_function :copy_path, :cairo_copy_path, [Cairo], Path
  
  # (Not documented)
  # 
  # @method copy_path_flat(cr)
  # @param [Cairo] cr 
  # @return [Path] 
  # @scope class
  attach_function :copy_path_flat, :cairo_copy_path_flat, [Cairo], Path
  
  # (Not documented)
  # 
  # @method append_path(cr, path)
  # @param [Cairo] cr 
  # @param [Path] path 
  # @return [nil] 
  # @scope class
  attach_function :append_path, :cairo_append_path, [Cairo, Path], :void
  
  # (Not documented)
  # 
  # @method path_destroy(path)
  # @param [Path] path 
  # @return [nil] 
  # @scope class
  attach_function :path_destroy, :cairo_path_destroy, [Path], :void
  
  # Error status queries
  # 
  # @method status(cr)
  # @param [Cairo] cr 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :status, :cairo_status, [Cairo], :status
  
  # (Not documented)
  # 
  # @method status_to_string(status)
  # @param [Symbol from _enum_status_] status 
  # @return [String] 
  # @scope class
  attach_function :status_to_string, :cairo_status_to_string, [:status], :string
  
  # Backend device manipulation
  # 
  # @method device_reference(device)
  # @param [Device] device 
  # @return [Device] 
  # @scope class
  attach_function :device_reference, :cairo_device_reference, [Device], Device
  
  # cairo_device_type_t:
  # 
  # #cairo_device_type_t is used to describe the type of a given
  # device. The devices types are also known as "backends" within cairo.
  # 
  # The device type can be queried with cairo_device_get_type()
  # 
  # The various #cairo_device_t functions can be used with surfaces of
  # any type, but some backends also provide type-specific functions
  # that must only be called with a device of the appropriate
  # type. These functions have names that begin with
  # cairo_<emphasis>type</emphasis>_device<!-- --> such as cairo_xcb_device_debug_set_render_version().
  # 
  # The behavior of calling a type-specific function with a surface of
  # the wrong type is undefined.
  # 
  # New entries may be added in future versions.
  # 
  # Since: 1.10
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:device_type).</em>
  # 
  # === Options:
  # :drm ::
  #   The surface is of type Direct Render Manager
  # :gl ::
  #   The surface is of type OpenGL
  # :script ::
  #   The surface is of type script
  # :xcb ::
  #   The surface is of type xcb
  # :xlib ::
  #   The surface is of type xlib
  # :xml ::
  #   The surface is of type XML
  #     cairo_surface_create_for_rectangle()
  # 
  # @method _enum_device_type_
  # @return [Symbol]
  # @scope class
  enum :device_type, [
    :drm, 0,
    :gl, 1,
    :script, 2,
    :xcb, 3,
    :xlib, 4,
    :xml, 5
  ]
  
  # (Not documented)
  # 
  # @method device_get_type(device)
  # @param [Device] device 
  # @return [Symbol from _enum_device_type_] 
  # @scope class
  attach_function :device_get_type, :cairo_device_get_type, [Device], :device_type
  
  # (Not documented)
  # 
  # @method device_status(device)
  # @param [Device] device 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :device_status, :cairo_device_status, [Device], :status
  
  # (Not documented)
  # 
  # @method device_acquire(device)
  # @param [Device] device 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :device_acquire, :cairo_device_acquire, [Device], :status
  
  # (Not documented)
  # 
  # @method device_release(device)
  # @param [Device] device 
  # @return [nil] 
  # @scope class
  attach_function :device_release, :cairo_device_release, [Device], :void
  
  # (Not documented)
  # 
  # @method device_flush(device)
  # @param [Device] device 
  # @return [nil] 
  # @scope class
  attach_function :device_flush, :cairo_device_flush, [Device], :void
  
  # (Not documented)
  # 
  # @method device_finish(device)
  # @param [Device] device 
  # @return [nil] 
  # @scope class
  attach_function :device_finish, :cairo_device_finish, [Device], :void
  
  # (Not documented)
  # 
  # @method device_destroy(device)
  # @param [Device] device 
  # @return [nil] 
  # @scope class
  attach_function :device_destroy, :cairo_device_destroy, [Device], :void
  
  # (Not documented)
  # 
  # @method device_get_reference_count(device)
  # @param [Device] device 
  # @return [Integer] 
  # @scope class
  attach_function :device_get_reference_count, :cairo_device_get_reference_count, [Device], :uint
  
  # (Not documented)
  # 
  # @method device_get_user_data(device, key)
  # @param [Device] device 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :device_get_user_data, :cairo_device_get_user_data, [Device, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method device_set_user_data(device, key, user_data, destroy)
  # @param [Device] device 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :device_set_user_data, :cairo_device_set_user_data, [Device, UserDataKey, :pointer, :pointer], :status
  
  # Surface manipulation
  # 
  # @method surface_create_similar(other, content, width, height)
  # @param [Surface] other 
  # @param [Symbol from _enum_content_] content 
  # @param [Integer] width 
  # @param [Integer] height 
  # @return [Surface] 
  # @scope class
  attach_function :surface_create_similar, :cairo_surface_create_similar, [Surface, :content, :int, :int], Surface
  
  # (Not documented)
  # 
  # @method surface_create_for_rectangle(target, x, y, width, height)
  # @param [Surface] target 
  # @param [Float] x 
  # @param [Float] y 
  # @param [Float] width 
  # @param [Float] height 
  # @return [Surface] 
  # @scope class
  attach_function :surface_create_for_rectangle, :cairo_surface_create_for_rectangle, [Surface, :double, :double, :double, :double], Surface
  
  # (Not documented)
  # 
  # @method surface_reference(surface)
  # @param [Surface] surface 
  # @return [Surface] 
  # @scope class
  attach_function :surface_reference, :cairo_surface_reference, [Surface], Surface
  
  # (Not documented)
  # 
  # @method surface_finish(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_finish, :cairo_surface_finish, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_destroy(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_destroy, :cairo_surface_destroy, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_get_device(surface)
  # @param [Surface] surface 
  # @return [Device] 
  # @scope class
  attach_function :surface_get_device, :cairo_surface_get_device, [Surface], Device
  
  # (Not documented)
  # 
  # @method surface_get_reference_count(surface)
  # @param [Surface] surface 
  # @return [Integer] 
  # @scope class
  attach_function :surface_get_reference_count, :cairo_surface_get_reference_count, [Surface], :uint
  
  # (Not documented)
  # 
  # @method surface_status(surface)
  # @param [Surface] surface 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :surface_status, :cairo_surface_status, [Surface], :status
  
  # cairo_surface_type_t:
  # 
  # #cairo_surface_type_t is used to describe the type of a given
  # surface. The surface types are also known as "backends" or "surface
  # backends" within cairo.
  # 
  # The type of a surface is determined by the function used to create
  # it, which will generally be of the form cairo_<emphasis>type</emphasis>_surface_create(),
  # (though see cairo_surface_create_similar() as well).
  # 
  # The surface type can be queried with cairo_surface_get_type()
  # 
  # The various #cairo_surface_t functions can be used with surfaces of
  # any type, but some backends also provide type-specific functions
  # that must only be called with a surface of the appropriate
  # type. These functions have names that begin with
  # cairo_<emphasis>type</emphasis>_surface<!-- --> such as cairo_image_surface_get_width().
  # 
  # The behavior of calling a type-specific function with a surface of
  # the wrong type is undefined.
  # 
  # New entries may be added in future versions.
  # 
  # Since: 1.2
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:surface_type).</em>
  # 
  # === Options:
  # :image ::
  #   The surface is of type image
  # :pdf ::
  #   The surface is of type pdf
  # :ps ::
  #   The surface is of type ps
  # :xlib ::
  #   The surface is of type xlib
  # :xcb ::
  #   The surface is of type xcb
  # :glitz ::
  #   The surface is of type glitz
  # :quartz ::
  #   The surface is of type quartz
  # :win32 ::
  #   The surface is of type win32
  # :beos ::
  #   The surface is of type beos
  # :directfb ::
  #   The surface is of type directfb
  # :svg ::
  #   The surface is of type svg
  # :os2 ::
  #   The surface is of type os2
  # :win32_printing ::
  #   The surface is a win32 printing surface
  # :quartz_image ::
  #   The surface is of type quartz_image
  # :script ::
  #   The surface is of type script, since 1.10
  # :qt ::
  #   The surface is of type Qt, since 1.10
  # :recording ::
  #   The surface is of type recording, since 1.10
  # :vg ::
  #   The surface is a OpenVG surface, since 1.10
  # :gl ::
  #   The surface is of type OpenGL, since 1.10
  # :drm ::
  #   The surface is of type Direct Render Manager, since 1.10
  # :tee ::
  #   The surface is of type 'tee' (a multiplexing surface), since 1.10
  # :xml ::
  #   The surface is of type XML (for debugging), since 1.10
  # :skia ::
  #   The surface is of type Skia, since 1.10
  # :subsurface ::
  #   The surface is a subsurface created with
  #     cairo_surface_create_for_rectangle(), since 1.10
  # 
  # @method _enum_surface_type_
  # @return [Symbol]
  # @scope class
  enum :surface_type, [
    :image, 0,
    :pdf, 1,
    :ps, 2,
    :xlib, 3,
    :xcb, 4,
    :glitz, 5,
    :quartz, 6,
    :win32, 7,
    :beos, 8,
    :directfb, 9,
    :svg, 10,
    :os2, 11,
    :win32_printing, 12,
    :quartz_image, 13,
    :script, 14,
    :qt, 15,
    :recording, 16,
    :vg, 17,
    :gl, 18,
    :drm, 19,
    :tee, 20,
    :xml, 21,
    :skia, 22,
    :subsurface, 23
  ]
  
  # (Not documented)
  # 
  # @method surface_get_type(surface)
  # @param [Surface] surface 
  # @return [Symbol from _enum_surface_type_] 
  # @scope class
  attach_function :surface_get_type, :cairo_surface_get_type, [Surface], :surface_type
  
  # (Not documented)
  # 
  # @method surface_get_content(surface)
  # @param [Surface] surface 
  # @return [Symbol from _enum_content_] 
  # @scope class
  attach_function :surface_get_content, :cairo_surface_get_content, [Surface], :content
  
  # (Not documented)
  # 
  # @method surface_write_to_png(surface, filename)
  # @param [Surface] surface 
  # @param [String] filename 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :surface_write_to_png, :cairo_surface_write_to_png, [Surface, :string], :status
  
  # (Not documented)
  # 
  # @method surface_write_to_png_stream(surface, write_func, closure)
  # @param [Surface] surface 
  # @param [Proc(_callback_write_func_t_)] write_func 
  # @param [FFI::Pointer(*Void)] closure 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :surface_write_to_png_stream, :cairo_surface_write_to_png_stream, [Surface, :write_func_t, :pointer], :status
  
  # (Not documented)
  # 
  # @method surface_get_user_data(surface, key)
  # @param [Surface] surface 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :surface_get_user_data, :cairo_surface_get_user_data, [Surface, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method surface_set_user_data(surface, key, user_data, destroy)
  # @param [Surface] surface 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :surface_set_user_data, :cairo_surface_set_user_data, [Surface, UserDataKey, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method surface_get_mime_data(surface, mime_type, data, length)
  # @param [Surface] surface 
  # @param [String] mime_type 
  # @param [FFI::Pointer(**UChar)] data 
  # @param [FFI::Pointer(*ULong)] length 
  # @return [nil] 
  # @scope class
  attach_function :surface_get_mime_data, :cairo_surface_get_mime_data, [Surface, :string, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method surface_set_mime_data(surface, mime_type, data, length, destroy, closure)
  # @param [Surface] surface 
  # @param [String] mime_type 
  # @param [FFI::Pointer(*UChar)] data 
  # @param [Integer] length 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @param [FFI::Pointer(*Void)] closure 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :surface_set_mime_data, :cairo_surface_set_mime_data, [Surface, :string, :pointer, :ulong, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method surface_get_font_options(surface, options)
  # @param [Surface] surface 
  # @param [FontOptions] options 
  # @return [nil] 
  # @scope class
  attach_function :surface_get_font_options, :cairo_surface_get_font_options, [Surface, FontOptions], :void
  
  # (Not documented)
  # 
  # @method surface_flush(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_flush, :cairo_surface_flush, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_mark_dirty(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_mark_dirty, :cairo_surface_mark_dirty, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_mark_dirty_rectangle(surface, x, y, width, height)
  # @param [Surface] surface 
  # @param [Integer] x 
  # @param [Integer] y 
  # @param [Integer] width 
  # @param [Integer] height 
  # @return [nil] 
  # @scope class
  attach_function :surface_mark_dirty_rectangle, :cairo_surface_mark_dirty_rectangle, [Surface, :int, :int, :int, :int], :void
  
  # (Not documented)
  # 
  # @method surface_set_device_offset(surface, x_offset, y_offset)
  # @param [Surface] surface 
  # @param [Float] x_offset 
  # @param [Float] y_offset 
  # @return [nil] 
  # @scope class
  attach_function :surface_set_device_offset, :cairo_surface_set_device_offset, [Surface, :double, :double], :void
  
  # (Not documented)
  # 
  # @method surface_get_device_offset(surface, x_offset, y_offset)
  # @param [Surface] surface 
  # @param [FFI::Pointer(*Double)] x_offset 
  # @param [FFI::Pointer(*Double)] y_offset 
  # @return [nil] 
  # @scope class
  attach_function :surface_get_device_offset, :cairo_surface_get_device_offset, [Surface, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method surface_set_fallback_resolution(surface, x_pixels_per_inch, y_pixels_per_inch)
  # @param [Surface] surface 
  # @param [Float] x_pixels_per_inch 
  # @param [Float] y_pixels_per_inch 
  # @return [nil] 
  # @scope class
  attach_function :surface_set_fallback_resolution, :cairo_surface_set_fallback_resolution, [Surface, :double, :double], :void
  
  # (Not documented)
  # 
  # @method surface_get_fallback_resolution(surface, x_pixels_per_inch, y_pixels_per_inch)
  # @param [Surface] surface 
  # @param [FFI::Pointer(*Double)] x_pixels_per_inch 
  # @param [FFI::Pointer(*Double)] y_pixels_per_inch 
  # @return [nil] 
  # @scope class
  attach_function :surface_get_fallback_resolution, :cairo_surface_get_fallback_resolution, [Surface, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method surface_copy_page(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_copy_page, :cairo_surface_copy_page, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_show_page(surface)
  # @param [Surface] surface 
  # @return [nil] 
  # @scope class
  attach_function :surface_show_page, :cairo_surface_show_page, [Surface], :void
  
  # (Not documented)
  # 
  # @method surface_has_show_text_glyphs(surface)
  # @param [Surface] surface 
  # @return [Integer] 
  # @scope class
  attach_function :surface_has_show_text_glyphs, :cairo_surface_has_show_text_glyphs, [Surface], :int
  
  # cairo_format_t:
  # 
  # #cairo_format_t is used to identify the memory format of
  # image data.
  # 
  # New entries may be added in future versions.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:format).</em>
  # 
  # === Options:
  # :invalid ::
  #   no such format exists or is supported.
  # :argb32 ::
  #   each pixel is a 32-bit quantity, with
  #     alpha in the upper 8 bits, then red, then green, then blue.
  #     The 32-bit quantities are stored native-endian. Pre-multiplied
  #     alpha is used. (That is, 50% transparent red is 0x80800000,
  #     not 0x80ff0000.)
  # :rgb24 ::
  #   each pixel is a 32-bit quantity, with
  #     the upper 8 bits unused. Red, Green, and Blue are stored
  #     in the remaining 24 bits in that order.
  # :a8 ::
  #   each pixel is a 8-bit quantity holding
  #     an alpha value.
  # :a1 ::
  #   each pixel is a 1-bit quantity holding
  #     an alpha value. Pixels are packed together into 32-bit
  #     quantities. The ordering of the bits matches the
  #     endianess of the platform. On a big-endian machine, the
  #     first pixel is in the uppermost bit, on a little-endian
  #     machine the first pixel is in the least-significant bit.
  # :rgb16_565 ::
  #   each pixel is a 16-bit quantity
  #     with red in the upper 5 bits, then green in the middle
  #     6 bits, and blue in the lower 5 bits.
  # 
  # @method _enum_format_
  # @return [Symbol]
  # @scope class
  enum :format, [
    :invalid, -1,
    :argb32, 0,
    :rgb24, 1,
    :a8, 2,
    :a1, 3,
    :rgb16_565, 4
  ]
  
  # (Not documented)
  # 
  # @method image_surface_create(format, width, height)
  # @param [Symbol from _enum_format_] format 
  # @param [Integer] width 
  # @param [Integer] height 
  # @return [Surface] 
  # @scope class
  attach_function :image_surface_create, :cairo_image_surface_create, [:format, :int, :int], Surface
  
  # (Not documented)
  # 
  # @method format_stride_for_width(format, width)
  # @param [Symbol from _enum_format_] format 
  # @param [Integer] width 
  # @return [Integer] 
  # @scope class
  attach_function :format_stride_for_width, :cairo_format_stride_for_width, [:format, :int], :int
  
  # (Not documented)
  # 
  # @method image_surface_create_for_data(data, format, width, height, stride)
  # @param [FFI::Pointer(*UChar)] data 
  # @param [Symbol from _enum_format_] format 
  # @param [Integer] width 
  # @param [Integer] height 
  # @param [Integer] stride 
  # @return [Surface] 
  # @scope class
  attach_function :image_surface_create_for_data, :cairo_image_surface_create_for_data, [:pointer, :format, :int, :int, :int], Surface
  
  # (Not documented)
  # 
  # @method image_surface_get_data(surface)
  # @param [Surface] surface 
  # @return [FFI::Pointer(*UChar)] 
  # @scope class
  attach_function :image_surface_get_data, :cairo_image_surface_get_data, [Surface], :pointer
  
  # (Not documented)
  # 
  # @method image_surface_get_format(surface)
  # @param [Surface] surface 
  # @return [Symbol from _enum_format_] 
  # @scope class
  attach_function :image_surface_get_format, :cairo_image_surface_get_format, [Surface], :format
  
  # (Not documented)
  # 
  # @method image_surface_get_width(surface)
  # @param [Surface] surface 
  # @return [Integer] 
  # @scope class
  attach_function :image_surface_get_width, :cairo_image_surface_get_width, [Surface], :int
  
  # (Not documented)
  # 
  # @method image_surface_get_height(surface)
  # @param [Surface] surface 
  # @return [Integer] 
  # @scope class
  attach_function :image_surface_get_height, :cairo_image_surface_get_height, [Surface], :int
  
  # (Not documented)
  # 
  # @method image_surface_get_stride(surface)
  # @param [Surface] surface 
  # @return [Integer] 
  # @scope class
  attach_function :image_surface_get_stride, :cairo_image_surface_get_stride, [Surface], :int
  
  # (Not documented)
  # 
  # @method image_surface_create_from_png(filename)
  # @param [String] filename 
  # @return [Surface] 
  # @scope class
  attach_function :image_surface_create_from_png, :cairo_image_surface_create_from_png, [:string], Surface
  
  # (Not documented)
  # 
  # @method image_surface_create_from_png_stream(read_func, closure)
  # @param [Proc(_callback_read_func_t_)] read_func 
  # @param [FFI::Pointer(*Void)] closure 
  # @return [Surface] 
  # @scope class
  attach_function :image_surface_create_from_png_stream, :cairo_image_surface_create_from_png_stream, [:read_func_t, :pointer], Surface
  
  # Recording-surface functions
  # 
  # @method recording_surface_create(content, extents)
  # @param [Symbol from _enum_content_] content 
  # @param [Rectangle] extents 
  # @return [Surface] 
  # @scope class
  attach_function :recording_surface_create, :cairo_recording_surface_create, [:content, Rectangle], Surface
  
  # (Not documented)
  # 
  # @method recording_surface_ink_extents(surface, x0, y0, width, height)
  # @param [Surface] surface 
  # @param [FFI::Pointer(*Double)] x0 
  # @param [FFI::Pointer(*Double)] y0 
  # @param [FFI::Pointer(*Double)] width 
  # @param [FFI::Pointer(*Double)] height 
  # @return [nil] 
  # @scope class
  attach_function :recording_surface_ink_extents, :cairo_recording_surface_ink_extents, [Surface, :pointer, :pointer, :pointer, :pointer], :void
  
  # Pattern creation functions
  # 
  # @method pattern_create_rgb(red, green, blue)
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_create_rgb, :cairo_pattern_create_rgb, [:double, :double, :double], Pattern
  
  # (Not documented)
  # 
  # @method pattern_create_rgba(red, green, blue, alpha)
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @param [Float] alpha 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_create_rgba, :cairo_pattern_create_rgba, [:double, :double, :double, :double], Pattern
  
  # (Not documented)
  # 
  # @method pattern_create_for_surface(surface)
  # @param [Surface] surface 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_create_for_surface, :cairo_pattern_create_for_surface, [Surface], Pattern
  
  # (Not documented)
  # 
  # @method pattern_create_linear(x0, y0, x1, y1)
  # @param [Float] x0 
  # @param [Float] y0 
  # @param [Float] x1 
  # @param [Float] y1 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_create_linear, :cairo_pattern_create_linear, [:double, :double, :double, :double], Pattern
  
  # (Not documented)
  # 
  # @method pattern_create_radial(cx0, cy0, radius0, cx1, cy1, radius1)
  # @param [Float] cx0 
  # @param [Float] cy0 
  # @param [Float] radius0 
  # @param [Float] cx1 
  # @param [Float] cy1 
  # @param [Float] radius1 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_create_radial, :cairo_pattern_create_radial, [:double, :double, :double, :double, :double, :double], Pattern
  
  # (Not documented)
  # 
  # @method pattern_reference(pattern)
  # @param [Pattern] pattern 
  # @return [Pattern] 
  # @scope class
  attach_function :pattern_reference, :cairo_pattern_reference, [Pattern], Pattern
  
  # (Not documented)
  # 
  # @method pattern_destroy(pattern)
  # @param [Pattern] pattern 
  # @return [nil] 
  # @scope class
  attach_function :pattern_destroy, :cairo_pattern_destroy, [Pattern], :void
  
  # (Not documented)
  # 
  # @method pattern_get_reference_count(pattern)
  # @param [Pattern] pattern 
  # @return [Integer] 
  # @scope class
  attach_function :pattern_get_reference_count, :cairo_pattern_get_reference_count, [Pattern], :uint
  
  # (Not documented)
  # 
  # @method pattern_status(pattern)
  # @param [Pattern] pattern 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_status, :cairo_pattern_status, [Pattern], :status
  
  # (Not documented)
  # 
  # @method pattern_get_user_data(pattern, key)
  # @param [Pattern] pattern 
  # @param [UserDataKey] key 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :pattern_get_user_data, :cairo_pattern_get_user_data, [Pattern, UserDataKey], :pointer
  
  # (Not documented)
  # 
  # @method pattern_set_user_data(pattern, key, user_data, destroy)
  # @param [Pattern] pattern 
  # @param [UserDataKey] key 
  # @param [FFI::Pointer(*Void)] user_data 
  # @param [FFI::Pointer(DestroyFuncT)] destroy 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_set_user_data, :cairo_pattern_set_user_data, [Pattern, UserDataKey, :pointer, :pointer], :status
  
  # cairo_pattern_type_t:
  # 
  # #cairo_pattern_type_t is used to describe the type of a given pattern.
  # 
  # The type of a pattern is determined by the function used to create
  # it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
  # functions create SOLID patterns. The remaining
  # cairo_pattern_create<!-- --> functions map to pattern types in obvious
  # ways.
  # 
  # The pattern type can be queried with cairo_pattern_get_type()
  # 
  # Most #cairo_pattern_t functions can be called with a pattern of any
  # type, (though trying to change the extend or filter for a solid
  # pattern will have no effect). A notable exception is
  # cairo_pattern_add_color_stop_rgb() and
  # cairo_pattern_add_color_stop_rgba() which must only be called with
  # gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
  # will be shutdown and put into an error state.
  # 
  # New entries may be added in future versions.
  # 
  # Since: 1.2
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:pattern_type).</em>
  # 
  # === Options:
  # :solid ::
  #   The pattern is a solid (uniform)
  #   color. It may be opaque or translucent.
  # :surface ::
  #   The pattern is a based on a surface (an image).
  # :linear ::
  #   The pattern is a linear gradient.
  # :radial ::
  #   The pattern is a radial gradient.
  # 
  # @method _enum_pattern_type_
  # @return [Symbol]
  # @scope class
  enum :pattern_type, [
    :solid, 0,
    :surface, 1,
    :linear, 2,
    :radial, 3
  ]
  
  # (Not documented)
  # 
  # @method pattern_get_type(pattern)
  # @param [Pattern] pattern 
  # @return [Symbol from _enum_pattern_type_] 
  # @scope class
  attach_function :pattern_get_type, :cairo_pattern_get_type, [Pattern], :pattern_type
  
  # (Not documented)
  # 
  # @method pattern_add_color_stop_rgb(pattern, offset, red, green, blue)
  # @param [Pattern] pattern 
  # @param [Float] offset 
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @return [nil] 
  # @scope class
  attach_function :pattern_add_color_stop_rgb, :cairo_pattern_add_color_stop_rgb, [Pattern, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method pattern_add_color_stop_rgba(pattern, offset, red, green, blue, alpha)
  # @param [Pattern] pattern 
  # @param [Float] offset 
  # @param [Float] red 
  # @param [Float] green 
  # @param [Float] blue 
  # @param [Float] alpha 
  # @return [nil] 
  # @scope class
  attach_function :pattern_add_color_stop_rgba, :cairo_pattern_add_color_stop_rgba, [Pattern, :double, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method pattern_set_matrix(pattern, matrix)
  # @param [Pattern] pattern 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :pattern_set_matrix, :cairo_pattern_set_matrix, [Pattern, Matrix], :void
  
  # (Not documented)
  # 
  # @method pattern_get_matrix(pattern, matrix)
  # @param [Pattern] pattern 
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :pattern_get_matrix, :cairo_pattern_get_matrix, [Pattern, Matrix], :void
  
  # cairo_extend_t:
  # 
  # #cairo_extend_t is used to describe how pattern color/alpha will be
  # determined for areas "outside" the pattern's natural area, (for
  # example, outside the surface bounds or outside the gradient
  # geometry).
  # 
  # The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
  # and %CAIRO_EXTEND_PAD for gradient patterns.
  # 
  # New entries may be added in future versions.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:extend).</em>
  # 
  # === Options:
  # :none ::
  #   pixels outside of the source pattern
  #     are fully transparent
  # :repeat ::
  #   the pattern is tiled by repeating
  # :reflect ::
  #   the pattern is tiled by reflecting
  #     at the edges (Implemented for surface patterns since 1.6)
  # :pad ::
  #   pixels outside of the pattern copy
  #     the closest pixel from the source (Since 1.2; but only
  #     implemented for surface patterns since 1.6)
  # 
  # @method _enum_extend_
  # @return [Symbol]
  # @scope class
  enum :extend, [
    :none, 0,
    :repeat, 1,
    :reflect, 2,
    :pad, 3
  ]
  
  # (Not documented)
  # 
  # @method pattern_set_extend(pattern, extend)
  # @param [Pattern] pattern 
  # @param [Symbol from _enum_extend_] extend 
  # @return [nil] 
  # @scope class
  attach_function :pattern_set_extend, :cairo_pattern_set_extend, [Pattern, :extend], :void
  
  # (Not documented)
  # 
  # @method pattern_get_extend(pattern)
  # @param [Pattern] pattern 
  # @return [Symbol from _enum_extend_] 
  # @scope class
  attach_function :pattern_get_extend, :cairo_pattern_get_extend, [Pattern], :extend
  
  # cairo_filter_t:
  # 
  # #cairo_filter_t is used to indicate what filtering should be
  # applied when reading pixel values from patterns. See
  # cairo_pattern_set_source() for indicating the desired filter to be
  # used with a particular pattern.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:filter).</em>
  # 
  # === Options:
  # :fast ::
  #   A high-performance filter, with quality similar
  #       to %CAIRO_FILTER_NEAREST
  # :good ::
  #   A reasonable-performance filter, with quality
  #       similar to %CAIRO_FILTER_BILINEAR
  # :best ::
  #   The highest-quality available, performance may
  #       not be suitable for interactive use.
  # :nearest ::
  #   Nearest-neighbor filtering
  # :bilinear ::
  #   Linear interpolation in two dimensions
  # :gaussian ::
  #   This filter value is currently
  #       unimplemented, and should not be used in current code.
  # 
  # @method _enum_filter_
  # @return [Symbol]
  # @scope class
  enum :filter, [
    :fast, 0,
    :good, 1,
    :best, 2,
    :nearest, 3,
    :bilinear, 4,
    :gaussian, 5
  ]
  
  # (Not documented)
  # 
  # @method pattern_set_filter(pattern, filter)
  # @param [Pattern] pattern 
  # @param [Symbol from _enum_filter_] filter 
  # @return [nil] 
  # @scope class
  attach_function :pattern_set_filter, :cairo_pattern_set_filter, [Pattern, :filter], :void
  
  # (Not documented)
  # 
  # @method pattern_get_filter(pattern)
  # @param [Pattern] pattern 
  # @return [Symbol from _enum_filter_] 
  # @scope class
  attach_function :pattern_get_filter, :cairo_pattern_get_filter, [Pattern], :filter
  
  # (Not documented)
  # 
  # @method pattern_get_rgba(pattern, red, green, blue, alpha)
  # @param [Pattern] pattern 
  # @param [FFI::Pointer(*Double)] red 
  # @param [FFI::Pointer(*Double)] green 
  # @param [FFI::Pointer(*Double)] blue 
  # @param [FFI::Pointer(*Double)] alpha 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_rgba, :cairo_pattern_get_rgba, [Pattern, :pointer, :pointer, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method pattern_get_surface(pattern, surface)
  # @param [Pattern] pattern 
  # @param [FFI::Pointer(**SurfaceT)] surface 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_surface, :cairo_pattern_get_surface, [Pattern, :pointer], :status
  
  # (Not documented)
  # 
  # @method pattern_get_color_stop_rgba(pattern, index, offset, red, green, blue, alpha)
  # @param [Pattern] pattern 
  # @param [Integer] index 
  # @param [FFI::Pointer(*Double)] offset 
  # @param [FFI::Pointer(*Double)] red 
  # @param [FFI::Pointer(*Double)] green 
  # @param [FFI::Pointer(*Double)] blue 
  # @param [FFI::Pointer(*Double)] alpha 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_color_stop_rgba, :cairo_pattern_get_color_stop_rgba, [Pattern, :int, :pointer, :pointer, :pointer, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method pattern_get_color_stop_count(pattern, count)
  # @param [Pattern] pattern 
  # @param [FFI::Pointer(*Int)] count 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_color_stop_count, :cairo_pattern_get_color_stop_count, [Pattern, :pointer], :status
  
  # (Not documented)
  # 
  # @method pattern_get_linear_points(pattern, x0, y0, x1, y1)
  # @param [Pattern] pattern 
  # @param [FFI::Pointer(*Double)] x0 
  # @param [FFI::Pointer(*Double)] y0 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_linear_points, :cairo_pattern_get_linear_points, [Pattern, :pointer, :pointer, :pointer, :pointer], :status
  
  # (Not documented)
  # 
  # @method pattern_get_radial_circles(pattern, x0, y0, r0, x1, y1, r1)
  # @param [Pattern] pattern 
  # @param [FFI::Pointer(*Double)] x0 
  # @param [FFI::Pointer(*Double)] y0 
  # @param [FFI::Pointer(*Double)] r0 
  # @param [FFI::Pointer(*Double)] x1 
  # @param [FFI::Pointer(*Double)] y1 
  # @param [FFI::Pointer(*Double)] r1 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :pattern_get_radial_circles, :cairo_pattern_get_radial_circles, [Pattern, :pointer, :pointer, :pointer, :pointer, :pointer, :pointer], :status
  
  # Matrix functions
  # 
  # @method matrix_init(matrix, xx, yx, xy, yy, x0, y0)
  # @param [Matrix] matrix 
  # @param [Float] xx 
  # @param [Float] yx 
  # @param [Float] xy 
  # @param [Float] yy 
  # @param [Float] x0 
  # @param [Float] y0 
  # @return [nil] 
  # @scope class
  attach_function :matrix_init, :cairo_matrix_init, [Matrix, :double, :double, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_init_identity(matrix)
  # @param [Matrix] matrix 
  # @return [nil] 
  # @scope class
  attach_function :matrix_init_identity, :cairo_matrix_init_identity, [Matrix], :void
  
  # (Not documented)
  # 
  # @method matrix_init_translate(matrix, tx, ty)
  # @param [Matrix] matrix 
  # @param [Float] tx 
  # @param [Float] ty 
  # @return [nil] 
  # @scope class
  attach_function :matrix_init_translate, :cairo_matrix_init_translate, [Matrix, :double, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_init_scale(matrix, sx, sy)
  # @param [Matrix] matrix 
  # @param [Float] sx 
  # @param [Float] sy 
  # @return [nil] 
  # @scope class
  attach_function :matrix_init_scale, :cairo_matrix_init_scale, [Matrix, :double, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_init_rotate(matrix, radians)
  # @param [Matrix] matrix 
  # @param [Float] radians 
  # @return [nil] 
  # @scope class
  attach_function :matrix_init_rotate, :cairo_matrix_init_rotate, [Matrix, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_translate(matrix, tx, ty)
  # @param [Matrix] matrix 
  # @param [Float] tx 
  # @param [Float] ty 
  # @return [nil] 
  # @scope class
  attach_function :matrix_translate, :cairo_matrix_translate, [Matrix, :double, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_scale(matrix, sx, sy)
  # @param [Matrix] matrix 
  # @param [Float] sx 
  # @param [Float] sy 
  # @return [nil] 
  # @scope class
  attach_function :matrix_scale, :cairo_matrix_scale, [Matrix, :double, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_rotate(matrix, radians)
  # @param [Matrix] matrix 
  # @param [Float] radians 
  # @return [nil] 
  # @scope class
  attach_function :matrix_rotate, :cairo_matrix_rotate, [Matrix, :double], :void
  
  # (Not documented)
  # 
  # @method matrix_invert(matrix)
  # @param [Matrix] matrix 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :matrix_invert, :cairo_matrix_invert, [Matrix], :status
  
  # (Not documented)
  # 
  # @method matrix_multiply(result, a, b)
  # @param [Matrix] result 
  # @param [Matrix] a 
  # @param [Matrix] b 
  # @return [nil] 
  # @scope class
  attach_function :matrix_multiply, :cairo_matrix_multiply, [Matrix, Matrix, Matrix], :void
  
  # (Not documented)
  # 
  # @method matrix_transform_distance(matrix, dx, dy)
  # @param [Matrix] matrix 
  # @param [FFI::Pointer(*Double)] dx 
  # @param [FFI::Pointer(*Double)] dy 
  # @return [nil] 
  # @scope class
  attach_function :matrix_transform_distance, :cairo_matrix_transform_distance, [Matrix, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method matrix_transform_point(matrix, x, y)
  # @param [Matrix] matrix 
  # @param [FFI::Pointer(*Double)] x 
  # @param [FFI::Pointer(*Double)] y 
  # @return [nil] 
  # @scope class
  attach_function :matrix_transform_point, :cairo_matrix_transform_point, [Matrix, :pointer, :pointer], :void
  
  # cairo_region_t:
  # 
  # A #cairo_region_t represents a set of integer-aligned rectangles.
  # 
  # It allows set-theoretical operations like cairo_region_union() and
  # cairo_region_intersect() to be performed on them.
  # 
  # Memory management of #cairo_region_t is done with
  # cairo_region_reference() and cairo_region_destroy().
  # 
  # Since: 1.10
  module RegionWrappers
    def copy()
      Region.new Cairo.region_copy(self)
    end
    
    def reference()
      Region.new Cairo.region_reference(self)
    end
    
    def destroy()
      Cairo.region_destroy(self)
    end
    
    def equal(b)
      Cairo.region_equal(self, b)
    end
    
    def status()
      Cairo.region_status(self)
    end
    
    def get_extents(extents)
      Cairo.region_get_extents(self, extents)
    end
    
    def num_rectangles()
      Cairo.region_num_rectangles(self)
    end
    
    def get_rectangle(nth, rectangle)
      Cairo.region_get_rectangle(self, nth, rectangle)
    end
    
    def is_empty()
      Cairo.region_is_empty(self)
    end
    
    def contains_rectangle(rectangle)
      Cairo.region_contains_rectangle(self, rectangle)
    end
    
    def contains_point(x, y)
      Cairo.region_contains_point(self, x, y)
    end
    
    def translate(dx, dy)
      Cairo.region_translate(self, dx, dy)
    end
    
    def subtract(other)
      Cairo.region_subtract(self, other)
    end
    
    def subtract_rectangle(rectangle)
      Cairo.region_subtract_rectangle(self, rectangle)
    end
    
    def intersect(other)
      Cairo.region_intersect(self, other)
    end
    
    def intersect_rectangle(rectangle)
      Cairo.region_intersect_rectangle(self, rectangle)
    end
    
    def union(other)
      Cairo.region_union(self, other)
    end
    
    def union_rectangle(rectangle)
      Cairo.region_union_rectangle(self, rectangle)
    end
    
    def xor(other)
      Cairo.region_xor(self, other)
    end
    
    def xor_rectangle(rectangle)
      Cairo.region_xor_rectangle(self, rectangle)
    end
  end
  
  class Region < FFI::Struct
    include RegionWrappers
    layout :dummy, :char
  end
  
  # cairo_rectangle_int_t:
  # @x: X coordinate of the left side of the rectangle
  # @y: Y coordinate of the the top side of the rectangle
  # @width: width of the rectangle
  # @height: height of the rectangle
  # 
  # A data structure for holding a rectangle with integer coordinates.
  # 
  # Since: 1.10
  # 
  # = Fields:
  # :x ::
  #   (Integer) 
  # :y ::
  #   (Integer) 
  # :width ::
  #   (Integer) 
  # :height ::
  #   (Integer) 
  class RectangleInt < FFI::Struct
    layout :x, :int,
           :y, :int,
           :width, :int,
           :height, :int
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:region_overlap).</em>
  # 
  # === Options:
  # :in_ ::
  #   
  # :out ::
  #   completely inside region
  # :part ::
  #   completely outside region
  # 
  # @method _enum_region_overlap_
  # @return [Symbol]
  # @scope class
  enum :region_overlap, [
    :in_, 0,
    :out, 1,
    :part, 2
  ]
  
  # (Not documented)
  # 
  # @method region_create()
  # @return [Region] 
  # @scope class
  attach_function :region_create, :cairo_region_create, [], Region
  
  # (Not documented)
  # 
  # @method region_create_rectangle(rectangle)
  # @param [RectangleInt] rectangle 
  # @return [Region] 
  # @scope class
  attach_function :region_create_rectangle, :cairo_region_create_rectangle, [RectangleInt], Region
  
  # (Not documented)
  # 
  # @method region_create_rectangles(rects, count)
  # @param [RectangleInt] rects 
  # @param [Integer] count 
  # @return [Region] 
  # @scope class
  attach_function :region_create_rectangles, :cairo_region_create_rectangles, [RectangleInt, :int], Region
  
  # (Not documented)
  # 
  # @method region_copy(original)
  # @param [Region] original 
  # @return [Region] 
  # @scope class
  attach_function :region_copy, :cairo_region_copy, [Region], Region
  
  # (Not documented)
  # 
  # @method region_reference(region)
  # @param [Region] region 
  # @return [Region] 
  # @scope class
  attach_function :region_reference, :cairo_region_reference, [Region], Region
  
  # (Not documented)
  # 
  # @method region_destroy(region)
  # @param [Region] region 
  # @return [nil] 
  # @scope class
  attach_function :region_destroy, :cairo_region_destroy, [Region], :void
  
  # (Not documented)
  # 
  # @method region_equal(a, b)
  # @param [Region] a 
  # @param [Region] b 
  # @return [Integer] 
  # @scope class
  attach_function :region_equal, :cairo_region_equal, [Region, Region], :int
  
  # (Not documented)
  # 
  # @method region_status(region)
  # @param [Region] region 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_status, :cairo_region_status, [Region], :status
  
  # (Not documented)
  # 
  # @method region_get_extents(region, extents)
  # @param [Region] region 
  # @param [RectangleInt] extents 
  # @return [nil] 
  # @scope class
  attach_function :region_get_extents, :cairo_region_get_extents, [Region, RectangleInt], :void
  
  # (Not documented)
  # 
  # @method region_num_rectangles(region)
  # @param [Region] region 
  # @return [Integer] 
  # @scope class
  attach_function :region_num_rectangles, :cairo_region_num_rectangles, [Region], :int
  
  # (Not documented)
  # 
  # @method region_get_rectangle(region, nth, rectangle)
  # @param [Region] region 
  # @param [Integer] nth 
  # @param [RectangleInt] rectangle 
  # @return [nil] 
  # @scope class
  attach_function :region_get_rectangle, :cairo_region_get_rectangle, [Region, :int, RectangleInt], :void
  
  # (Not documented)
  # 
  # @method region_is_empty(region)
  # @param [Region] region 
  # @return [Integer] 
  # @scope class
  attach_function :region_is_empty, :cairo_region_is_empty, [Region], :int
  
  # (Not documented)
  # 
  # @method region_contains_rectangle(region, rectangle)
  # @param [Region] region 
  # @param [RectangleInt] rectangle 
  # @return [Symbol from _enum_region_overlap_] 
  # @scope class
  attach_function :region_contains_rectangle, :cairo_region_contains_rectangle, [Region, RectangleInt], :region_overlap
  
  # (Not documented)
  # 
  # @method region_contains_point(region, x, y)
  # @param [Region] region 
  # @param [Integer] x 
  # @param [Integer] y 
  # @return [Integer] 
  # @scope class
  attach_function :region_contains_point, :cairo_region_contains_point, [Region, :int, :int], :int
  
  # (Not documented)
  # 
  # @method region_translate(region, dx, dy)
  # @param [Region] region 
  # @param [Integer] dx 
  # @param [Integer] dy 
  # @return [nil] 
  # @scope class
  attach_function :region_translate, :cairo_region_translate, [Region, :int, :int], :void
  
  # (Not documented)
  # 
  # @method region_subtract(dst, other)
  # @param [Region] dst 
  # @param [Region] other 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_subtract, :cairo_region_subtract, [Region, Region], :status
  
  # (Not documented)
  # 
  # @method region_subtract_rectangle(dst, rectangle)
  # @param [Region] dst 
  # @param [RectangleInt] rectangle 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_subtract_rectangle, :cairo_region_subtract_rectangle, [Region, RectangleInt], :status
  
  # (Not documented)
  # 
  # @method region_intersect(dst, other)
  # @param [Region] dst 
  # @param [Region] other 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_intersect, :cairo_region_intersect, [Region, Region], :status
  
  # (Not documented)
  # 
  # @method region_intersect_rectangle(dst, rectangle)
  # @param [Region] dst 
  # @param [RectangleInt] rectangle 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_intersect_rectangle, :cairo_region_intersect_rectangle, [Region, RectangleInt], :status
  
  # (Not documented)
  # 
  # @method region_union(dst, other)
  # @param [Region] dst 
  # @param [Region] other 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_union, :cairo_region_union, [Region, Region], :status
  
  # (Not documented)
  # 
  # @method region_union_rectangle(dst, rectangle)
  # @param [Region] dst 
  # @param [RectangleInt] rectangle 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_union_rectangle, :cairo_region_union_rectangle, [Region, RectangleInt], :status
  
  # (Not documented)
  # 
  # @method region_xor(dst, other)
  # @param [Region] dst 
  # @param [Region] other 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_xor, :cairo_region_xor, [Region, Region], :status
  
  # (Not documented)
  # 
  # @method region_xor_rectangle(dst, rectangle)
  # @param [Region] dst 
  # @param [RectangleInt] rectangle 
  # @return [Symbol from _enum_status_] 
  # @scope class
  attach_function :region_xor_rectangle, :cairo_region_xor_rectangle, [Region, RectangleInt], :status
  
  # Functions to be used while debugging (not intended for use in production code)
  # 
  # @method debug_reset_static_data()
  # @return [nil] 
  # @scope class
  attach_function :debug_reset_static_data, :cairo_debug_reset_static_data, [], :void
  
end
