# Generated by ffi_gen. Please do not change this file by hand.

require 'ffi'

module Glib
  extend FFI::Library
  ffi_lib 'libglib-2.0-0'
  
  def self.attach_function(name, *_)
    begin; super; rescue FFI::NotFoundError => e
      (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
    end
  end
  
  G_GNUC_FUNCTION = ""
  
  G_GNUC_PRETTY_FUNCTION = ""
  
  G_E = 2.7182818284590452353602874713526624977572470937000
  
  G_LN2 = 0.69314718055994530941723212145817656807550013436026
  
  G_LN10 = 2.3025850929940456840179914546843642076011014886288
  
  G_PI = 3.1415926535897932384626433832795028841971693993751
  
  G_PI_2 = 1.5707963267948966192313216916397514420985846996876
  
  G_PI_4 = 0.78539816339744830961566084581987572104929234984378
  
  G_SQRT2 = 1.4142135623730950488016887242096980785696718753769
  
  G_LITTLE_ENDIAN = 1234
  
  G_BIG_ENDIAN = 4321
  
  G_PDP_ENDIAN = 3412
  
  G_DATALIST_FLAGS_MASK = 0x3
  
  G_DATE_BAD_JULIAN = 0
  
  G_DATE_BAD_DAY = 0
  
  G_DATE_BAD_YEAR = 0
  
  G_DIR_SEPARATOR = '\\'
  
  G_DIR_SEPARATOR_S = "\\"
  
  G_SEARCHPATH_SEPARATOR = ';'
  
  G_SEARCHPATH_SEPARATOR_S = ";"
  
  G_POLLFD_FORMAT = "%#x"
  
  G_PRIORITY_HIGH = -100
  
  G_PRIORITY_DEFAULT = 0
  
  G_PRIORITY_HIGH_IDLE = 100
  
  G_PRIORITY_DEFAULT_IDLE = 200
  
  G_PRIORITY_LOW = 300
  
  G_UNICHAR_MAX_DECOMPOSITION_LENGTH = 18
  
  G_WIN32_MSG_HANDLE = 19981206
  
  G_KEY_FILE_DESKTOP_GROUP = "Desktop Entry"
  
  G_KEY_FILE_DESKTOP_KEY_TYPE = "Type"
  
  G_KEY_FILE_DESKTOP_KEY_VERSION = "Version"
  
  G_KEY_FILE_DESKTOP_KEY_NAME = "Name"
  
  G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = "GenericName"
  
  G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = "NoDisplay"
  
  G_KEY_FILE_DESKTOP_KEY_COMMENT = "Comment"
  
  G_KEY_FILE_DESKTOP_KEY_ICON = "Icon"
  
  G_KEY_FILE_DESKTOP_KEY_HIDDEN = "Hidden"
  
  G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = "OnlyShowIn"
  
  G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = "NotShowIn"
  
  G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = "TryExec"
  
  G_KEY_FILE_DESKTOP_KEY_EXEC = "Exec"
  
  G_KEY_FILE_DESKTOP_KEY_PATH = "Path"
  
  G_KEY_FILE_DESKTOP_KEY_TERMINAL = "Terminal"
  
  G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = "MimeType"
  
  G_KEY_FILE_DESKTOP_KEY_CATEGORIES = "Categories"
  
  G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = "StartupNotify"
  
  G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = "StartupWMClass"
  
  G_KEY_FILE_DESKTOP_KEY_URL = "URL"
  
  G_KEY_FILE_DESKTOP_TYPE_APPLICATION = "Application"
  
  G_KEY_FILE_DESKTOP_TYPE_LINK = "Link"
  
  G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = "Directory"
  
  G_OPTION_REMAINING = ""
  
  G_CSET_A_2_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  
  G_CSET_a_2_z = "abcdefghijklmnopqrstuvwxyz"
  
  G_CSET_DIGITS = "0123456789"
  
  G_CSET_LATINC = "\300\301\302\303\304\305\306""\307\310\311\312\313\314\315\316\317\320""\321\322\323\324\325\326""\330\331\332\333\334\335\336"
  
  G_CSET_LATINS = "\337\340\341\342\343\344\345\346""\347\350\351\352\353\354\355\356\357\360""\361\362\363\364\365\366""\370\371\372\373\374\375\376\377"
  
  G_STR_DELIMITERS = "_-|> <."
  
  G_USEC_PER_SEC = 1000000
  
  G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@"
  
  G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;="
  
  MAXPATHLEN = 1024
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_compare_func_(a, b)
  # @param [FFI::Pointer(Gconstpointer)] a 
  # @param [FFI::Pointer(Gconstpointer)] b 
  # @return [Integer] 
  # @scope class
  callback :g_compare_func, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_compare_data_func_(a, b, user_data)
  # @param [FFI::Pointer(Gconstpointer)] a 
  # @param [FFI::Pointer(Gconstpointer)] b 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :g_compare_data_func, [:pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_equal_func_(a, b)
  # @param [FFI::Pointer(Gconstpointer)] a 
  # @param [FFI::Pointer(Gconstpointer)] b 
  # @return [Integer] 
  # @scope class
  callback :g_equal_func, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_func_(user_data)
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_func, [:pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hash_func_(key)
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  callback :g_hash_func, [:pointer], :uint
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_gh_func_(value, user_data)
  # @param [FFI::Pointer(Gpointer)] value 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :gh_func, [:pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_translate_func_(str, data)
  # @param [String] str 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_translate_func, [:string, :pointer], :char
  
  # (Not documented)
  # 
  # = Fields:
  # :mantissa ::
  #   (Integer) 
  # :biased_exponent ::
  #   (Integer) 
  # :sign ::
  #   (Integer) 
  class GFloatIEEE754Mpn < FFI::Struct
    layout :mantissa, :uint,
           :biased_exponent, :uint,
           :sign, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :v_float ::
  #   (Float) 
  # :mpn ::
  #   (GFloatIEEE754Mpn) 
  class GFloatIEEE754 < FFI::Union
    layout :v_float, :float,
           :mpn, GFloatIEEE754Mpn.by_value
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :mantissa_low ::
  #   (Integer) 
  # :mantissa_high ::
  #   (Integer) 
  # :biased_exponent ::
  #   (Integer) 
  # :sign ::
  #   (Integer) 
  class GDoubleIEEE754Mpn < FFI::Struct
    layout :mantissa_low, :uint,
           :mantissa_high, :uint,
           :biased_exponent, :uint,
           :sign, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :v_double ::
  #   (Float) 
  # :mpn ::
  #   (GDoubleIEEE754Mpn) 
  class GDoubleIEEE754 < FFI::Union
    layout :v_double, :double,
           :mpn, GDoubleIEEE754Mpn.by_value
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :tv_sec ::
  #   (Integer) 
  # :tv_usec ::
  #   (Integer) 
  module GTimeValWrappers
    # @param [Integer] microseconds 
    # @return [nil] 
    def add(microseconds)
      Glib.g_time_val_add(self, microseconds)
    end
    
    # @return [String] 
    def to_iso8601()
      Glib.g_time_val_to_iso8601(self)
    end
  end
  
  class GTimeVal < FFI::Struct
    include GTimeValWrappers
    layout :tv_sec, :long,
           :tv_usec, :long
  end
  
  # (Not documented)
  module GBytesWrappers
    # @param [Integer] offset 
    # @param [Integer] length 
    # @return [GBytes] 
    def new_from_bytes(offset, length)
      GBytes.new Glib.g_bytes_new_from_bytes(self, offset, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] size 
    # @return [FFI::Pointer(Gconstpointer)] 
    def get_data(size)
      Glib.g_bytes_get_data(self, size)
    end
    
    # @return [Integer] 
    def get_size()
      Glib.g_bytes_get_size(self)
    end
    
    # @return [GBytes] 
    def ref()
      GBytes.new Glib.g_bytes_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_bytes_unref(self)
    end
    
    # @param [FFI::Pointer(*Gsize)] size 
    # @return [FFI::Pointer(Gpointer)] 
    def unref_to_data(size)
      Glib.g_bytes_unref_to_data(self, size)
    end
    
    # @return [GByteArray] 
    def unref_to_array()
      GByteArray.new Glib.g_bytes_unref_to_array(self)
    end
  end
  
  class GBytes < FFI::Struct
    include GBytesWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (String) 
  # :len ::
  #   (Integer) 
  module GArrayWrappers
    # @param [Integer] free_segment 
    # @return [String] 
    def free(free_segment)
      Glib.g_array_free(self, free_segment)
    end
    
    # @return [GArray] 
    def ref()
      GArray.new Glib.g_array_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_array_unref(self)
    end
    
    # @return [Integer] 
    def get_element_size()
      Glib.g_array_get_element_size(self)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Integer] len 
    # @return [GArray] 
    def append_vals(data, len)
      GArray.new Glib.g_array_append_vals(self, data, len)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Integer] len 
    # @return [GArray] 
    def prepend_vals(data, len)
      GArray.new Glib.g_array_prepend_vals(self, data, len)
    end
    
    # @param [Integer] index 
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Integer] len 
    # @return [GArray] 
    def insert_vals(index, data, len)
      GArray.new Glib.g_array_insert_vals(self, index, data, len)
    end
    
    # @param [Integer] length 
    # @return [GArray] 
    def set_size(length)
      GArray.new Glib.g_array_set_size(self, length)
    end
    
    # @param [Integer] index 
    # @return [GArray] 
    def remove_index(index)
      GArray.new Glib.g_array_remove_index(self, index)
    end
    
    # @param [Integer] index 
    # @return [GArray] 
    def remove_index_fast(index)
      GArray.new Glib.g_array_remove_index_fast(self, index)
    end
    
    # @param [Integer] index 
    # @param [Integer] length 
    # @return [GArray] 
    def remove_range(index, length)
      GArray.new Glib.g_array_remove_range(self, index, length)
    end
    
    # @param [Proc(_callback_g_compare_func_)] compare_func 
    # @return [nil] 
    def sort(compare_func)
      Glib.g_array_sort(self, compare_func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort_with_data(compare_func, user_data)
      Glib.g_array_sort_with_data(self, compare_func, user_data)
    end
    
    # @param [FFI::Pointer(GDestroyNotify)] clear_func 
    # @return [nil] 
    def set_clear_func(clear_func)
      Glib.g_array_set_clear_func(self, clear_func)
    end
  end
  
  class GArray < FFI::Struct
    include GArrayWrappers
    layout :data, :string,
           :len, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Guint8)) 
  # :len ::
  #   (Integer) 
  module GByteArrayWrappers
    # @param [Integer] free_segment 
    # @return [FFI::Pointer(*Guint8)] 
    def free(free_segment)
      Glib.g_byte_array_free(self, free_segment)
    end
    
    # @return [GBytes] 
    def free_to_bytes()
      GBytes.new Glib.g_byte_array_free_to_bytes(self)
    end
    
    # @return [GByteArray] 
    def ref()
      GByteArray.new Glib.g_byte_array_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_byte_array_unref(self)
    end
    
    # @param [FFI::Pointer(*Guint8)] data 
    # @param [Integer] len 
    # @return [GByteArray] 
    def append(data, len)
      GByteArray.new Glib.g_byte_array_append(self, data, len)
    end
    
    # @param [FFI::Pointer(*Guint8)] data 
    # @param [Integer] len 
    # @return [GByteArray] 
    def prepend(data, len)
      GByteArray.new Glib.g_byte_array_prepend(self, data, len)
    end
    
    # @param [Integer] length 
    # @return [GByteArray] 
    def set_size(length)
      GByteArray.new Glib.g_byte_array_set_size(self, length)
    end
    
    # @param [Integer] index 
    # @return [GByteArray] 
    def remove_index(index)
      GByteArray.new Glib.g_byte_array_remove_index(self, index)
    end
    
    # @param [Integer] index 
    # @return [GByteArray] 
    def remove_index_fast(index)
      GByteArray.new Glib.g_byte_array_remove_index_fast(self, index)
    end
    
    # @param [Integer] index 
    # @param [Integer] length 
    # @return [GByteArray] 
    def remove_range(index, length)
      GByteArray.new Glib.g_byte_array_remove_range(self, index, length)
    end
    
    # @param [Proc(_callback_g_compare_func_)] compare_func 
    # @return [nil] 
    def sort(compare_func)
      Glib.g_byte_array_sort(self, compare_func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort_with_data(compare_func, user_data)
      Glib.g_byte_array_sort_with_data(self, compare_func, user_data)
    end
  end
  
  class GByteArray < FFI::Struct
    include GByteArrayWrappers
    layout :data, :pointer,
           :len, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :pdata ::
  #   (FFI::Pointer(*Gpointer)) 
  # :len ::
  #   (Integer) 
  module GPtrArrayWrappers
    # @param [Integer] free_seg 
    # @return [FFI::Pointer(*Gpointer)] 
    def free(free_seg)
      Glib.g_ptr_array_free(self, free_seg)
    end
    
    # @return [GPtrArray] 
    def ref()
      GPtrArray.new Glib.g_ptr_array_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_ptr_array_unref(self)
    end
    
    # @param [FFI::Pointer(GDestroyNotify)] element_free_func 
    # @return [nil] 
    def set_free_func(element_free_func)
      Glib.g_ptr_array_set_free_func(self, element_free_func)
    end
    
    # @param [Integer] length 
    # @return [nil] 
    def set_size(length)
      Glib.g_ptr_array_set_size(self, length)
    end
    
    # @param [Integer] index 
    # @return [FFI::Pointer(Gpointer)] 
    def remove_index(index)
      Glib.g_ptr_array_remove_index(self, index)
    end
    
    # @param [Integer] index 
    # @return [FFI::Pointer(Gpointer)] 
    def remove_index_fast(index)
      Glib.g_ptr_array_remove_index_fast(self, index)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [Integer] 
    def remove(data)
      Glib.g_ptr_array_remove(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [Integer] 
    def remove_fast(data)
      Glib.g_ptr_array_remove_fast(self, data)
    end
    
    # @param [Integer] index 
    # @param [Integer] length 
    # @return [nil] 
    def remove_range(index, length)
      Glib.g_ptr_array_remove_range(self, index, length)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def add(data)
      Glib.g_ptr_array_add(self, data)
    end
    
    # @param [Proc(_callback_g_compare_func_)] compare_func 
    # @return [nil] 
    def sort(compare_func)
      Glib.g_ptr_array_sort(self, compare_func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort_with_data(compare_func, user_data)
      Glib.g_ptr_array_sort_with_data(self, compare_func, user_data)
    end
    
    # @param [Proc(_callback_g_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_ptr_array_foreach(self, func, user_data)
    end
  end
  
  class GPtrArray < FFI::Struct
    include GPtrArrayWrappers
    layout :pdata, :pointer,
           :len, :uint
  end
  
  # (Not documented)
  # 
  # @method g_array_new(zero_terminated, clear, element_size)
  # @param [Integer] zero_terminated 
  # @param [Integer] clear 
  # @param [Integer] element_size 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_new, :g_array_new, [:int, :int, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_sized_new(zero_terminated, clear, element_size, reserved_size)
  # @param [Integer] zero_terminated 
  # @param [Integer] clear 
  # @param [Integer] element_size 
  # @param [Integer] reserved_size 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_sized_new, :g_array_sized_new, [:int, :int, :uint, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_free(array, free_segment)
  # @param [GArray] array 
  # @param [Integer] free_segment 
  # @return [String] 
  # @scope class
  attach_function :g_array_free, :g_array_free, [GArray, :int], :string
  
  # (Not documented)
  # 
  # @method g_array_ref(array)
  # @param [GArray] array 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_ref, :g_array_ref, [GArray], GArray
  
  # (Not documented)
  # 
  # @method g_array_unref(array)
  # @param [GArray] array 
  # @return [nil] 
  # @scope class
  attach_function :g_array_unref, :g_array_unref, [GArray], :void
  
  # (Not documented)
  # 
  # @method g_array_get_element_size(array)
  # @param [GArray] array 
  # @return [Integer] 
  # @scope class
  attach_function :g_array_get_element_size, :g_array_get_element_size, [GArray], :uint
  
  # (Not documented)
  # 
  # @method g_array_append_vals(array, data, len)
  # @param [GArray] array 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] len 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_append_vals, :g_array_append_vals, [GArray, :pointer, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_prepend_vals(array, data, len)
  # @param [GArray] array 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] len 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_prepend_vals, :g_array_prepend_vals, [GArray, :pointer, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_insert_vals(array, index, data, len)
  # @param [GArray] array 
  # @param [Integer] index 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] len 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_insert_vals, :g_array_insert_vals, [GArray, :uint, :pointer, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_set_size(array, length)
  # @param [GArray] array 
  # @param [Integer] length 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_set_size, :g_array_set_size, [GArray, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_remove_index(array, index)
  # @param [GArray] array 
  # @param [Integer] index 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_remove_index, :g_array_remove_index, [GArray, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_remove_index_fast(array, index)
  # @param [GArray] array 
  # @param [Integer] index 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_remove_index_fast, :g_array_remove_index_fast, [GArray, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_remove_range(array, index, length)
  # @param [GArray] array 
  # @param [Integer] index 
  # @param [Integer] length 
  # @return [GArray] 
  # @scope class
  attach_function :g_array_remove_range, :g_array_remove_range, [GArray, :uint, :uint], GArray
  
  # (Not documented)
  # 
  # @method g_array_sort(array, compare_func)
  # @param [GArray] array 
  # @param [Proc(_callback_g_compare_func_)] compare_func 
  # @return [nil] 
  # @scope class
  attach_function :g_array_sort, :g_array_sort, [GArray, :g_compare_func], :void
  
  # (Not documented)
  # 
  # @method g_array_sort_with_data(array, compare_func, user_data)
  # @param [GArray] array 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_array_sort_with_data, :g_array_sort_with_data, [GArray, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_array_set_clear_func(array, clear_func)
  # @param [GArray] array 
  # @param [FFI::Pointer(GDestroyNotify)] clear_func 
  # @return [nil] 
  # @scope class
  attach_function :g_array_set_clear_func, :g_array_set_clear_func, [GArray, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_new()
  # @return [GPtrArray] 
  # @scope class
  attach_function :g_ptr_array_new, :g_ptr_array_new, [], GPtrArray
  
  # (Not documented)
  # 
  # @method g_ptr_array_new_with_free_func(element_free_func)
  # @param [FFI::Pointer(GDestroyNotify)] element_free_func 
  # @return [GPtrArray] 
  # @scope class
  attach_function :g_ptr_array_new_with_free_func, :g_ptr_array_new_with_free_func, [:pointer], GPtrArray
  
  # (Not documented)
  # 
  # @method g_ptr_array_sized_new(reserved_size)
  # @param [Integer] reserved_size 
  # @return [GPtrArray] 
  # @scope class
  attach_function :g_ptr_array_sized_new, :g_ptr_array_sized_new, [:uint], GPtrArray
  
  # (Not documented)
  # 
  # @method g_ptr_array_new_full(reserved_size, element_free_func)
  # @param [Integer] reserved_size 
  # @param [FFI::Pointer(GDestroyNotify)] element_free_func 
  # @return [GPtrArray] 
  # @scope class
  attach_function :g_ptr_array_new_full, :g_ptr_array_new_full, [:uint, :pointer], GPtrArray
  
  # (Not documented)
  # 
  # @method g_ptr_array_free(array, free_seg)
  # @param [GPtrArray] array 
  # @param [Integer] free_seg 
  # @return [FFI::Pointer(*Gpointer)] 
  # @scope class
  attach_function :g_ptr_array_free, :g_ptr_array_free, [GPtrArray, :int], :pointer
  
  # (Not documented)
  # 
  # @method g_ptr_array_ref(array)
  # @param [GPtrArray] array 
  # @return [GPtrArray] 
  # @scope class
  attach_function :g_ptr_array_ref, :g_ptr_array_ref, [GPtrArray], GPtrArray
  
  # (Not documented)
  # 
  # @method g_ptr_array_unref(array)
  # @param [GPtrArray] array 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_unref, :g_ptr_array_unref, [GPtrArray], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_set_free_func(array, element_free_func)
  # @param [GPtrArray] array 
  # @param [FFI::Pointer(GDestroyNotify)] element_free_func 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_set_free_func, :g_ptr_array_set_free_func, [GPtrArray, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_set_size(array, length)
  # @param [GPtrArray] array 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_set_size, :g_ptr_array_set_size, [GPtrArray, :int], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_remove_index(array, index)
  # @param [GPtrArray] array 
  # @param [Integer] index 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_ptr_array_remove_index, :g_ptr_array_remove_index, [GPtrArray, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_ptr_array_remove_index_fast(array, index)
  # @param [GPtrArray] array 
  # @param [Integer] index 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_ptr_array_remove_index_fast, :g_ptr_array_remove_index_fast, [GPtrArray, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_ptr_array_remove(array, data)
  # @param [GPtrArray] array 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_ptr_array_remove, :g_ptr_array_remove, [GPtrArray, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_ptr_array_remove_fast(array, data)
  # @param [GPtrArray] array 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_ptr_array_remove_fast, :g_ptr_array_remove_fast, [GPtrArray, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_ptr_array_remove_range(array, index, length)
  # @param [GPtrArray] array 
  # @param [Integer] index 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_remove_range, :g_ptr_array_remove_range, [GPtrArray, :uint, :uint], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_add(array, data)
  # @param [GPtrArray] array 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_add, :g_ptr_array_add, [GPtrArray, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_sort(array, compare_func)
  # @param [GPtrArray] array 
  # @param [Proc(_callback_g_compare_func_)] compare_func 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_sort, :g_ptr_array_sort, [GPtrArray, :g_compare_func], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_sort_with_data(array, compare_func, user_data)
  # @param [GPtrArray] array 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_sort_with_data, :g_ptr_array_sort_with_data, [GPtrArray, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_ptr_array_foreach(array, func, user_data)
  # @param [GPtrArray] array 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_ptr_array_foreach, :g_ptr_array_foreach, [GPtrArray, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_byte_array_new()
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_new, :g_byte_array_new, [], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_new_take(data, len)
  # @param [FFI::Pointer(*Guint8)] data 
  # @param [Integer] len 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_new_take, :g_byte_array_new_take, [:pointer, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_sized_new(reserved_size)
  # @param [Integer] reserved_size 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_sized_new, :g_byte_array_sized_new, [:uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_free(array, free_segment)
  # @param [GByteArray] array 
  # @param [Integer] free_segment 
  # @return [FFI::Pointer(*Guint8)] 
  # @scope class
  attach_function :g_byte_array_free, :g_byte_array_free, [GByteArray, :int], :pointer
  
  # (Not documented)
  # 
  # @method g_byte_array_free_to_bytes(array)
  # @param [GByteArray] array 
  # @return [GBytes] 
  # @scope class
  attach_function :g_byte_array_free_to_bytes, :g_byte_array_free_to_bytes, [GByteArray], GBytes
  
  # (Not documented)
  # 
  # @method g_byte_array_ref(array)
  # @param [GByteArray] array 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_ref, :g_byte_array_ref, [GByteArray], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_unref(array)
  # @param [GByteArray] array 
  # @return [nil] 
  # @scope class
  attach_function :g_byte_array_unref, :g_byte_array_unref, [GByteArray], :void
  
  # (Not documented)
  # 
  # @method g_byte_array_append(array, data, len)
  # @param [GByteArray] array 
  # @param [FFI::Pointer(*Guint8)] data 
  # @param [Integer] len 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_append, :g_byte_array_append, [GByteArray, :pointer, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_prepend(array, data, len)
  # @param [GByteArray] array 
  # @param [FFI::Pointer(*Guint8)] data 
  # @param [Integer] len 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_prepend, :g_byte_array_prepend, [GByteArray, :pointer, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_set_size(array, length)
  # @param [GByteArray] array 
  # @param [Integer] length 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_set_size, :g_byte_array_set_size, [GByteArray, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_remove_index(array, index)
  # @param [GByteArray] array 
  # @param [Integer] index 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_remove_index, :g_byte_array_remove_index, [GByteArray, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_remove_index_fast(array, index)
  # @param [GByteArray] array 
  # @param [Integer] index 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_remove_index_fast, :g_byte_array_remove_index_fast, [GByteArray, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_remove_range(array, index, length)
  # @param [GByteArray] array 
  # @param [Integer] index 
  # @param [Integer] length 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_byte_array_remove_range, :g_byte_array_remove_range, [GByteArray, :uint, :uint], GByteArray
  
  # (Not documented)
  # 
  # @method g_byte_array_sort(array, compare_func)
  # @param [GByteArray] array 
  # @param [Proc(_callback_g_compare_func_)] compare_func 
  # @return [nil] 
  # @scope class
  attach_function :g_byte_array_sort, :g_byte_array_sort, [GByteArray, :g_compare_func], :void
  
  # (Not documented)
  # 
  # @method g_byte_array_sort_with_data(array, compare_func, user_data)
  # @param [GByteArray] array 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_byte_array_sort_with_data, :g_byte_array_sort_with_data, [GByteArray, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_atomic_int_get(atomic)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_get, :g_atomic_int_get, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_atomic_int_set(atomic, newval)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @param [Integer] newval 
  # @return [nil] 
  # @scope class
  attach_function :g_atomic_int_set, :g_atomic_int_set, [:pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_atomic_int_inc(atomic)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @return [nil] 
  # @scope class
  attach_function :g_atomic_int_inc, :g_atomic_int_inc, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_atomic_int_dec_and_test(atomic)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_dec_and_test, :g_atomic_int_dec_and_test, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_atomic_int_compare_and_exchange(atomic, oldval, newval)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @param [Integer] oldval 
  # @param [Integer] newval 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_compare_and_exchange, :g_atomic_int_compare_and_exchange, [:pointer, :int, :int], :int
  
  # (Not documented)
  # 
  # @method g_atomic_int_add(atomic, val)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_add, :g_atomic_int_add, [:pointer, :int], :int
  
  # (Not documented)
  # 
  # @method g_atomic_int_and(atomic, val)
  # @param [FFI::Pointer(*Guint)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_and, :g_atomic_int_and, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_int_or(atomic, val)
  # @param [FFI::Pointer(*Guint)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_or, :g_atomic_int_or, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_int_xor(atomic, val)
  # @param [FFI::Pointer(*Guint)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_xor, :g_atomic_int_xor, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_get(atomic)
  # @param [FFI::Pointer(*Void)] atomic 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_atomic_pointer_get, :g_atomic_pointer_get, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_set(atomic, newval)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [FFI::Pointer(Gpointer)] newval 
  # @return [nil] 
  # @scope class
  attach_function :g_atomic_pointer_set, :g_atomic_pointer_set, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_compare_and_exchange(atomic, oldval, newval)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [FFI::Pointer(Gpointer)] oldval 
  # @param [FFI::Pointer(Gpointer)] newval 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_pointer_compare_and_exchange, :g_atomic_pointer_compare_and_exchange, [:pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_add(atomic, val)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_pointer_add, :g_atomic_pointer_add, [:pointer, :int], :int
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_and(atomic, val)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_pointer_and, :g_atomic_pointer_and, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_or(atomic, val)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_pointer_or, :g_atomic_pointer_or, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_pointer_xor(atomic, val)
  # @param [FFI::Pointer(*Void)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_pointer_xor, :g_atomic_pointer_xor, [:pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_atomic_int_exchange_and_add(atomic, val)
  # @param [FFI::Pointer(*Gint)] atomic 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :g_atomic_int_exchange_and_add, :g_atomic_int_exchange_and_add, [:pointer, :int], :int
  
  # (Not documented)
  # 
  # @method g_quark_try_string(string)
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_quark_try_string, :g_quark_try_string, [:string], :uint
  
  # (Not documented)
  # 
  # @method g_quark_from_static_string(string)
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_quark_from_static_string, :g_quark_from_static_string, [:string], :uint
  
  # (Not documented)
  # 
  # @method g_quark_from_string(string)
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_quark_from_string, :g_quark_from_string, [:string], :uint
  
  # (Not documented)
  # 
  # @method g_quark_to_string(quark)
  # @param [Integer] quark 
  # @return [String] 
  # @scope class
  attach_function :g_quark_to_string, :g_quark_to_string, [:uint], :string
  
  # (Not documented)
  # 
  # @method g_intern_string(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_intern_string, :g_intern_string, [:string], :string
  
  # (Not documented)
  # 
  # @method g_intern_static_string(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_intern_static_string, :g_intern_static_string, [:string], :string
  
  # (Not documented)
  # 
  # = Fields:
  # :domain ::
  #   (Integer) 
  # :code ::
  #   (Integer) 
  # :message ::
  #   (String) 
  module GErrorWrappers
    # @return [nil] 
    def free()
      Glib.g_error_free(self)
    end
    
    # @return [GError] 
    def copy()
      GError.new Glib.g_error_copy(self)
    end
    
    # @param [Integer] domain 
    # @param [Integer] code 
    # @return [Integer] 
    def matches(domain, code)
      Glib.g_error_matches(self, domain, code)
    end
  end
  
  class GError < FFI::Struct
    include GErrorWrappers
    layout :domain, :uint,
           :code, :int,
           :message, :string
  end
  
  # (Not documented)
  # 
  # @method g_error_new(domain, code, format)
  # @param [Integer] domain 
  # @param [Integer] code 
  # @param [String] format 
  # @return [GError] 
  # @scope class
  attach_function :g_error_new, :g_error_new, [:uint, :int, :string], GError
  
  # (Not documented)
  # 
  # @method g_error_new_literal(domain, code, message)
  # @param [Integer] domain 
  # @param [Integer] code 
  # @param [String] message 
  # @return [GError] 
  # @scope class
  attach_function :g_error_new_literal, :g_error_new_literal, [:uint, :int, :string], GError
  
  # (Not documented)
  # 
  # @method g_error_new_valist(domain, code, format, args)
  # @param [Integer] domain 
  # @param [Integer] code 
  # @param [String] format 
  # @param [String] args 
  # @return [GError] 
  # @scope class
  attach_function :g_error_new_valist, :g_error_new_valist, [:uint, :int, :string, :string], GError
  
  # (Not documented)
  # 
  # @method g_error_free(error)
  # @param [GError] error 
  # @return [nil] 
  # @scope class
  attach_function :g_error_free, :g_error_free, [GError], :void
  
  # (Not documented)
  # 
  # @method g_error_copy(error)
  # @param [GError] error 
  # @return [GError] 
  # @scope class
  attach_function :g_error_copy, :g_error_copy, [GError], GError
  
  # (Not documented)
  # 
  # @method g_error_matches(error, domain, code)
  # @param [GError] error 
  # @param [Integer] domain 
  # @param [Integer] code 
  # @return [Integer] 
  # @scope class
  attach_function :g_error_matches, :g_error_matches, [GError, :uint, :int], :int
  
  # (Not documented)
  # 
  # @method g_set_error(err, domain, code, format)
  # @param [FFI::Pointer(**GError)] err 
  # @param [Integer] domain 
  # @param [Integer] code 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_set_error, :g_set_error, [:pointer, :uint, :int, :string], :void
  
  # (Not documented)
  # 
  # @method g_set_error_literal(err, domain, code, message)
  # @param [FFI::Pointer(**GError)] err 
  # @param [Integer] domain 
  # @param [Integer] code 
  # @param [String] message 
  # @return [nil] 
  # @scope class
  attach_function :g_set_error_literal, :g_set_error_literal, [:pointer, :uint, :int, :string], :void
  
  # (Not documented)
  # 
  # @method g_propagate_error(dest, src)
  # @param [FFI::Pointer(**GError)] dest 
  # @param [GError] src 
  # @return [nil] 
  # @scope class
  attach_function :g_propagate_error, :g_propagate_error, [:pointer, GError], :void
  
  # (Not documented)
  # 
  # @method g_clear_error(err)
  # @param [FFI::Pointer(**GError)] err 
  # @return [nil] 
  # @scope class
  attach_function :g_clear_error, :g_clear_error, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_prefix_error(err, format)
  # @param [FFI::Pointer(**GError)] err 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_prefix_error, :g_prefix_error, [:pointer, :string], :void
  
  # (Not documented)
  # 
  # @method g_propagate_prefixed_error(dest, src, format)
  # @param [FFI::Pointer(**GError)] dest 
  # @param [GError] src 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_propagate_prefixed_error, :g_propagate_prefixed_error, [:pointer, GError, :string], :void
  
  # (Not documented)
  # 
  # @method g_thread_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_error_quark, :g_thread_error_quark, [], :uint
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_thread_error).</em>
  # 
  # === Options:
  # :g_thread_error_again ::
  #   
  # 
  # @method _enum_g_thread_error_
  # @return [Symbol]
  # @scope class
  enum :g_thread_error, [
    :g_thread_error_again, 0
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_thread_func_(data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_thread_func, [:pointer], :pointer
  
  # (Not documented)
  module GThreadWrappers
    # @return [GThread] 
    def ref()
      GThread.new Glib.g_thread_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_thread_unref(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def join()
      Glib.g_thread_join(self)
    end
  end
  
  class GThread < FFI::Struct
    include GThreadWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :p ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :i ::
  #   (Array<Integer>) 
  module GMutexWrappers
    # @return [nil] 
    def init()
      Glib.g_mutex_init(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_mutex_clear(self)
    end
    
    # @return [nil] 
    def lock()
      Glib.g_mutex_lock(self)
    end
    
    # @return [Integer] 
    def trylock()
      Glib.g_mutex_trylock(self)
    end
    
    # @return [nil] 
    def unlock()
      Glib.g_mutex_unlock(self)
    end
  end
  
  class GMutex < FFI::Union
    include GMutexWrappers
    layout :p, :pointer,
           :i, [:uint, 2]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :p ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :i ::
  #   (Array<Integer>) 
  module GRWLockWrappers
    # @return [nil] 
    def init()
      Glib.g_rw_lock_init(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_rw_lock_clear(self)
    end
    
    # @return [nil] 
    def writer_lock()
      Glib.g_rw_lock_writer_lock(self)
    end
    
    # @return [Integer] 
    def writer_trylock()
      Glib.g_rw_lock_writer_trylock(self)
    end
    
    # @return [nil] 
    def writer_unlock()
      Glib.g_rw_lock_writer_unlock(self)
    end
    
    # @return [nil] 
    def reader_lock()
      Glib.g_rw_lock_reader_lock(self)
    end
    
    # @return [Integer] 
    def reader_trylock()
      Glib.g_rw_lock_reader_trylock(self)
    end
    
    # @return [nil] 
    def reader_unlock()
      Glib.g_rw_lock_reader_unlock(self)
    end
  end
  
  class GRWLock < FFI::Struct
    include GRWLockWrappers
    layout :p, :pointer,
           :i, [:uint, 2]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :p ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :i ::
  #   (Array<Integer>) 
  module GCondWrappers
    # @return [nil] 
    def init()
      Glib.g_cond_init(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_cond_clear(self)
    end
    
    # @param [GMutex] mutex 
    # @return [nil] 
    def wait(mutex)
      Glib.g_cond_wait(self, mutex)
    end
    
    # @return [nil] 
    def signal()
      Glib.g_cond_signal(self)
    end
    
    # @return [nil] 
    def broadcast()
      Glib.g_cond_broadcast(self)
    end
    
    # @param [GMutex] mutex 
    # @param [Integer] end_time 
    # @return [Integer] 
    def wait_until(mutex, end_time)
      Glib.g_cond_wait_until(self, mutex, end_time)
    end
  end
  
  class GCond < FFI::Struct
    include GCondWrappers
    layout :p, :pointer,
           :i, [:uint, 2]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :p ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :i ::
  #   (Array<Integer>) 
  module GRecMutexWrappers
    # @return [nil] 
    def init()
      Glib.g_rec_mutex_init(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_rec_mutex_clear(self)
    end
    
    # @return [nil] 
    def lock()
      Glib.g_rec_mutex_lock(self)
    end
    
    # @return [Integer] 
    def trylock()
      Glib.g_rec_mutex_trylock(self)
    end
    
    # @return [nil] 
    def unlock()
      Glib.g_rec_mutex_unlock(self)
    end
  end
  
  class GRecMutex < FFI::Struct
    include GRecMutexWrappers
    layout :p, :pointer,
           :i, [:uint, 2]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :p ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :notify ::
  #   (FFI::Pointer(GDestroyNotify)) 
  # :future ::
  #   (Array<FFI::Pointer(*Void)>) 
  module GPrivateWrappers
    # @return [FFI::Pointer(Gpointer)] 
    def get()
      Glib.g_private_get(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def set(value)
      Glib.g_private_set(self, value)
    end
    
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def replace(value)
      Glib.g_private_replace(self, value)
    end
  end
  
  class GPrivate < FFI::Struct
    include GPrivateWrappers
    layout :p, :pointer,
           :notify, :pointer,
           :future, [:pointer, 2]
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_once_status).</em>
  # 
  # === Options:
  # :notcalled ::
  #   
  # :progress ::
  #   
  # :ready ::
  #   
  # 
  # @method _enum_g_once_status_
  # @return [Symbol]
  # @scope class
  enum :g_once_status, [
    :notcalled, 0,
    :progress, 1,
    :ready, 2
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :status ::
  #   (unknown) 
  # :retval ::
  #   (FFI::Pointer(Gpointer)) 
  module GOnceWrappers
    # @param [Proc(_callback_g_thread_func_)] func 
    # @param [FFI::Pointer(Gpointer)] arg 
    # @return [FFI::Pointer(Gpointer)] 
    def impl(func, arg)
      Glib.g_once_impl(self, func, arg)
    end
  end
  
  class GOnce < FFI::Struct
    include GOnceWrappers
    layout :status, :char,
           :retval, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_thread_ref(thread)
  # @param [GThread] thread 
  # @return [GThread] 
  # @scope class
  attach_function :g_thread_ref, :g_thread_ref, [GThread], GThread
  
  # (Not documented)
  # 
  # @method g_thread_unref(thread)
  # @param [GThread] thread 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_unref, :g_thread_unref, [GThread], :void
  
  # (Not documented)
  # 
  # @method g_thread_new(name, func, data)
  # @param [String] name 
  # @param [Proc(_callback_g_thread_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GThread] 
  # @scope class
  attach_function :g_thread_new, :g_thread_new, [:string, :g_thread_func, :pointer], GThread
  
  # (Not documented)
  # 
  # @method g_thread_try_new(name, func, data, error)
  # @param [String] name 
  # @param [Proc(_callback_g_thread_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GThread] 
  # @scope class
  attach_function :g_thread_try_new, :g_thread_try_new, [:string, :g_thread_func, :pointer, :pointer], GThread
  
  # (Not documented)
  # 
  # @method g_thread_self()
  # @return [GThread] 
  # @scope class
  attach_function :g_thread_self, :g_thread_self, [], GThread
  
  # (Not documented)
  # 
  # @method g_thread_exit(retval)
  # @param [FFI::Pointer(Gpointer)] retval 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_exit, :g_thread_exit, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_thread_join(thread)
  # @param [GThread] thread 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_thread_join, :g_thread_join, [GThread], :pointer
  
  # (Not documented)
  # 
  # @method g_thread_yield()
  # @return [nil] 
  # @scope class
  attach_function :g_thread_yield, :g_thread_yield, [], :void
  
  # (Not documented)
  # 
  # @method g_mutex_init(mutex)
  # @param [GMutex] mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_mutex_init, :g_mutex_init, [GMutex], :void
  
  # (Not documented)
  # 
  # @method g_mutex_clear(mutex)
  # @param [GMutex] mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_mutex_clear, :g_mutex_clear, [GMutex], :void
  
  # (Not documented)
  # 
  # @method g_mutex_lock(mutex)
  # @param [GMutex] mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_mutex_lock, :g_mutex_lock, [GMutex], :void
  
  # (Not documented)
  # 
  # @method g_mutex_trylock(mutex)
  # @param [GMutex] mutex 
  # @return [Integer] 
  # @scope class
  attach_function :g_mutex_trylock, :g_mutex_trylock, [GMutex], :int
  
  # (Not documented)
  # 
  # @method g_mutex_unlock(mutex)
  # @param [GMutex] mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_mutex_unlock, :g_mutex_unlock, [GMutex], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_init(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_init, :g_rw_lock_init, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_clear(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_clear, :g_rw_lock_clear, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_writer_lock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_writer_lock, :g_rw_lock_writer_lock, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_writer_trylock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [Integer] 
  # @scope class
  attach_function :g_rw_lock_writer_trylock, :g_rw_lock_writer_trylock, [GRWLock], :int
  
  # (Not documented)
  # 
  # @method g_rw_lock_writer_unlock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_writer_unlock, :g_rw_lock_writer_unlock, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_reader_lock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_reader_lock, :g_rw_lock_reader_lock, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rw_lock_reader_trylock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [Integer] 
  # @scope class
  attach_function :g_rw_lock_reader_trylock, :g_rw_lock_reader_trylock, [GRWLock], :int
  
  # (Not documented)
  # 
  # @method g_rw_lock_reader_unlock(rw_lock)
  # @param [GRWLock] rw_lock 
  # @return [nil] 
  # @scope class
  attach_function :g_rw_lock_reader_unlock, :g_rw_lock_reader_unlock, [GRWLock], :void
  
  # (Not documented)
  # 
  # @method g_rec_mutex_init(rec_mutex)
  # @param [GRecMutex] rec_mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_rec_mutex_init, :g_rec_mutex_init, [GRecMutex], :void
  
  # (Not documented)
  # 
  # @method g_rec_mutex_clear(rec_mutex)
  # @param [GRecMutex] rec_mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_rec_mutex_clear, :g_rec_mutex_clear, [GRecMutex], :void
  
  # (Not documented)
  # 
  # @method g_rec_mutex_lock(rec_mutex)
  # @param [GRecMutex] rec_mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_rec_mutex_lock, :g_rec_mutex_lock, [GRecMutex], :void
  
  # (Not documented)
  # 
  # @method g_rec_mutex_trylock(rec_mutex)
  # @param [GRecMutex] rec_mutex 
  # @return [Integer] 
  # @scope class
  attach_function :g_rec_mutex_trylock, :g_rec_mutex_trylock, [GRecMutex], :int
  
  # (Not documented)
  # 
  # @method g_rec_mutex_unlock(rec_mutex)
  # @param [GRecMutex] rec_mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_rec_mutex_unlock, :g_rec_mutex_unlock, [GRecMutex], :void
  
  # (Not documented)
  # 
  # @method g_cond_init(cond)
  # @param [GCond] cond 
  # @return [nil] 
  # @scope class
  attach_function :g_cond_init, :g_cond_init, [GCond], :void
  
  # (Not documented)
  # 
  # @method g_cond_clear(cond)
  # @param [GCond] cond 
  # @return [nil] 
  # @scope class
  attach_function :g_cond_clear, :g_cond_clear, [GCond], :void
  
  # (Not documented)
  # 
  # @method g_cond_wait(cond, mutex)
  # @param [GCond] cond 
  # @param [GMutex] mutex 
  # @return [nil] 
  # @scope class
  attach_function :g_cond_wait, :g_cond_wait, [GCond, GMutex], :void
  
  # (Not documented)
  # 
  # @method g_cond_signal(cond)
  # @param [GCond] cond 
  # @return [nil] 
  # @scope class
  attach_function :g_cond_signal, :g_cond_signal, [GCond], :void
  
  # (Not documented)
  # 
  # @method g_cond_broadcast(cond)
  # @param [GCond] cond 
  # @return [nil] 
  # @scope class
  attach_function :g_cond_broadcast, :g_cond_broadcast, [GCond], :void
  
  # (Not documented)
  # 
  # @method g_cond_wait_until(cond, mutex, end_time)
  # @param [GCond] cond 
  # @param [GMutex] mutex 
  # @param [Integer] end_time 
  # @return [Integer] 
  # @scope class
  attach_function :g_cond_wait_until, :g_cond_wait_until, [GCond, GMutex, :long_long], :int
  
  # (Not documented)
  # 
  # @method g_private_get(key)
  # @param [GPrivate] key 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_private_get, :g_private_get, [GPrivate], :pointer
  
  # (Not documented)
  # 
  # @method g_private_set(key, value)
  # @param [GPrivate] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_private_set, :g_private_set, [GPrivate, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_private_replace(key, value)
  # @param [GPrivate] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_private_replace, :g_private_replace, [GPrivate, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_once_impl(once, func, arg)
  # @param [GOnce] once 
  # @param [Proc(_callback_g_thread_func_)] func 
  # @param [FFI::Pointer(Gpointer)] arg 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_once_impl, :g_once_impl, [GOnce, :g_thread_func, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_once_init_enter(location)
  # @param [FFI::Pointer(*Void)] location 
  # @return [Integer] 
  # @scope class
  attach_function :g_once_init_enter, :g_once_init_enter, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_once_init_leave(location, result)
  # @param [FFI::Pointer(*Void)] location 
  # @param [Integer] result 
  # @return [nil] 
  # @scope class
  attach_function :g_once_init_leave, :g_once_init_leave, [:pointer, :uint], :void
  
  # (Not documented)
  module GAsyncQueueWrappers
    # @return [nil] 
    def lock()
      Glib.g_async_queue_lock(self)
    end
    
    # @return [nil] 
    def unlock()
      Glib.g_async_queue_unlock(self)
    end
    
    # @return [GAsyncQueue] 
    def ref()
      GAsyncQueue.new Glib.g_async_queue_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_async_queue_unref(self)
    end
    
    # @return [nil] 
    def ref_unlocked()
      Glib.g_async_queue_ref_unlocked(self)
    end
    
    # @return [nil] 
    def unref_and_unlock()
      Glib.g_async_queue_unref_and_unlock(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def push(data)
      Glib.g_async_queue_push(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def push_unlocked(data)
      Glib.g_async_queue_push_unlocked(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def push_sorted(data, func, user_data)
      Glib.g_async_queue_push_sorted(self, data, func, user_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def push_sorted_unlocked(data, func, user_data)
      Glib.g_async_queue_push_sorted_unlocked(self, data, func, user_data)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def pop()
      Glib.g_async_queue_pop(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def pop_unlocked()
      Glib.g_async_queue_pop_unlocked(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def try_pop()
      Glib.g_async_queue_try_pop(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def try_pop_unlocked()
      Glib.g_async_queue_try_pop_unlocked(self)
    end
    
    # @param [Integer] timeout 
    # @return [FFI::Pointer(Gpointer)] 
    def timeout_pop(timeout)
      Glib.g_async_queue_timeout_pop(self, timeout)
    end
    
    # @param [Integer] timeout 
    # @return [FFI::Pointer(Gpointer)] 
    def timeout_pop_unlocked(timeout)
      Glib.g_async_queue_timeout_pop_unlocked(self, timeout)
    end
    
    # @return [Integer] 
    def length()
      Glib.g_async_queue_length(self)
    end
    
    # @return [Integer] 
    def length_unlocked()
      Glib.g_async_queue_length_unlocked(self)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort(func, user_data)
      Glib.g_async_queue_sort(self, func, user_data)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort_unlocked(func, user_data)
      Glib.g_async_queue_sort_unlocked(self, func, user_data)
    end
    
    # @param [GTimeVal] end_time 
    # @return [FFI::Pointer(Gpointer)] 
    def timed_pop(end_time)
      Glib.g_async_queue_timed_pop(self, end_time)
    end
    
    # @param [GTimeVal] end_time 
    # @return [FFI::Pointer(Gpointer)] 
    def timed_pop_unlocked(end_time)
      Glib.g_async_queue_timed_pop_unlocked(self, end_time)
    end
  end
  
  class GAsyncQueue < FFI::Struct
    include GAsyncQueueWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_async_queue_new()
  # @return [GAsyncQueue] 
  # @scope class
  attach_function :g_async_queue_new, :g_async_queue_new, [], GAsyncQueue
  
  # (Not documented)
  # 
  # @method g_async_queue_new_full(item_free_func)
  # @param [FFI::Pointer(GDestroyNotify)] item_free_func 
  # @return [GAsyncQueue] 
  # @scope class
  attach_function :g_async_queue_new_full, :g_async_queue_new_full, [:pointer], GAsyncQueue
  
  # (Not documented)
  # 
  # @method g_async_queue_lock(queue)
  # @param [GAsyncQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_lock, :g_async_queue_lock, [GAsyncQueue], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_unlock(queue)
  # @param [GAsyncQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_unlock, :g_async_queue_unlock, [GAsyncQueue], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_ref(queue)
  # @param [GAsyncQueue] queue 
  # @return [GAsyncQueue] 
  # @scope class
  attach_function :g_async_queue_ref, :g_async_queue_ref, [GAsyncQueue], GAsyncQueue
  
  # (Not documented)
  # 
  # @method g_async_queue_unref(queue)
  # @param [GAsyncQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_unref, :g_async_queue_unref, [GAsyncQueue], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_ref_unlocked(queue)
  # @param [GAsyncQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_ref_unlocked, :g_async_queue_ref_unlocked, [GAsyncQueue], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_unref_and_unlock(queue)
  # @param [GAsyncQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_unref_and_unlock, :g_async_queue_unref_and_unlock, [GAsyncQueue], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_push(queue, data)
  # @param [GAsyncQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_push, :g_async_queue_push, [GAsyncQueue, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_push_unlocked(queue, data)
  # @param [GAsyncQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_push_unlocked, :g_async_queue_push_unlocked, [GAsyncQueue, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_push_sorted(queue, data, func, user_data)
  # @param [GAsyncQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_push_sorted, :g_async_queue_push_sorted, [GAsyncQueue, :pointer, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_push_sorted_unlocked(queue, data, func, user_data)
  # @param [GAsyncQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_push_sorted_unlocked, :g_async_queue_push_sorted_unlocked, [GAsyncQueue, :pointer, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_pop(queue)
  # @param [GAsyncQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_pop, :g_async_queue_pop, [GAsyncQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_pop_unlocked(queue)
  # @param [GAsyncQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_pop_unlocked, :g_async_queue_pop_unlocked, [GAsyncQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_try_pop(queue)
  # @param [GAsyncQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_try_pop, :g_async_queue_try_pop, [GAsyncQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_try_pop_unlocked(queue)
  # @param [GAsyncQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_try_pop_unlocked, :g_async_queue_try_pop_unlocked, [GAsyncQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_timeout_pop(queue, timeout)
  # @param [GAsyncQueue] queue 
  # @param [Integer] timeout 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_timeout_pop, :g_async_queue_timeout_pop, [GAsyncQueue, :ulong_long], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_timeout_pop_unlocked(queue, timeout)
  # @param [GAsyncQueue] queue 
  # @param [Integer] timeout 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_timeout_pop_unlocked, :g_async_queue_timeout_pop_unlocked, [GAsyncQueue, :ulong_long], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_length(queue)
  # @param [GAsyncQueue] queue 
  # @return [Integer] 
  # @scope class
  attach_function :g_async_queue_length, :g_async_queue_length, [GAsyncQueue], :int
  
  # (Not documented)
  # 
  # @method g_async_queue_length_unlocked(queue)
  # @param [GAsyncQueue] queue 
  # @return [Integer] 
  # @scope class
  attach_function :g_async_queue_length_unlocked, :g_async_queue_length_unlocked, [GAsyncQueue], :int
  
  # (Not documented)
  # 
  # @method g_async_queue_sort(queue, func, user_data)
  # @param [GAsyncQueue] queue 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_sort, :g_async_queue_sort, [GAsyncQueue, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_sort_unlocked(queue, func, user_data)
  # @param [GAsyncQueue] queue 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_async_queue_sort_unlocked, :g_async_queue_sort_unlocked, [GAsyncQueue, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_async_queue_timed_pop(queue, end_time)
  # @param [GAsyncQueue] queue 
  # @param [GTimeVal] end_time 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_timed_pop, :g_async_queue_timed_pop, [GAsyncQueue, GTimeVal], :pointer
  
  # (Not documented)
  # 
  # @method g_async_queue_timed_pop_unlocked(queue, end_time)
  # @param [GAsyncQueue] queue 
  # @param [GTimeVal] end_time 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_async_queue_timed_pop_unlocked, :g_async_queue_timed_pop_unlocked, [GAsyncQueue, GTimeVal], :pointer
  
  # (Not documented)
  # 
  # @method g_on_error_query(prg_name)
  # @param [String] prg_name 
  # @return [nil] 
  # @scope class
  attach_function :g_on_error_query, :g_on_error_query, [:string], :void
  
  # (Not documented)
  # 
  # @method g_on_error_stack_trace(prg_name)
  # @param [String] prg_name 
  # @return [nil] 
  # @scope class
  attach_function :g_on_error_stack_trace, :g_on_error_stack_trace, [:string], :void
  
  # (Not documented)
  # 
  # @method g_base64_encode_step(in_, len, break_lines, out, state, save)
  # @param [FFI::Pointer(*Guchar)] in_ 
  # @param [Integer] len 
  # @param [Integer] break_lines 
  # @param [String] out 
  # @param [FFI::Pointer(*Gint)] state 
  # @param [FFI::Pointer(*Gint)] save 
  # @return [Integer] 
  # @scope class
  attach_function :g_base64_encode_step, :g_base64_encode_step, [:pointer, :uint, :int, :string, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_base64_encode_close(break_lines, out, state, save)
  # @param [Integer] break_lines 
  # @param [String] out 
  # @param [FFI::Pointer(*Gint)] state 
  # @param [FFI::Pointer(*Gint)] save 
  # @return [Integer] 
  # @scope class
  attach_function :g_base64_encode_close, :g_base64_encode_close, [:int, :string, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_base64_encode(data, len)
  # @param [FFI::Pointer(*Guchar)] data 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_base64_encode, :g_base64_encode, [:pointer, :uint], :string
  
  # (Not documented)
  # 
  # @method g_base64_decode_step(in_, len, out, state, save)
  # @param [String] in_ 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Guchar)] out 
  # @param [FFI::Pointer(*Gint)] state 
  # @param [FFI::Pointer(*Guint)] save 
  # @return [Integer] 
  # @scope class
  attach_function :g_base64_decode_step, :g_base64_decode_step, [:string, :uint, :pointer, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_base64_decode(text, out_len)
  # @param [String] text 
  # @param [FFI::Pointer(*Gsize)] out_len 
  # @return [FFI::Pointer(*Guchar)] 
  # @scope class
  attach_function :g_base64_decode, :g_base64_decode, [:string, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_base64_decode_inplace(text, out_len)
  # @param [String] text 
  # @param [FFI::Pointer(*Gsize)] out_len 
  # @return [FFI::Pointer(*Guchar)] 
  # @scope class
  attach_function :g_base64_decode_inplace, :g_base64_decode_inplace, [:string, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bit_lock(address, lock_bit)
  # @param [FFI::Pointer(*Gint)] address 
  # @param [Integer] lock_bit 
  # @return [nil] 
  # @scope class
  attach_function :g_bit_lock, :g_bit_lock, [:pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_bit_trylock(address, lock_bit)
  # @param [FFI::Pointer(*Gint)] address 
  # @param [Integer] lock_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_trylock, :g_bit_trylock, [:pointer, :int], :int
  
  # (Not documented)
  # 
  # @method g_bit_unlock(address, lock_bit)
  # @param [FFI::Pointer(*Gint)] address 
  # @param [Integer] lock_bit 
  # @return [nil] 
  # @scope class
  attach_function :g_bit_unlock, :g_bit_unlock, [:pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_pointer_bit_lock(address, lock_bit)
  # @param [FFI::Pointer(*Void)] address 
  # @param [Integer] lock_bit 
  # @return [nil] 
  # @scope class
  attach_function :g_pointer_bit_lock, :g_pointer_bit_lock, [:pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_pointer_bit_trylock(address, lock_bit)
  # @param [FFI::Pointer(*Void)] address 
  # @param [Integer] lock_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_pointer_bit_trylock, :g_pointer_bit_trylock, [:pointer, :int], :int
  
  # (Not documented)
  # 
  # @method g_pointer_bit_unlock(address, lock_bit)
  # @param [FFI::Pointer(*Void)] address 
  # @param [Integer] lock_bit 
  # @return [nil] 
  # @scope class
  attach_function :g_pointer_bit_unlock, :g_pointer_bit_unlock, [:pointer, :int], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_bookmark_file_error).</em>
  # 
  # === Options:
  # :invalid_uri ::
  #   
  # :invalid_value ::
  #   
  # :app_not_registered ::
  #   
  # :uri_not_found ::
  #   
  # :read ::
  #   
  # :unknown_encoding ::
  #   
  # :write ::
  #   
  # :file_not_found ::
  #   
  # 
  # @method _enum_g_bookmark_file_error_
  # @return [Symbol]
  # @scope class
  enum :g_bookmark_file_error, [
    :invalid_uri, 0,
    :invalid_value, 1,
    :app_not_registered, 2,
    :uri_not_found, 3,
    :read, 4,
    :unknown_encoding, 5,
    :write, 6,
    :file_not_found, 7
  ]
  
  # (Not documented)
  # 
  # @method g_bookmark_file_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_error_quark, :g_bookmark_file_error_quark, [], :uint
  
  # (Not documented)
  module GBookmarkFileWrappers
    # @return [nil] 
    def free()
      Glib.g_bookmark_file_free(self)
    end
    
    # @param [String] filename 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_file(filename, error)
      Glib.g_bookmark_file_load_from_file(self, filename, error)
    end
    
    # @param [String] data 
    # @param [Integer] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_data(data, length, error)
      Glib.g_bookmark_file_load_from_data(self, data, length, error)
    end
    
    # @param [String] file 
    # @param [FFI::Pointer(**Gchar)] full_path 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_data_dirs(file, full_path, error)
      Glib.g_bookmark_file_load_from_data_dirs(self, file, full_path, error)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def to_data(length, error)
      Glib.g_bookmark_file_to_data(self, length, error)
    end
    
    # @param [String] filename 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def to_file(filename, error)
      Glib.g_bookmark_file_to_file(self, filename, error)
    end
    
    # @param [String] uri 
    # @param [String] title 
    # @return [nil] 
    def set_title(uri, title)
      Glib.g_bookmark_file_set_title(self, uri, title)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_title(uri, error)
      Glib.g_bookmark_file_get_title(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [String] description 
    # @return [nil] 
    def set_description(uri, description)
      Glib.g_bookmark_file_set_description(self, uri, description)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_description(uri, error)
      Glib.g_bookmark_file_get_description(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [String] mime_type 
    # @return [nil] 
    def set_mime_type(uri, mime_type)
      Glib.g_bookmark_file_set_mime_type(self, uri, mime_type)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_mime_type(uri, error)
      Glib.g_bookmark_file_get_mime_type(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**Gchar)] groups 
    # @param [Integer] length 
    # @return [nil] 
    def set_groups(uri, groups, length)
      Glib.g_bookmark_file_set_groups(self, uri, groups, length)
    end
    
    # @param [String] uri 
    # @param [String] group 
    # @return [nil] 
    def add_group(uri, group)
      Glib.g_bookmark_file_add_group(self, uri, group)
    end
    
    # @param [String] uri 
    # @param [String] group 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def has_group(uri, group, error)
      Glib.g_bookmark_file_has_group(self, uri, group, error)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def get_groups(uri, length, error)
      Glib.g_bookmark_file_get_groups(self, uri, length, error)
    end
    
    # @param [String] uri 
    # @param [String] name 
    # @param [String] exec 
    # @return [nil] 
    def add_application(uri, name, exec)
      Glib.g_bookmark_file_add_application(self, uri, name, exec)
    end
    
    # @param [String] uri 
    # @param [String] name 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def has_application(uri, name, error)
      Glib.g_bookmark_file_has_application(self, uri, name, error)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def get_applications(uri, length, error)
      Glib.g_bookmark_file_get_applications(self, uri, length, error)
    end
    
    # @param [String] uri 
    # @param [String] name 
    # @param [String] exec 
    # @param [Integer] count 
    # @param [Integer] stamp 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def set_app_info(uri, name, exec, count, stamp, error)
      Glib.g_bookmark_file_set_app_info(self, uri, name, exec, count, stamp, error)
    end
    
    # @param [String] uri 
    # @param [String] name 
    # @param [FFI::Pointer(**Gchar)] exec 
    # @param [FFI::Pointer(*Guint)] count 
    # @param [FFI::Pointer(*TimeT)] stamp 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_app_info(uri, name, exec, count, stamp, error)
      Glib.g_bookmark_file_get_app_info(self, uri, name, exec, count, stamp, error)
    end
    
    # @param [String] uri 
    # @param [Integer] is_private 
    # @return [nil] 
    def set_is_private(uri, is_private)
      Glib.g_bookmark_file_set_is_private(self, uri, is_private)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_is_private(uri, error)
      Glib.g_bookmark_file_get_is_private(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [String] href 
    # @param [String] mime_type 
    # @return [nil] 
    def set_icon(uri, href, mime_type)
      Glib.g_bookmark_file_set_icon(self, uri, href, mime_type)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**Gchar)] href 
    # @param [FFI::Pointer(**Gchar)] mime_type 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_icon(uri, href, mime_type, error)
      Glib.g_bookmark_file_get_icon(self, uri, href, mime_type, error)
    end
    
    # @param [String] uri 
    # @param [Integer] added 
    # @return [nil] 
    def set_added(uri, added)
      Glib.g_bookmark_file_set_added(self, uri, added)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_added(uri, error)
      Glib.g_bookmark_file_get_added(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [Integer] modified 
    # @return [nil] 
    def set_modified(uri, modified)
      Glib.g_bookmark_file_set_modified(self, uri, modified)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_modified(uri, error)
      Glib.g_bookmark_file_get_modified(self, uri, error)
    end
    
    # @param [String] uri 
    # @param [Integer] visited 
    # @return [nil] 
    def set_visited(uri, visited)
      Glib.g_bookmark_file_set_visited(self, uri, visited)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_visited(uri, error)
      Glib.g_bookmark_file_get_visited(self, uri, error)
    end
    
    # @param [String] uri 
    # @return [Integer] 
    def has_item(uri)
      Glib.g_bookmark_file_has_item(self, uri)
    end
    
    # @return [Integer] 
    def get_size()
      Glib.g_bookmark_file_get_size(self)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def get_uris(length)
      Glib.g_bookmark_file_get_uris(self, length)
    end
    
    # @param [String] uri 
    # @param [String] group 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_group(uri, group, error)
      Glib.g_bookmark_file_remove_group(self, uri, group, error)
    end
    
    # @param [String] uri 
    # @param [String] name 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_application(uri, name, error)
      Glib.g_bookmark_file_remove_application(self, uri, name, error)
    end
    
    # @param [String] uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_item(uri, error)
      Glib.g_bookmark_file_remove_item(self, uri, error)
    end
    
    # @param [String] old_uri 
    # @param [String] new_uri 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def move_item(old_uri, new_uri, error)
      Glib.g_bookmark_file_move_item(self, old_uri, new_uri, error)
    end
  end
  
  class GBookmarkFile < FFI::Struct
    include GBookmarkFileWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_bookmark_file_new()
  # @return [GBookmarkFile] 
  # @scope class
  attach_function :g_bookmark_file_new, :g_bookmark_file_new, [], GBookmarkFile
  
  # (Not documented)
  # 
  # @method g_bookmark_file_free(bookmark)
  # @param [GBookmarkFile] bookmark 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_free, :g_bookmark_file_free, [GBookmarkFile], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_load_from_file(bookmark, filename, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] filename 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_load_from_file, :g_bookmark_file_load_from_file, [GBookmarkFile, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_load_from_data(bookmark, data, length, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] data 
  # @param [Integer] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_load_from_data, :g_bookmark_file_load_from_data, [GBookmarkFile, :string, :uint, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] file 
  # @param [FFI::Pointer(**Gchar)] full_path 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_load_from_data_dirs, :g_bookmark_file_load_from_data_dirs, [GBookmarkFile, :string, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_to_data(bookmark, length, error)
  # @param [GBookmarkFile] bookmark 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_bookmark_file_to_data, :g_bookmark_file_to_data, [GBookmarkFile, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_bookmark_file_to_file(bookmark, filename, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] filename 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_to_file, :g_bookmark_file_to_file, [GBookmarkFile, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_title(bookmark, uri, title)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] title 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_title, :g_bookmark_file_set_title, [GBookmarkFile, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_title(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_bookmark_file_get_title, :g_bookmark_file_get_title, [GBookmarkFile, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_description(bookmark, uri, description)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] description 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_description, :g_bookmark_file_set_description, [GBookmarkFile, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_description(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_bookmark_file_get_description, :g_bookmark_file_get_description, [GBookmarkFile, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_mime_type(bookmark, uri, mime_type)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] mime_type 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_mime_type, :g_bookmark_file_set_mime_type, [GBookmarkFile, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_mime_type(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_bookmark_file_get_mime_type, :g_bookmark_file_get_mime_type, [GBookmarkFile, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_groups(bookmark, uri, groups, length)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**Gchar)] groups 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_groups, :g_bookmark_file_set_groups, [GBookmarkFile, :string, :pointer, :uint], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_add_group(bookmark, uri, group)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] group 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_add_group, :g_bookmark_file_add_group, [GBookmarkFile, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_has_group(bookmark, uri, group, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] group 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_has_group, :g_bookmark_file_has_group, [GBookmarkFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_groups(bookmark, uri, length, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_bookmark_file_get_groups, :g_bookmark_file_get_groups, [GBookmarkFile, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bookmark_file_add_application(bookmark, uri, name, exec)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] name 
  # @param [String] exec 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_add_application, :g_bookmark_file_add_application, [GBookmarkFile, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_has_application(bookmark, uri, name, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] name 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_has_application, :g_bookmark_file_has_application, [GBookmarkFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_applications(bookmark, uri, length, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_bookmark_file_get_applications, :g_bookmark_file_get_applications, [GBookmarkFile, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] name 
  # @param [String] exec 
  # @param [Integer] count 
  # @param [Integer] stamp 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_set_app_info, :g_bookmark_file_set_app_info, [GBookmarkFile, :string, :string, :string, :int, :long_long, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] name 
  # @param [FFI::Pointer(**Gchar)] exec 
  # @param [FFI::Pointer(*Guint)] count 
  # @param [FFI::Pointer(*TimeT)] stamp 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_app_info, :g_bookmark_file_get_app_info, [GBookmarkFile, :string, :string, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_is_private(bookmark, uri, is_private)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [Integer] is_private 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_is_private, :g_bookmark_file_set_is_private, [GBookmarkFile, :string, :int], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_is_private(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_is_private, :g_bookmark_file_get_is_private, [GBookmarkFile, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_icon(bookmark, uri, href, mime_type)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] href 
  # @param [String] mime_type 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_icon, :g_bookmark_file_set_icon, [GBookmarkFile, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**Gchar)] href 
  # @param [FFI::Pointer(**Gchar)] mime_type 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_icon, :g_bookmark_file_get_icon, [GBookmarkFile, :string, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_added(bookmark, uri, added)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [Integer] added 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_added, :g_bookmark_file_set_added, [GBookmarkFile, :string, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_added(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_added, :g_bookmark_file_get_added, [GBookmarkFile, :string, :pointer], :long_long
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_modified(bookmark, uri, modified)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [Integer] modified 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_modified, :g_bookmark_file_set_modified, [GBookmarkFile, :string, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_modified(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_modified, :g_bookmark_file_get_modified, [GBookmarkFile, :string, :pointer], :long_long
  
  # (Not documented)
  # 
  # @method g_bookmark_file_set_visited(bookmark, uri, visited)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [Integer] visited 
  # @return [nil] 
  # @scope class
  attach_function :g_bookmark_file_set_visited, :g_bookmark_file_set_visited, [GBookmarkFile, :string, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_visited(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_visited, :g_bookmark_file_get_visited, [GBookmarkFile, :string, :pointer], :long_long
  
  # (Not documented)
  # 
  # @method g_bookmark_file_has_item(bookmark, uri)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_has_item, :g_bookmark_file_has_item, [GBookmarkFile, :string], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_size(bookmark)
  # @param [GBookmarkFile] bookmark 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_get_size, :g_bookmark_file_get_size, [GBookmarkFile], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_get_uris(bookmark, length)
  # @param [GBookmarkFile] bookmark 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_bookmark_file_get_uris, :g_bookmark_file_get_uris, [GBookmarkFile, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bookmark_file_remove_group(bookmark, uri, group, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] group 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_remove_group, :g_bookmark_file_remove_group, [GBookmarkFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_remove_application(bookmark, uri, name, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [String] name 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_remove_application, :g_bookmark_file_remove_application, [GBookmarkFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_remove_item(bookmark, uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_remove_item, :g_bookmark_file_remove_item, [GBookmarkFile, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bookmark_file_move_item(bookmark, old_uri, new_uri, error)
  # @param [GBookmarkFile] bookmark 
  # @param [String] old_uri 
  # @param [String] new_uri 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_bookmark_file_move_item, :g_bookmark_file_move_item, [GBookmarkFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bytes_new(data, size)
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] size 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_new, :g_bytes_new, [:pointer, :uint], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_new_take(data, size)
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Integer] size 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_new_take, :g_bytes_new_take, [:pointer, :uint], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_new_static(data, size)
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] size 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_new_static, :g_bytes_new_static, [:pointer, :uint], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_new_with_free_func(data, size, free_func, user_data)
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] size 
  # @param [FFI::Pointer(GDestroyNotify)] free_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_new_with_free_func, :g_bytes_new_with_free_func, [:pointer, :uint, :pointer, :pointer], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_new_from_bytes(bytes, offset, length)
  # @param [GBytes] bytes 
  # @param [Integer] offset 
  # @param [Integer] length 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_new_from_bytes, :g_bytes_new_from_bytes, [GBytes, :uint, :uint], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_get_data(bytes, size)
  # @param [GBytes] bytes 
  # @param [FFI::Pointer(*Gsize)] size 
  # @return [FFI::Pointer(Gconstpointer)] 
  # @scope class
  attach_function :g_bytes_get_data, :g_bytes_get_data, [GBytes, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bytes_get_size(bytes)
  # @param [GBytes] bytes 
  # @return [Integer] 
  # @scope class
  attach_function :g_bytes_get_size, :g_bytes_get_size, [GBytes], :uint
  
  # (Not documented)
  # 
  # @method g_bytes_ref(bytes)
  # @param [GBytes] bytes 
  # @return [GBytes] 
  # @scope class
  attach_function :g_bytes_ref, :g_bytes_ref, [GBytes], GBytes
  
  # (Not documented)
  # 
  # @method g_bytes_unref(bytes)
  # @param [GBytes] bytes 
  # @return [nil] 
  # @scope class
  attach_function :g_bytes_unref, :g_bytes_unref, [GBytes], :void
  
  # (Not documented)
  # 
  # @method g_bytes_unref_to_data(bytes, size)
  # @param [GBytes] bytes 
  # @param [FFI::Pointer(*Gsize)] size 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_bytes_unref_to_data, :g_bytes_unref_to_data, [GBytes, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_bytes_unref_to_array(bytes)
  # @param [GBytes] bytes 
  # @return [GByteArray] 
  # @scope class
  attach_function :g_bytes_unref_to_array, :g_bytes_unref_to_array, [GBytes], GByteArray
  
  # (Not documented)
  # 
  # @method g_bytes_hash(bytes)
  # @param [FFI::Pointer(Gconstpointer)] bytes 
  # @return [Integer] 
  # @scope class
  attach_function :g_bytes_hash, :g_bytes_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_bytes_equal(bytes1, bytes2)
  # @param [FFI::Pointer(Gconstpointer)] bytes1 
  # @param [FFI::Pointer(Gconstpointer)] bytes2 
  # @return [Integer] 
  # @scope class
  attach_function :g_bytes_equal, :g_bytes_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_bytes_compare(bytes1, bytes2)
  # @param [FFI::Pointer(Gconstpointer)] bytes1 
  # @param [FFI::Pointer(Gconstpointer)] bytes2 
  # @return [Integer] 
  # @scope class
  attach_function :g_bytes_compare, :g_bytes_compare, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_get_charset(charset)
  # @param [FFI::Pointer(**CharS)] charset 
  # @return [Integer] 
  # @scope class
  attach_function :g_get_charset, :g_get_charset, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_get_codeset()
  # @return [String] 
  # @scope class
  attach_function :g_get_codeset, :g_get_codeset, [], :string
  
  # (Not documented)
  # 
  # @method g_get_language_names()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_get_language_names, :g_get_language_names, [], :pointer
  
  # (Not documented)
  # 
  # @method g_get_locale_variants(locale)
  # @param [String] locale 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_get_locale_variants, :g_get_locale_variants, [:string], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_checksum_type).</em>
  # 
  # === Options:
  # :md5 ::
  #   
  # :sha1 ::
  #   
  # :sha256 ::
  #   
  # 
  # @method _enum_g_checksum_type_
  # @return [Symbol]
  # @scope class
  enum :g_checksum_type, [
    :md5, 0,
    :sha1, 1,
    :sha256, 2
  ]
  
  # (Not documented)
  module GChecksumWrappers
    # @return [nil] 
    def reset()
      Glib.g_checksum_reset(self)
    end
    
    # @return [GChecksum] 
    def copy()
      GChecksum.new Glib.g_checksum_copy(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_checksum_free(self)
    end
    
    # @param [FFI::Pointer(*Guchar)] data 
    # @param [Integer] length 
    # @return [nil] 
    def update(data, length)
      Glib.g_checksum_update(self, data, length)
    end
    
    # @return [String] 
    def get_string()
      Glib.g_checksum_get_string(self)
    end
    
    # @param [FFI::Pointer(*Guint8)] buffer 
    # @param [FFI::Pointer(*Gsize)] digest_len 
    # @return [nil] 
    def get_digest(buffer, digest_len)
      Glib.g_checksum_get_digest(self, buffer, digest_len)
    end
  end
  
  class GChecksum < FFI::Struct
    include GChecksumWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_checksum_type_get_length(checksum_type)
  # @param [Symbol from _enum_g_checksum_type_] checksum_type 
  # @return [Integer] 
  # @scope class
  attach_function :g_checksum_type_get_length, :g_checksum_type_get_length, [:g_checksum_type], :int
  
  # (Not documented)
  # 
  # @method g_checksum_new(checksum_type)
  # @param [Symbol from _enum_g_checksum_type_] checksum_type 
  # @return [GChecksum] 
  # @scope class
  attach_function :g_checksum_new, :g_checksum_new, [:g_checksum_type], GChecksum
  
  # (Not documented)
  # 
  # @method g_checksum_reset(checksum)
  # @param [GChecksum] checksum 
  # @return [nil] 
  # @scope class
  attach_function :g_checksum_reset, :g_checksum_reset, [GChecksum], :void
  
  # (Not documented)
  # 
  # @method g_checksum_copy(checksum)
  # @param [GChecksum] checksum 
  # @return [GChecksum] 
  # @scope class
  attach_function :g_checksum_copy, :g_checksum_copy, [GChecksum], GChecksum
  
  # (Not documented)
  # 
  # @method g_checksum_free(checksum)
  # @param [GChecksum] checksum 
  # @return [nil] 
  # @scope class
  attach_function :g_checksum_free, :g_checksum_free, [GChecksum], :void
  
  # (Not documented)
  # 
  # @method g_checksum_update(checksum, data, length)
  # @param [GChecksum] checksum 
  # @param [FFI::Pointer(*Guchar)] data 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_checksum_update, :g_checksum_update, [GChecksum, :pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_checksum_get_string(checksum)
  # @param [GChecksum] checksum 
  # @return [String] 
  # @scope class
  attach_function :g_checksum_get_string, :g_checksum_get_string, [GChecksum], :string
  
  # (Not documented)
  # 
  # @method g_checksum_get_digest(checksum, buffer, digest_len)
  # @param [GChecksum] checksum 
  # @param [FFI::Pointer(*Guint8)] buffer 
  # @param [FFI::Pointer(*Gsize)] digest_len 
  # @return [nil] 
  # @scope class
  attach_function :g_checksum_get_digest, :g_checksum_get_digest, [GChecksum, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_compute_checksum_for_data(checksum_type, data, length)
  # @param [Symbol from _enum_g_checksum_type_] checksum_type 
  # @param [FFI::Pointer(*Guchar)] data 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_compute_checksum_for_data, :g_compute_checksum_for_data, [:g_checksum_type, :pointer, :uint], :string
  
  # (Not documented)
  # 
  # @method g_compute_checksum_for_string(checksum_type, str, length)
  # @param [Symbol from _enum_g_checksum_type_] checksum_type 
  # @param [String] str 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_compute_checksum_for_string, :g_compute_checksum_for_string, [:g_checksum_type, :string, :int], :string
  
  # (Not documented)
  # 
  # @method g_compute_checksum_for_bytes(checksum_type, data)
  # @param [Symbol from _enum_g_checksum_type_] checksum_type 
  # @param [GBytes] data 
  # @return [String] 
  # @scope class
  attach_function :g_compute_checksum_for_bytes, :g_compute_checksum_for_bytes, [:g_checksum_type, GBytes], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_convert_error).</em>
  # 
  # === Options:
  # :no_conversion ::
  #   
  # :illegal_sequence ::
  #   
  # :failed ::
  #   
  # :partial_input ::
  #   
  # :bad_uri ::
  #   
  # :not_absolute_path ::
  #   
  # 
  # @method _enum_g_convert_error_
  # @return [Symbol]
  # @scope class
  enum :g_convert_error, [
    :no_conversion, 0,
    :illegal_sequence, 1,
    :failed, 2,
    :partial_input, 3,
    :bad_uri, 4,
    :not_absolute_path, 5
  ]
  
  # (Not documented)
  # 
  # @method g_convert_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_convert_error_quark, :g_convert_error_quark, [], :uint
  
  # (Not documented)
  module GIConvWrappers
    # @return [Integer] 
    def close()
      Glib.g_iconv_close(self)
    end
  end
  
  class GIConv < FFI::Struct
    include GIConvWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_iconv_open(to_codeset, from_codeset)
  # @param [String] to_codeset 
  # @param [String] from_codeset 
  # @return [GIConv] 
  # @scope class
  attach_function :g_iconv_open, :g_iconv_open, [:string, :string], GIConv
  
  # (Not documented)
  # 
  # @method g_iconv_close(converter)
  # @param [GIConv] converter 
  # @return [Integer] 
  # @scope class
  attach_function :g_iconv_close, :g_iconv_close, [GIConv], :int
  
  # (Not documented)
  # 
  # @method g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_written, error)
  # @param [String] str 
  # @param [Integer] len 
  # @param [String] to_codeset 
  # @param [String] from_codeset 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_convert, :g_convert, [:string, :int, :string, :string, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, error)
  # @param [String] str 
  # @param [Integer] len 
  # @param [GIConv] converter 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_convert_with_iconv, :g_convert_with_iconv, [:string, :int, GIConv, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, bytes_read, bytes_written, error)
  # @param [String] str 
  # @param [Integer] len 
  # @param [String] to_codeset 
  # @param [String] from_codeset 
  # @param [String] fallback 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_convert_with_fallback, :g_convert_with_fallback, [:string, :int, :string, :string, :string, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error)
  # @param [String] opsysstring 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_locale_to_utf8, :g_locale_to_utf8, [:string, :int, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error)
  # @param [String] utf8string 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_locale_from_utf8, :g_locale_from_utf8, [:string, :int, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_filename_to_utf8_utf8(opsysstring, len, bytes_read, bytes_written, error)
  # @param [String] opsysstring 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_filename_to_utf8_utf8, :g_filename_to_utf8_utf8, [:string, :int, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_filename_from_utf8_utf8(utf8string, len, bytes_read, bytes_written, error)
  # @param [String] utf8string 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_filename_from_utf8_utf8, :g_filename_from_utf8_utf8, [:string, :int, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_filename_from_uri_utf8(uri, hostname, error)
  # @param [String] uri 
  # @param [FFI::Pointer(**Gchar)] hostname 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_filename_from_uri_utf8, :g_filename_from_uri_utf8, [:string, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_filename_to_uri_utf8(filename, hostname, error)
  # @param [String] filename 
  # @param [String] hostname 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_filename_to_uri_utf8, :g_filename_to_uri_utf8, [:string, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_filename_display_name(filename)
  # @param [String] filename 
  # @return [String] 
  # @scope class
  attach_function :g_filename_display_name, :g_filename_display_name, [:string], :string
  
  # (Not documented)
  # 
  # @method g_get_filename_charsets(charsets)
  # @param [FFI::Pointer(***Gchar)] charsets 
  # @return [Integer] 
  # @scope class
  attach_function :g_get_filename_charsets, :g_get_filename_charsets, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_filename_display_basename(filename)
  # @param [String] filename 
  # @return [String] 
  # @scope class
  attach_function :g_filename_display_basename, :g_filename_display_basename, [:string], :string
  
  # (Not documented)
  # 
  # @method g_uri_list_extract_uris(uri_list)
  # @param [String] uri_list 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_uri_list_extract_uris, :g_uri_list_extract_uris, [:string], :pointer
  
  # (Not documented)
  class GData < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_data_foreach_func_(data, user_data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :g_data_foreach_func, [:pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_datalist_init(datalist)
  # @param [FFI::Pointer(**GData)] datalist 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_init, :g_datalist_init, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_datalist_clear(datalist)
  # @param [FFI::Pointer(**GData)] datalist 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_clear, :g_datalist_clear, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_datalist_id_get_data(datalist, key_id)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] key_id 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_datalist_id_get_data, :g_datalist_id_get_data, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_datalist_id_set_data_full(datalist, key_id, data, destroy_func)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] key_id 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] destroy_func 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_id_set_data_full, :g_datalist_id_set_data_full, [:pointer, :uint, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_duplicate_func_(data, user_data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_duplicate_func, [:pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_datalist_id_dup_data(datalist, key_id, dup_func, user_data)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] key_id 
  # @param [Proc(_callback_g_duplicate_func_)] dup_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_datalist_id_dup_data, :g_datalist_id_dup_data, [:pointer, :uint, :g_duplicate_func, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_datalist_id_replace_data(datalist, key_id, oldval, newval, destroy, old_destroy)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] key_id 
  # @param [FFI::Pointer(Gpointer)] oldval 
  # @param [FFI::Pointer(Gpointer)] newval 
  # @param [FFI::Pointer(GDestroyNotify)] destroy 
  # @param [FFI::Pointer(*GDestroyNotify)] old_destroy 
  # @return [Integer] 
  # @scope class
  attach_function :g_datalist_id_replace_data, :g_datalist_id_replace_data, [:pointer, :uint, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_datalist_id_remove_no_notify(datalist, key_id)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] key_id 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_datalist_id_remove_no_notify, :g_datalist_id_remove_no_notify, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_datalist_foreach(datalist, func, user_data)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Proc(_callback_g_data_foreach_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_foreach, :g_datalist_foreach, [:pointer, :g_data_foreach_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_datalist_set_flags(datalist, flags)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] flags 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_set_flags, :g_datalist_set_flags, [:pointer, :uint], :void
  
  # (Not documented)
  # 
  # @method g_datalist_unset_flags(datalist, flags)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [Integer] flags 
  # @return [nil] 
  # @scope class
  attach_function :g_datalist_unset_flags, :g_datalist_unset_flags, [:pointer, :uint], :void
  
  # (Not documented)
  # 
  # @method g_datalist_get_flags(datalist)
  # @param [FFI::Pointer(**GData)] datalist 
  # @return [Integer] 
  # @scope class
  attach_function :g_datalist_get_flags, :g_datalist_get_flags, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_dataset_destroy(dataset_location)
  # @param [FFI::Pointer(Gconstpointer)] dataset_location 
  # @return [nil] 
  # @scope class
  attach_function :g_dataset_destroy, :g_dataset_destroy, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_dataset_id_get_data(dataset_location, key_id)
  # @param [FFI::Pointer(Gconstpointer)] dataset_location 
  # @param [Integer] key_id 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_dataset_id_get_data, :g_dataset_id_get_data, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_datalist_get_data(datalist, key)
  # @param [FFI::Pointer(**GData)] datalist 
  # @param [String] key 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_datalist_get_data, :g_datalist_get_data, [:pointer, :string], :pointer
  
  # (Not documented)
  # 
  # @method g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_func)
  # @param [FFI::Pointer(Gconstpointer)] dataset_location 
  # @param [Integer] key_id 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] destroy_func 
  # @return [nil] 
  # @scope class
  attach_function :g_dataset_id_set_data_full, :g_dataset_id_set_data_full, [:pointer, :uint, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_dataset_id_remove_no_notify(dataset_location, key_id)
  # @param [FFI::Pointer(Gconstpointer)] dataset_location 
  # @param [Integer] key_id 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_dataset_id_remove_no_notify, :g_dataset_id_remove_no_notify, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_dataset_foreach(dataset_location, func, user_data)
  # @param [FFI::Pointer(Gconstpointer)] dataset_location 
  # @param [Proc(_callback_g_data_foreach_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_dataset_foreach, :g_dataset_foreach, [:pointer, :g_data_foreach_func, :pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_date_dmy).</em>
  # 
  # === Options:
  # :day ::
  #   
  # :month ::
  #   
  # :year ::
  #   
  # 
  # @method _enum_g_date_dmy_
  # @return [Symbol]
  # @scope class
  enum :g_date_dmy, [
    :day, 0,
    :month, 1,
    :year, 2
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_date_weekday).</em>
  # 
  # === Options:
  # :bad_weekday ::
  #   
  # :monday ::
  #   
  # :tuesday ::
  #   
  # :wednesday ::
  #   
  # :thursday ::
  #   
  # :friday ::
  #   
  # :saturday ::
  #   
  # :sunday ::
  #   
  # 
  # @method _enum_g_date_weekday_
  # @return [Symbol]
  # @scope class
  enum :g_date_weekday, [
    :bad_weekday, 0,
    :monday, 1,
    :tuesday, 2,
    :wednesday, 3,
    :thursday, 4,
    :friday, 5,
    :saturday, 6,
    :sunday, 7
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_date_month).</em>
  # 
  # === Options:
  # :bad_month ::
  #   
  # :january ::
  #   
  # :february ::
  #   
  # :march ::
  #   
  # :april ::
  #   
  # :may ::
  #   
  # :june ::
  #   
  # :july ::
  #   
  # :august ::
  #   
  # :september ::
  #   
  # :october ::
  #   
  # :november ::
  #   
  # :december ::
  #   
  # 
  # @method _enum_g_date_month_
  # @return [Symbol]
  # @scope class
  enum :g_date_month, [
    :bad_month, 0,
    :january, 1,
    :february, 2,
    :march, 3,
    :april, 4,
    :may, 5,
    :june, 6,
    :july, 7,
    :august, 8,
    :september, 9,
    :october, 10,
    :november, 11,
    :december, 12
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :julian_days ::
  #   (Integer) julian days representation - we use a
  #    bitfield hoping that 64 bit platforms
  #    will pack this whole struct in one big
  #    int
  # :julian ::
  #   (Integer) julian is valid
  # :dmy ::
  #   (Integer) dmy is valid
  # :day ::
  #   (Integer) DMY representation
  # :month ::
  #   (Integer) 
  # :year ::
  #   (Integer) 
  module GDateWrappers
    # @return [nil] 
    def free()
      Glib.g_date_free(self)
    end
    
    # @return [Integer] 
    def valid()
      Glib.g_date_valid(self)
    end
    
    # @return [Symbol from _enum_g_date_weekday_] 
    def get_weekday()
      Glib.g_date_get_weekday(self)
    end
    
    # @return [Symbol from _enum_g_date_month_] 
    def get_month()
      Glib.g_date_get_month(self)
    end
    
    # @return [Integer] 
    def get_year()
      Glib.g_date_get_year(self)
    end
    
    # @return [Integer] 
    def get_day()
      Glib.g_date_get_day(self)
    end
    
    # @return [Integer] 
    def get_julian()
      Glib.g_date_get_julian(self)
    end
    
    # @return [Integer] 
    def get_day_of_year()
      Glib.g_date_get_day_of_year(self)
    end
    
    # @return [Integer] 
    def get_monday_week_of_year()
      Glib.g_date_get_monday_week_of_year(self)
    end
    
    # @return [Integer] 
    def get_sunday_week_of_year()
      Glib.g_date_get_sunday_week_of_year(self)
    end
    
    # @return [Integer] 
    def get_iso8601_week_of_year()
      Glib.g_date_get_iso8601_week_of_year(self)
    end
    
    # @param [Integer] n_dates 
    # @return [nil] 
    def clear(n_dates)
      Glib.g_date_clear(self, n_dates)
    end
    
    # @param [String] str 
    # @return [nil] 
    def set_parse(str)
      Glib.g_date_set_parse(self, str)
    end
    
    # @param [Integer] timet 
    # @return [nil] 
    def set_time_t(timet)
      Glib.g_date_set_time_t(self, timet)
    end
    
    # @param [GTimeVal] timeval 
    # @return [nil] 
    def set_time_val(timeval)
      Glib.g_date_set_time_val(self, timeval)
    end
    
    # @param [Integer] time 
    # @return [nil] 
    def set_time(time)
      Glib.g_date_set_time(self, time)
    end
    
    # @param [Symbol from _enum_g_date_month_] month 
    # @return [nil] 
    def set_month(month)
      Glib.g_date_set_month(self, month)
    end
    
    # @param [Integer] day 
    # @return [nil] 
    def set_day(day)
      Glib.g_date_set_day(self, day)
    end
    
    # @param [Integer] year 
    # @return [nil] 
    def set_year(year)
      Glib.g_date_set_year(self, year)
    end
    
    # @param [Integer] day 
    # @param [Symbol from _enum_g_date_month_] month 
    # @param [Integer] y 
    # @return [nil] 
    def set_dmy(day, month, y)
      Glib.g_date_set_dmy(self, day, month, y)
    end
    
    # @param [Integer] julian_date 
    # @return [nil] 
    def set_julian(julian_date)
      Glib.g_date_set_julian(self, julian_date)
    end
    
    # @return [Integer] 
    def is_first_of_month()
      Glib.g_date_is_first_of_month(self)
    end
    
    # @return [Integer] 
    def is_last_of_month()
      Glib.g_date_is_last_of_month(self)
    end
    
    # @param [Integer] n_days 
    # @return [nil] 
    def add_days(n_days)
      Glib.g_date_add_days(self, n_days)
    end
    
    # @param [Integer] n_days 
    # @return [nil] 
    def subtract_days(n_days)
      Glib.g_date_subtract_days(self, n_days)
    end
    
    # @param [Integer] n_months 
    # @return [nil] 
    def add_months(n_months)
      Glib.g_date_add_months(self, n_months)
    end
    
    # @param [Integer] n_months 
    # @return [nil] 
    def subtract_months(n_months)
      Glib.g_date_subtract_months(self, n_months)
    end
    
    # @param [Integer] n_years 
    # @return [nil] 
    def add_years(n_years)
      Glib.g_date_add_years(self, n_years)
    end
    
    # @param [Integer] n_years 
    # @return [nil] 
    def subtract_years(n_years)
      Glib.g_date_subtract_years(self, n_years)
    end
    
    # @param [FFI::Pointer(*GDate)] date2 
    # @return [Integer] 
    def days_between(date2)
      Glib.g_date_days_between(self, date2)
    end
    
    # @param [FFI::Pointer(*GDate)] rhs 
    # @return [Integer] 
    def compare(rhs)
      Glib.g_date_compare(self, rhs)
    end
    
    # @param [FFI::Pointer(*Tm)] tm 
    # @return [nil] 
    def to_struct_tm(tm)
      Glib.g_date_to_struct_tm(self, tm)
    end
    
    # @param [FFI::Pointer(*GDate)] min_date 
    # @param [FFI::Pointer(*GDate)] max_date 
    # @return [nil] 
    def clamp(min_date, max_date)
      Glib.g_date_clamp(self, min_date, max_date)
    end
    
    # @param [FFI::Pointer(*GDate)] date2 
    # @return [nil] 
    def order(date2)
      Glib.g_date_order(self, date2)
    end
  end
  
  class GDate < FFI::Struct
    include GDateWrappers
    layout :julian_days, :uint,
           :julian, :uint,
           :dmy, :uint,
           :day, :uint,
           :month, :uint,
           :year, :uint
  end
  
  # (Not documented)
  # 
  # @method g_date_new()
  # @return [GDate] 
  # @scope class
  attach_function :g_date_new, :g_date_new, [], GDate
  
  # (Not documented)
  # 
  # @method g_date_new_dmy(day, month, year)
  # @param [Integer] day 
  # @param [Symbol from _enum_g_date_month_] month 
  # @param [Integer] year 
  # @return [GDate] 
  # @scope class
  attach_function :g_date_new_dmy, :g_date_new_dmy, [:uchar, :g_date_month, :ushort], GDate
  
  # (Not documented)
  # 
  # @method g_date_new_julian(julian_day)
  # @param [Integer] julian_day 
  # @return [GDate] 
  # @scope class
  attach_function :g_date_new_julian, :g_date_new_julian, [:uint], GDate
  
  # (Not documented)
  # 
  # @method g_date_free(date)
  # @param [GDate] date 
  # @return [nil] 
  # @scope class
  attach_function :g_date_free, :g_date_free, [GDate], :void
  
  # (Not documented)
  # 
  # @method g_date_valid(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid, :g_date_valid, [GDate], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_day(day)
  # @param [Integer] day 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_day, :g_date_valid_day, [:uchar], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_month(month)
  # @param [Symbol from _enum_g_date_month_] month 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_month, :g_date_valid_month, [:g_date_month], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_year(year)
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_year, :g_date_valid_year, [:ushort], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_weekday(weekday)
  # @param [Symbol from _enum_g_date_weekday_] weekday 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_weekday, :g_date_valid_weekday, [:g_date_weekday], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_julian(julian_date)
  # @param [Integer] julian_date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_julian, :g_date_valid_julian, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_date_valid_dmy(day, month, year)
  # @param [Integer] day 
  # @param [Symbol from _enum_g_date_month_] month 
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_valid_dmy, :g_date_valid_dmy, [:uchar, :g_date_month, :ushort], :int
  
  # (Not documented)
  # 
  # @method g_date_get_weekday(date)
  # @param [GDate] date 
  # @return [Symbol from _enum_g_date_weekday_] 
  # @scope class
  attach_function :g_date_get_weekday, :g_date_get_weekday, [GDate], :g_date_weekday
  
  # (Not documented)
  # 
  # @method g_date_get_month(date)
  # @param [GDate] date 
  # @return [Symbol from _enum_g_date_month_] 
  # @scope class
  attach_function :g_date_get_month, :g_date_get_month, [GDate], :g_date_month
  
  # (Not documented)
  # 
  # @method g_date_get_year(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_year, :g_date_get_year, [GDate], :ushort
  
  # (Not documented)
  # 
  # @method g_date_get_day(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_day, :g_date_get_day, [GDate], :uchar
  
  # (Not documented)
  # 
  # @method g_date_get_julian(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_julian, :g_date_get_julian, [GDate], :uint
  
  # (Not documented)
  # 
  # @method g_date_get_day_of_year(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_day_of_year, :g_date_get_day_of_year, [GDate], :uint
  
  # (Not documented)
  # 
  # @method g_date_get_monday_week_of_year(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_monday_week_of_year, :g_date_get_monday_week_of_year, [GDate], :uint
  
  # (Not documented)
  # 
  # @method g_date_get_sunday_week_of_year(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_sunday_week_of_year, :g_date_get_sunday_week_of_year, [GDate], :uint
  
  # (Not documented)
  # 
  # @method g_date_get_iso8601_week_of_year(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_iso8601_week_of_year, :g_date_get_iso8601_week_of_year, [GDate], :uint
  
  # (Not documented)
  # 
  # @method g_date_clear(date, n_dates)
  # @param [GDate] date 
  # @param [Integer] n_dates 
  # @return [nil] 
  # @scope class
  attach_function :g_date_clear, :g_date_clear, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_set_parse(date, str)
  # @param [GDate] date 
  # @param [String] str 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_parse, :g_date_set_parse, [GDate, :string], :void
  
  # (Not documented)
  # 
  # @method g_date_set_time_t(date, timet)
  # @param [GDate] date 
  # @param [Integer] timet 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_time_t, :g_date_set_time_t, [GDate, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_date_set_time_val(date, timeval)
  # @param [GDate] date 
  # @param [GTimeVal] timeval 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_time_val, :g_date_set_time_val, [GDate, GTimeVal], :void
  
  # (Not documented)
  # 
  # @method g_date_set_time(date, time)
  # @param [GDate] date 
  # @param [Integer] time 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_time, :g_date_set_time, [GDate, :int], :void
  
  # (Not documented)
  # 
  # @method g_date_set_month(date, month)
  # @param [GDate] date 
  # @param [Symbol from _enum_g_date_month_] month 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_month, :g_date_set_month, [GDate, :g_date_month], :void
  
  # (Not documented)
  # 
  # @method g_date_set_day(date, day)
  # @param [GDate] date 
  # @param [Integer] day 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_day, :g_date_set_day, [GDate, :uchar], :void
  
  # (Not documented)
  # 
  # @method g_date_set_year(date, year)
  # @param [GDate] date 
  # @param [Integer] year 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_year, :g_date_set_year, [GDate, :ushort], :void
  
  # (Not documented)
  # 
  # @method g_date_set_dmy(date, day, month, y)
  # @param [GDate] date 
  # @param [Integer] day 
  # @param [Symbol from _enum_g_date_month_] month 
  # @param [Integer] y 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_dmy, :g_date_set_dmy, [GDate, :uchar, :g_date_month, :ushort], :void
  
  # (Not documented)
  # 
  # @method g_date_set_julian(date, julian_date)
  # @param [GDate] date 
  # @param [Integer] julian_date 
  # @return [nil] 
  # @scope class
  attach_function :g_date_set_julian, :g_date_set_julian, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_is_first_of_month(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_is_first_of_month, :g_date_is_first_of_month, [GDate], :int
  
  # (Not documented)
  # 
  # @method g_date_is_last_of_month(date)
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_is_last_of_month, :g_date_is_last_of_month, [GDate], :int
  
  # (Not documented)
  # 
  # @method g_date_add_days(date, n_days)
  # @param [GDate] date 
  # @param [Integer] n_days 
  # @return [nil] 
  # @scope class
  attach_function :g_date_add_days, :g_date_add_days, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_subtract_days(date, n_days)
  # @param [GDate] date 
  # @param [Integer] n_days 
  # @return [nil] 
  # @scope class
  attach_function :g_date_subtract_days, :g_date_subtract_days, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_add_months(date, n_months)
  # @param [GDate] date 
  # @param [Integer] n_months 
  # @return [nil] 
  # @scope class
  attach_function :g_date_add_months, :g_date_add_months, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_subtract_months(date, n_months)
  # @param [GDate] date 
  # @param [Integer] n_months 
  # @return [nil] 
  # @scope class
  attach_function :g_date_subtract_months, :g_date_subtract_months, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_add_years(date, n_years)
  # @param [GDate] date 
  # @param [Integer] n_years 
  # @return [nil] 
  # @scope class
  attach_function :g_date_add_years, :g_date_add_years, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_subtract_years(date, n_years)
  # @param [GDate] date 
  # @param [Integer] n_years 
  # @return [nil] 
  # @scope class
  attach_function :g_date_subtract_years, :g_date_subtract_years, [GDate, :uint], :void
  
  # (Not documented)
  # 
  # @method g_date_is_leap_year(year)
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_is_leap_year, :g_date_is_leap_year, [:ushort], :int
  
  # (Not documented)
  # 
  # @method g_date_get_days_in_month(month, year)
  # @param [Symbol from _enum_g_date_month_] month 
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_days_in_month, :g_date_get_days_in_month, [:g_date_month, :ushort], :uchar
  
  # (Not documented)
  # 
  # @method g_date_get_monday_weeks_in_year(year)
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_monday_weeks_in_year, :g_date_get_monday_weeks_in_year, [:ushort], :uchar
  
  # (Not documented)
  # 
  # @method g_date_get_sunday_weeks_in_year(year)
  # @param [Integer] year 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_get_sunday_weeks_in_year, :g_date_get_sunday_weeks_in_year, [:ushort], :uchar
  
  # (Not documented)
  # 
  # @method g_date_days_between(date1, date2)
  # @param [GDate] date1 
  # @param [GDate] date2 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_days_between, :g_date_days_between, [GDate, GDate], :int
  
  # (Not documented)
  # 
  # @method g_date_compare(lhs, rhs)
  # @param [GDate] lhs 
  # @param [GDate] rhs 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_compare, :g_date_compare, [GDate, GDate], :int
  
  # (Not documented)
  # 
  # @method g_date_to_struct_tm(date, tm)
  # @param [GDate] date 
  # @param [FFI::Pointer(*Tm)] tm 
  # @return [nil] 
  # @scope class
  attach_function :g_date_to_struct_tm, :g_date_to_struct_tm, [GDate, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_date_clamp(date, min_date, max_date)
  # @param [GDate] date 
  # @param [GDate] min_date 
  # @param [GDate] max_date 
  # @return [nil] 
  # @scope class
  attach_function :g_date_clamp, :g_date_clamp, [GDate, GDate, GDate], :void
  
  # (Not documented)
  # 
  # @method g_date_order(date1, date2)
  # @param [GDate] date1 
  # @param [GDate] date2 
  # @return [nil] 
  # @scope class
  attach_function :g_date_order, :g_date_order, [GDate, GDate], :void
  
  # (Not documented)
  # 
  # @method g_date_strftime(s, slen, format, date)
  # @param [String] s 
  # @param [Integer] slen 
  # @param [String] format 
  # @param [GDate] date 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_strftime, :g_date_strftime, [:string, :uint, :string, GDate], :uint
  
  # (Not documented)
  module GTimeZoneWrappers
    # @return [GTimeZone] 
    def ref()
      GTimeZone.new Glib.g_time_zone_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_time_zone_unref(self)
    end
    
    # @param [Symbol from _enum_g_time_type_] type 
    # @param [Integer] time 
    # @return [Integer] 
    def find_interval(type, time)
      Glib.g_time_zone_find_interval(self, type, time)
    end
    
    # @param [Symbol from _enum_g_time_type_] type 
    # @param [FFI::Pointer(*Gint64)] time 
    # @return [Integer] 
    def adjust_time(type, time)
      Glib.g_time_zone_adjust_time(self, type, time)
    end
    
    # @param [Integer] interval 
    # @return [String] 
    def get_abbreviation(interval)
      Glib.g_time_zone_get_abbreviation(self, interval)
    end
    
    # @param [Integer] interval 
    # @return [Integer] 
    def get_offset(interval)
      Glib.g_time_zone_get_offset(self, interval)
    end
    
    # @param [Integer] interval 
    # @return [Integer] 
    def is_dst(interval)
      Glib.g_time_zone_is_dst(self, interval)
    end
  end
  
  class GTimeZone < FFI::Struct
    include GTimeZoneWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_time_type).</em>
  # 
  # === Options:
  # :standard ::
  #   
  # :daylight ::
  #   
  # :universal ::
  #   
  # 
  # @method _enum_g_time_type_
  # @return [Symbol]
  # @scope class
  enum :g_time_type, [
    :standard, 0,
    :daylight, 1,
    :universal, 2
  ]
  
  # (Not documented)
  # 
  # @method g_time_zone_new(identifier)
  # @param [String] identifier 
  # @return [GTimeZone] 
  # @scope class
  attach_function :g_time_zone_new, :g_time_zone_new, [:string], GTimeZone
  
  # (Not documented)
  # 
  # @method g_time_zone_new_utc()
  # @return [GTimeZone] 
  # @scope class
  attach_function :g_time_zone_new_utc, :g_time_zone_new_utc, [], GTimeZone
  
  # (Not documented)
  # 
  # @method g_time_zone_new_local()
  # @return [GTimeZone] 
  # @scope class
  attach_function :g_time_zone_new_local, :g_time_zone_new_local, [], GTimeZone
  
  # (Not documented)
  # 
  # @method g_time_zone_ref(tz)
  # @param [GTimeZone] tz 
  # @return [GTimeZone] 
  # @scope class
  attach_function :g_time_zone_ref, :g_time_zone_ref, [GTimeZone], GTimeZone
  
  # (Not documented)
  # 
  # @method g_time_zone_unref(tz)
  # @param [GTimeZone] tz 
  # @return [nil] 
  # @scope class
  attach_function :g_time_zone_unref, :g_time_zone_unref, [GTimeZone], :void
  
  # (Not documented)
  # 
  # @method g_time_zone_find_interval(tz, type, time)
  # @param [GTimeZone] tz 
  # @param [Symbol from _enum_g_time_type_] type 
  # @param [Integer] time 
  # @return [Integer] 
  # @scope class
  attach_function :g_time_zone_find_interval, :g_time_zone_find_interval, [GTimeZone, :g_time_type, :long_long], :int
  
  # (Not documented)
  # 
  # @method g_time_zone_adjust_time(tz, type, time)
  # @param [GTimeZone] tz 
  # @param [Symbol from _enum_g_time_type_] type 
  # @param [FFI::Pointer(*Gint64)] time 
  # @return [Integer] 
  # @scope class
  attach_function :g_time_zone_adjust_time, :g_time_zone_adjust_time, [GTimeZone, :g_time_type, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_time_zone_get_abbreviation(tz, interval)
  # @param [GTimeZone] tz 
  # @param [Integer] interval 
  # @return [String] 
  # @scope class
  attach_function :g_time_zone_get_abbreviation, :g_time_zone_get_abbreviation, [GTimeZone, :int], :string
  
  # (Not documented)
  # 
  # @method g_time_zone_get_offset(tz, interval)
  # @param [GTimeZone] tz 
  # @param [Integer] interval 
  # @return [Integer] 
  # @scope class
  attach_function :g_time_zone_get_offset, :g_time_zone_get_offset, [GTimeZone, :int], :int
  
  # (Not documented)
  # 
  # @method g_time_zone_is_dst(tz, interval)
  # @param [GTimeZone] tz 
  # @param [Integer] interval 
  # @return [Integer] 
  # @scope class
  attach_function :g_time_zone_is_dst, :g_time_zone_is_dst, [GTimeZone, :int], :int
  
  # (Not documented)
  module GDateTimeWrappers
    # @return [nil] 
    def unref()
      Glib.g_date_time_unref(self)
    end
    
    # @return [GDateTime] 
    def ref()
      GDateTime.new Glib.g_date_time_ref(self)
    end
    
    # @param [Integer] timespan 
    # @return [GDateTime] 
    def add(timespan)
      GDateTime.new Glib.g_date_time_add(self, timespan)
    end
    
    # @param [Integer] years 
    # @return [GDateTime] 
    def add_years(years)
      GDateTime.new Glib.g_date_time_add_years(self, years)
    end
    
    # @param [Integer] months 
    # @return [GDateTime] 
    def add_months(months)
      GDateTime.new Glib.g_date_time_add_months(self, months)
    end
    
    # @param [Integer] weeks 
    # @return [GDateTime] 
    def add_weeks(weeks)
      GDateTime.new Glib.g_date_time_add_weeks(self, weeks)
    end
    
    # @param [Integer] days 
    # @return [GDateTime] 
    def add_days(days)
      GDateTime.new Glib.g_date_time_add_days(self, days)
    end
    
    # @param [Integer] hours 
    # @return [GDateTime] 
    def add_hours(hours)
      GDateTime.new Glib.g_date_time_add_hours(self, hours)
    end
    
    # @param [Integer] minutes 
    # @return [GDateTime] 
    def add_minutes(minutes)
      GDateTime.new Glib.g_date_time_add_minutes(self, minutes)
    end
    
    # @param [Float] seconds 
    # @return [GDateTime] 
    def add_seconds(seconds)
      GDateTime.new Glib.g_date_time_add_seconds(self, seconds)
    end
    
    # @param [Integer] years 
    # @param [Integer] months 
    # @param [Integer] days 
    # @param [Integer] hours 
    # @param [Integer] minutes 
    # @param [Float] seconds 
    # @return [GDateTime] 
    def add_full(years, months, days, hours, minutes, seconds)
      GDateTime.new Glib.g_date_time_add_full(self, years, months, days, hours, minutes, seconds)
    end
    
    # @param [FFI::Pointer(*GDateTime)] begin_ 
    # @return [Integer] 
    def difference(begin_)
      Glib.g_date_time_difference(self, begin_)
    end
    
    # @param [FFI::Pointer(*Gint)] year 
    # @param [FFI::Pointer(*Gint)] month 
    # @param [FFI::Pointer(*Gint)] day 
    # @return [nil] 
    def get_ymd(year, month, day)
      Glib.g_date_time_get_ymd(self, year, month, day)
    end
    
    # @return [Integer] 
    def get_year()
      Glib.g_date_time_get_year(self)
    end
    
    # @return [Integer] 
    def get_month()
      Glib.g_date_time_get_month(self)
    end
    
    # @return [Integer] 
    def get_day_of_month()
      Glib.g_date_time_get_day_of_month(self)
    end
    
    # @return [Integer] 
    def get_week_numbering_year()
      Glib.g_date_time_get_week_numbering_year(self)
    end
    
    # @return [Integer] 
    def get_week_of_year()
      Glib.g_date_time_get_week_of_year(self)
    end
    
    # @return [Integer] 
    def get_day_of_week()
      Glib.g_date_time_get_day_of_week(self)
    end
    
    # @return [Integer] 
    def get_day_of_year()
      Glib.g_date_time_get_day_of_year(self)
    end
    
    # @return [Integer] 
    def get_hour()
      Glib.g_date_time_get_hour(self)
    end
    
    # @return [Integer] 
    def get_minute()
      Glib.g_date_time_get_minute(self)
    end
    
    # @return [Integer] 
    def get_second()
      Glib.g_date_time_get_second(self)
    end
    
    # @return [Integer] 
    def get_microsecond()
      Glib.g_date_time_get_microsecond(self)
    end
    
    # @return [Float] 
    def get_seconds()
      Glib.g_date_time_get_seconds(self)
    end
    
    # @return [Integer] 
    def to_unix()
      Glib.g_date_time_to_unix(self)
    end
    
    # @param [GTimeVal] tv 
    # @return [Integer] 
    def to_timeval(tv)
      Glib.g_date_time_to_timeval(self, tv)
    end
    
    # @return [Integer] 
    def get_utc_offset()
      Glib.g_date_time_get_utc_offset(self)
    end
    
    # @return [String] 
    def get_timezone_abbreviation()
      Glib.g_date_time_get_timezone_abbreviation(self)
    end
    
    # @return [Integer] 
    def is_daylight_savings()
      Glib.g_date_time_is_daylight_savings(self)
    end
    
    # @param [GTimeZone] tz 
    # @return [GDateTime] 
    def to_timezone(tz)
      GDateTime.new Glib.g_date_time_to_timezone(self, tz)
    end
    
    # @return [GDateTime] 
    def to_local()
      GDateTime.new Glib.g_date_time_to_local(self)
    end
    
    # @return [GDateTime] 
    def to_utc()
      GDateTime.new Glib.g_date_time_to_utc(self)
    end
    
    # @param [String] format 
    # @return [String] 
    def format(format)
      Glib.g_date_time_format(self, format)
    end
  end
  
  class GDateTime < FFI::Struct
    include GDateTimeWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_date_time_unref(datetime)
  # @param [GDateTime] datetime 
  # @return [nil] 
  # @scope class
  attach_function :g_date_time_unref, :g_date_time_unref, [GDateTime], :void
  
  # (Not documented)
  # 
  # @method g_date_time_ref(datetime)
  # @param [GDateTime] datetime 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_ref, :g_date_time_ref, [GDateTime], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_now(tz)
  # @param [GTimeZone] tz 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_now, :g_date_time_new_now, [GTimeZone], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_now_local()
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_now_local, :g_date_time_new_now_local, [], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_now_utc()
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_now_utc, :g_date_time_new_now_utc, [], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_from_unix_local(t)
  # @param [Integer] t 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_from_unix_local, :g_date_time_new_from_unix_local, [:long_long], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_from_unix_utc(t)
  # @param [Integer] t 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_from_unix_utc, :g_date_time_new_from_unix_utc, [:long_long], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_from_timeval_local(tv)
  # @param [GTimeVal] tv 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_from_timeval_local, :g_date_time_new_from_timeval_local, [GTimeVal], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_from_timeval_utc(tv)
  # @param [GTimeVal] tv 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_from_timeval_utc, :g_date_time_new_from_timeval_utc, [GTimeVal], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new(tz, year, month, day, hour, minute, seconds)
  # @param [GTimeZone] tz 
  # @param [Integer] year 
  # @param [Integer] month 
  # @param [Integer] day 
  # @param [Integer] hour 
  # @param [Integer] minute 
  # @param [Float] seconds 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new, :g_date_time_new, [GTimeZone, :int, :int, :int, :int, :int, :double], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_local(year, month, day, hour, minute, seconds)
  # @param [Integer] year 
  # @param [Integer] month 
  # @param [Integer] day 
  # @param [Integer] hour 
  # @param [Integer] minute 
  # @param [Float] seconds 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_local, :g_date_time_new_local, [:int, :int, :int, :int, :int, :double], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_new_utc(year, month, day, hour, minute, seconds)
  # @param [Integer] year 
  # @param [Integer] month 
  # @param [Integer] day 
  # @param [Integer] hour 
  # @param [Integer] minute 
  # @param [Float] seconds 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_new_utc, :g_date_time_new_utc, [:int, :int, :int, :int, :int, :double], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add(datetime, timespan)
  # @param [GDateTime] datetime 
  # @param [Integer] timespan 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add, :g_date_time_add, [GDateTime, :long_long], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_years(datetime, years)
  # @param [GDateTime] datetime 
  # @param [Integer] years 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_years, :g_date_time_add_years, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_months(datetime, months)
  # @param [GDateTime] datetime 
  # @param [Integer] months 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_months, :g_date_time_add_months, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_weeks(datetime, weeks)
  # @param [GDateTime] datetime 
  # @param [Integer] weeks 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_weeks, :g_date_time_add_weeks, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_days(datetime, days)
  # @param [GDateTime] datetime 
  # @param [Integer] days 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_days, :g_date_time_add_days, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_hours(datetime, hours)
  # @param [GDateTime] datetime 
  # @param [Integer] hours 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_hours, :g_date_time_add_hours, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_minutes(datetime, minutes)
  # @param [GDateTime] datetime 
  # @param [Integer] minutes 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_minutes, :g_date_time_add_minutes, [GDateTime, :int], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_seconds(datetime, seconds)
  # @param [GDateTime] datetime 
  # @param [Float] seconds 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_seconds, :g_date_time_add_seconds, [GDateTime, :double], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_add_full(datetime, years, months, days, hours, minutes, seconds)
  # @param [GDateTime] datetime 
  # @param [Integer] years 
  # @param [Integer] months 
  # @param [Integer] days 
  # @param [Integer] hours 
  # @param [Integer] minutes 
  # @param [Float] seconds 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_add_full, :g_date_time_add_full, [GDateTime, :int, :int, :int, :int, :int, :double], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_compare(dt1, dt2)
  # @param [FFI::Pointer(Gconstpointer)] dt1 
  # @param [FFI::Pointer(Gconstpointer)] dt2 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_compare, :g_date_time_compare, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_date_time_difference(end_, begin_)
  # @param [GDateTime] end_ 
  # @param [GDateTime] begin_ 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_difference, :g_date_time_difference, [GDateTime, GDateTime], :long_long
  
  # (Not documented)
  # 
  # @method g_date_time_hash(datetime)
  # @param [FFI::Pointer(Gconstpointer)] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_hash, :g_date_time_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_date_time_equal(dt1, dt2)
  # @param [FFI::Pointer(Gconstpointer)] dt1 
  # @param [FFI::Pointer(Gconstpointer)] dt2 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_equal, :g_date_time_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_ymd(datetime, year, month, day)
  # @param [GDateTime] datetime 
  # @param [FFI::Pointer(*Gint)] year 
  # @param [FFI::Pointer(*Gint)] month 
  # @param [FFI::Pointer(*Gint)] day 
  # @return [nil] 
  # @scope class
  attach_function :g_date_time_get_ymd, :g_date_time_get_ymd, [GDateTime, :pointer, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_date_time_get_year(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_year, :g_date_time_get_year, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_month(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_month, :g_date_time_get_month, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_day_of_month(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_day_of_month, :g_date_time_get_day_of_month, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_week_numbering_year(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_week_numbering_year, :g_date_time_get_week_numbering_year, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_week_of_year(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_week_of_year, :g_date_time_get_week_of_year, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_day_of_week(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_day_of_week, :g_date_time_get_day_of_week, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_day_of_year(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_day_of_year, :g_date_time_get_day_of_year, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_hour(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_hour, :g_date_time_get_hour, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_minute(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_minute, :g_date_time_get_minute, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_second(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_second, :g_date_time_get_second, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_microsecond(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_microsecond, :g_date_time_get_microsecond, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_seconds(datetime)
  # @param [GDateTime] datetime 
  # @return [Float] 
  # @scope class
  attach_function :g_date_time_get_seconds, :g_date_time_get_seconds, [GDateTime], :double
  
  # (Not documented)
  # 
  # @method g_date_time_to_unix(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_to_unix, :g_date_time_to_unix, [GDateTime], :long_long
  
  # (Not documented)
  # 
  # @method g_date_time_to_timeval(datetime, tv)
  # @param [GDateTime] datetime 
  # @param [GTimeVal] tv 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_to_timeval, :g_date_time_to_timeval, [GDateTime, GTimeVal], :int
  
  # (Not documented)
  # 
  # @method g_date_time_get_utc_offset(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_get_utc_offset, :g_date_time_get_utc_offset, [GDateTime], :long_long
  
  # (Not documented)
  # 
  # @method g_date_time_get_timezone_abbreviation(datetime)
  # @param [GDateTime] datetime 
  # @return [String] 
  # @scope class
  attach_function :g_date_time_get_timezone_abbreviation, :g_date_time_get_timezone_abbreviation, [GDateTime], :string
  
  # (Not documented)
  # 
  # @method g_date_time_is_daylight_savings(datetime)
  # @param [GDateTime] datetime 
  # @return [Integer] 
  # @scope class
  attach_function :g_date_time_is_daylight_savings, :g_date_time_is_daylight_savings, [GDateTime], :int
  
  # (Not documented)
  # 
  # @method g_date_time_to_timezone(datetime, tz)
  # @param [GDateTime] datetime 
  # @param [GTimeZone] tz 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_to_timezone, :g_date_time_to_timezone, [GDateTime, GTimeZone], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_to_local(datetime)
  # @param [GDateTime] datetime 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_to_local, :g_date_time_to_local, [GDateTime], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_to_utc(datetime)
  # @param [GDateTime] datetime 
  # @return [GDateTime] 
  # @scope class
  attach_function :g_date_time_to_utc, :g_date_time_to_utc, [GDateTime], GDateTime
  
  # (Not documented)
  # 
  # @method g_date_time_format(datetime, format)
  # @param [GDateTime] datetime 
  # @param [String] format 
  # @return [String] 
  # @scope class
  attach_function :g_date_time_format, :g_date_time_format, [GDateTime, :string], :string
  
  # (Not documented)
  module GDirWrappers
    # @return [String] 
    def read_name_utf8()
      Glib.g_dir_read_name_utf8(self)
    end
    
    # @return [nil] 
    def rewind()
      Glib.g_dir_rewind(self)
    end
    
    # @return [nil] 
    def close()
      Glib.g_dir_close(self)
    end
  end
  
  class GDir < FFI::Struct
    include GDirWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_dir_open_utf8(path, flags, error)
  # @param [String] path 
  # @param [Integer] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GDir] 
  # @scope class
  attach_function :g_dir_open_utf8, :g_dir_open_utf8, [:string, :uint, :pointer], GDir
  
  # (Not documented)
  # 
  # @method g_dir_read_name_utf8(dir)
  # @param [GDir] dir 
  # @return [String] 
  # @scope class
  attach_function :g_dir_read_name_utf8, :g_dir_read_name_utf8, [GDir], :string
  
  # (Not documented)
  # 
  # @method g_dir_rewind(dir)
  # @param [GDir] dir 
  # @return [nil] 
  # @scope class
  attach_function :g_dir_rewind, :g_dir_rewind, [GDir], :void
  
  # (Not documented)
  # 
  # @method g_dir_close(dir)
  # @param [GDir] dir 
  # @return [nil] 
  # @scope class
  attach_function :g_dir_close, :g_dir_close, [GDir], :void
  
  # (Not documented)
  # 
  # @method g_getenv_utf8(variable)
  # @param [String] variable 
  # @return [String] 
  # @scope class
  attach_function :g_getenv_utf8, :g_getenv_utf8, [:string], :string
  
  # (Not documented)
  # 
  # @method g_setenv_utf8(variable, value, overwrite)
  # @param [String] variable 
  # @param [String] value 
  # @param [Integer] overwrite 
  # @return [Integer] 
  # @scope class
  attach_function :g_setenv_utf8, :g_setenv_utf8, [:string, :string, :int], :int
  
  # (Not documented)
  # 
  # @method g_unsetenv_utf8(variable)
  # @param [String] variable 
  # @return [nil] 
  # @scope class
  attach_function :g_unsetenv_utf8, :g_unsetenv_utf8, [:string], :void
  
  # (Not documented)
  # 
  # @method g_listenv()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_listenv, :g_listenv, [], :pointer
  
  # (Not documented)
  # 
  # @method g_get_environ()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_get_environ, :g_get_environ, [], :pointer
  
  # (Not documented)
  # 
  # @method g_environ_getenv(envp, variable)
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [String] variable 
  # @return [String] 
  # @scope class
  attach_function :g_environ_getenv, :g_environ_getenv, [:pointer, :string], :string
  
  # (Not documented)
  # 
  # @method g_environ_setenv(envp, variable, value, overwrite)
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [String] variable 
  # @param [String] value 
  # @param [Integer] overwrite 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_environ_setenv, :g_environ_setenv, [:pointer, :string, :string, :int], :pointer
  
  # (Not documented)
  # 
  # @method g_environ_unsetenv(envp, variable)
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [String] variable 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_environ_unsetenv, :g_environ_unsetenv, [:pointer, :string], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_file_error).</em>
  # 
  # === Options:
  # :exist ::
  #   
  # :isdir ::
  #   
  # :acces ::
  #   
  # :nametoolong ::
  #   
  # :noent ::
  #   
  # :notdir ::
  #   
  # :nxio ::
  #   
  # :nodev ::
  #   
  # :rofs ::
  #   
  # :txtbsy ::
  #   
  # :fault ::
  #   
  # :loop ::
  #   
  # :nospc ::
  #   
  # :nomem ::
  #   
  # :mfile ::
  #   
  # :nfile ::
  #   
  # :badf ::
  #   
  # :inval ::
  #   
  # :pipe ::
  #   
  # :again ::
  #   
  # :intr ::
  #   
  # :io ::
  #   
  # :perm ::
  #   
  # :nosys ::
  #   
  # :failed ::
  #   
  # 
  # @method _enum_g_file_error_
  # @return [Symbol]
  # @scope class
  enum :g_file_error, [
    :exist, 0,
    :isdir, 1,
    :acces, 2,
    :nametoolong, 3,
    :noent, 4,
    :notdir, 5,
    :nxio, 6,
    :nodev, 7,
    :rofs, 8,
    :txtbsy, 9,
    :fault, 10,
    :loop, 11,
    :nospc, 12,
    :nomem, 13,
    :mfile, 14,
    :nfile, 15,
    :badf, 16,
    :inval, 17,
    :pipe, 18,
    :again, 19,
    :intr, 20,
    :io, 21,
    :perm, 22,
    :nosys, 23,
    :failed, 24
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_file_test).</em>
  # 
  # === Options:
  # :is_regular ::
  #   
  # :is_symlink ::
  #   
  # :is_dir ::
  #   
  # :is_executable ::
  #   
  # :exists ::
  #   
  # 
  # @method _enum_g_file_test_
  # @return [Symbol]
  # @scope class
  enum :g_file_test, [
    :is_regular, 1,
    :is_symlink, 2,
    :is_dir, 4,
    :is_executable, 8,
    :exists, 16
  ]
  
  # (Not documented)
  # 
  # @method g_file_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_file_error_quark, :g_file_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_file_error_from_errno(err_no)
  # @param [Integer] err_no 
  # @return [Symbol from _enum_g_file_error_] 
  # @scope class
  attach_function :g_file_error_from_errno, :g_file_error_from_errno, [:int], :g_file_error
  
  # (Not documented)
  # 
  # @method g_file_test_utf8(filename, test)
  # @param [String] filename 
  # @param [Symbol from _enum_g_file_test_] test 
  # @return [Integer] 
  # @scope class
  attach_function :g_file_test_utf8, :g_file_test_utf8, [:string, :g_file_test], :int
  
  # (Not documented)
  # 
  # @method g_file_get_contents_utf8(filename, contents, length, error)
  # @param [String] filename 
  # @param [FFI::Pointer(**Gchar)] contents 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_file_get_contents_utf8, :g_file_get_contents_utf8, [:string, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_file_set_contents(filename, contents, length, error)
  # @param [String] filename 
  # @param [String] contents 
  # @param [Integer] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_file_set_contents, :g_file_set_contents, [:string, :string, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_file_read_link(filename, error)
  # @param [String] filename 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_file_read_link, :g_file_read_link, [:string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_mkdtemp(tmpl)
  # @param [String] tmpl 
  # @return [String] 
  # @scope class
  attach_function :g_mkdtemp, :g_mkdtemp, [:string], :string
  
  # (Not documented)
  # 
  # @method g_mkdtemp_full(tmpl, mode)
  # @param [String] tmpl 
  # @param [Integer] mode 
  # @return [String] 
  # @scope class
  attach_function :g_mkdtemp_full, :g_mkdtemp_full, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_mkstemp_utf8(tmpl)
  # @param [String] tmpl 
  # @return [Integer] 
  # @scope class
  attach_function :g_mkstemp_utf8, :g_mkstemp_utf8, [:string], :int
  
  # (Not documented)
  # 
  # @method g_mkstemp_full(tmpl, flags, mode)
  # @param [String] tmpl 
  # @param [Integer] flags 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_mkstemp_full, :g_mkstemp_full, [:string, :int, :int], :int
  
  # (Not documented)
  # 
  # @method g_file_open_tmp_utf8(tmpl, name_used, error)
  # @param [String] tmpl 
  # @param [FFI::Pointer(**Gchar)] name_used 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_file_open_tmp_utf8, :g_file_open_tmp_utf8, [:string, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_dir_make_tmp(tmpl, error)
  # @param [String] tmpl 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_dir_make_tmp, :g_dir_make_tmp, [:string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_build_path(separator, first_element)
  # @param [String] separator 
  # @param [String] first_element 
  # @return [String] 
  # @scope class
  attach_function :g_build_path, :g_build_path, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_build_pathv(separator, args)
  # @param [String] separator 
  # @param [FFI::Pointer(**Gchar)] args 
  # @return [String] 
  # @scope class
  attach_function :g_build_pathv, :g_build_pathv, [:string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_build_filename(first_element)
  # @param [String] first_element 
  # @return [String] 
  # @scope class
  attach_function :g_build_filename, :g_build_filename, [:string], :string
  
  # (Not documented)
  # 
  # @method g_build_filenamev(args)
  # @param [FFI::Pointer(**Gchar)] args 
  # @return [String] 
  # @scope class
  attach_function :g_build_filenamev, :g_build_filenamev, [:pointer], :string
  
  # (Not documented)
  # 
  # @method g_mkdir_with_parents(pathname, mode)
  # @param [String] pathname 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_mkdir_with_parents, :g_mkdir_with_parents, [:string, :int], :int
  
  # (Not documented)
  # 
  # @method g_path_is_absolute(file_name)
  # @param [String] file_name 
  # @return [Integer] 
  # @scope class
  attach_function :g_path_is_absolute, :g_path_is_absolute, [:string], :int
  
  # (Not documented)
  # 
  # @method g_path_skip_root(file_name)
  # @param [String] file_name 
  # @return [String] 
  # @scope class
  attach_function :g_path_skip_root, :g_path_skip_root, [:string], :string
  
  # (Not documented)
  # 
  # @method g_basename(file_name)
  # @param [String] file_name 
  # @return [String] 
  # @scope class
  attach_function :g_basename, :g_basename, [:string], :string
  
  # (Not documented)
  # 
  # @method g_get_current_dir_utf8()
  # @return [String] 
  # @scope class
  attach_function :g_get_current_dir_utf8, :g_get_current_dir_utf8, [], :string
  
  # (Not documented)
  # 
  # @method g_path_get_basename(file_name)
  # @param [String] file_name 
  # @return [String] 
  # @scope class
  attach_function :g_path_get_basename, :g_path_get_basename, [:string], :string
  
  # (Not documented)
  # 
  # @method g_path_get_dirname(file_name)
  # @param [String] file_name 
  # @return [String] 
  # @scope class
  attach_function :g_path_get_dirname, :g_path_get_dirname, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strip_context(msgid, msgval)
  # @param [String] msgid 
  # @param [String] msgval 
  # @return [String] 
  # @scope class
  attach_function :g_strip_context, :g_strip_context, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_dgettext(domain, msgid)
  # @param [String] domain 
  # @param [String] msgid 
  # @return [String] 
  # @scope class
  attach_function :g_dgettext, :g_dgettext, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_dcgettext(domain, msgid, category)
  # @param [String] domain 
  # @param [String] msgid 
  # @param [Integer] category 
  # @return [String] 
  # @scope class
  attach_function :g_dcgettext, :g_dcgettext, [:string, :string, :int], :string
  
  # (Not documented)
  # 
  # @method g_dngettext(domain, msgid, msgid_plural, n)
  # @param [String] domain 
  # @param [String] msgid 
  # @param [String] msgid_plural 
  # @param [Integer] n 
  # @return [String] 
  # @scope class
  attach_function :g_dngettext, :g_dngettext, [:string, :string, :string, :ulong], :string
  
  # (Not documented)
  # 
  # @method g_dpgettext(domain, msgctxtid, msgidoffset)
  # @param [String] domain 
  # @param [String] msgctxtid 
  # @param [Integer] msgidoffset 
  # @return [String] 
  # @scope class
  attach_function :g_dpgettext, :g_dpgettext, [:string, :string, :uint], :string
  
  # (Not documented)
  # 
  # @method g_dpgettext2(domain, context, msgid)
  # @param [String] domain 
  # @param [String] context 
  # @param [String] msgid 
  # @return [String] 
  # @scope class
  attach_function :g_dpgettext2, :g_dpgettext2, [:string, :string, :string], :string
  
  # (Not documented)
  # 
  # @method g_free(mem)
  # @param [FFI::Pointer(Gpointer)] mem 
  # @return [nil] 
  # @scope class
  attach_function :g_free, :g_free, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_clear_pointer(pp, destroy)
  # @param [FFI::Pointer(*Gpointer)] pp 
  # @param [FFI::Pointer(GDestroyNotify)] destroy 
  # @return [nil] 
  # @scope class
  attach_function :g_clear_pointer, :g_clear_pointer, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_malloc(n_bytes)
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_malloc, :g_malloc, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_malloc0(n_bytes)
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_malloc0, :g_malloc0, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_realloc(mem, n_bytes)
  # @param [FFI::Pointer(Gpointer)] mem 
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_realloc, :g_realloc, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_malloc(n_bytes)
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_malloc, :g_try_malloc, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_malloc0(n_bytes)
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_malloc0, :g_try_malloc0, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_realloc(mem, n_bytes)
  # @param [FFI::Pointer(Gpointer)] mem 
  # @param [Integer] n_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_realloc, :g_try_realloc, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_malloc_n(n_blocks, n_block_bytes)
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_malloc_n, :g_malloc_n, [:uint, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_malloc0_n(n_blocks, n_block_bytes)
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_malloc0_n, :g_malloc0_n, [:uint, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_realloc_n(mem, n_blocks, n_block_bytes)
  # @param [FFI::Pointer(Gpointer)] mem 
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_realloc_n, :g_realloc_n, [:pointer, :uint, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_malloc_n(n_blocks, n_block_bytes)
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_malloc_n, :g_try_malloc_n, [:uint, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_malloc0_n(n_blocks, n_block_bytes)
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_malloc0_n, :g_try_malloc0_n, [:uint, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_try_realloc_n(mem, n_blocks, n_block_bytes)
  # @param [FFI::Pointer(Gpointer)] mem 
  # @param [Integer] n_blocks 
  # @param [Integer] n_block_bytes 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_try_realloc_n, :g_try_realloc_n, [:pointer, :uint, :uint], :pointer
  
  # (Not documented)
  # 
  # = Fields:
  # :malloc ::
  #   (FFI::Pointer(*)) 
  # :realloc ::
  #   (FFI::Pointer(*)) 
  # :free ::
  #   (FFI::Pointer(*)) 
  # :calloc ::
  #   (FFI::Pointer(*)) optional; set to NULL if not used !
  # :try_malloc ::
  #   (FFI::Pointer(*)) 
  # :try_realloc ::
  #   (FFI::Pointer(*)) 
  class GMemVTable < FFI::Struct
    layout :malloc, :pointer,
           :realloc, :pointer,
           :free, :pointer,
           :calloc, :pointer,
           :try_malloc, :pointer,
           :try_realloc, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_mem_set_vtable(vtable)
  # @param [GMemVTable] vtable 
  # @return [nil] 
  # @scope class
  attach_function :g_mem_set_vtable, :g_mem_set_vtable, [GMemVTable], :void
  
  # (Not documented)
  # 
  # @method g_mem_is_system_malloc()
  # @return [Integer] 
  # @scope class
  attach_function :g_mem_is_system_malloc, :g_mem_is_system_malloc, [], :int
  
  # (Not documented)
  # 
  # @method g_mem_profile()
  # @return [nil] 
  # @scope class
  attach_function :g_mem_profile, :g_mem_profile, [], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_traverse_flags).</em>
  # 
  # === Options:
  # :leaves ::
  #   
  # :non_leaves ::
  #   
  # :mask ::
  #   
  # 
  # @method _enum_g_traverse_flags_
  # @return [Symbol]
  # @scope class
  enum :g_traverse_flags, [
    :leaves, 1,
    :non_leaves, 2,
    :mask, 3
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_traverse_type).</em>
  # 
  # === Options:
  # :in_order ::
  #   
  # :pre_order ::
  #   
  # :post_order ::
  #   
  # :level_order ::
  #   
  # 
  # @method _enum_g_traverse_type_
  # @return [Symbol]
  # @scope class
  enum :g_traverse_type, [
    :in_order, 0,
    :pre_order, 1,
    :post_order, 2,
    :level_order, 3
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_node_traverse_func_(node, data)
  # @param [FFI::Pointer(*GNode)] node 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_node_traverse_func, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_node_foreach_func_(data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [FFI::Pointer(*GNode)] 
  # @scope class
  callback :g_node_foreach_func, [:pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_copy_func_(src, data)
  # @param [FFI::Pointer(Gconstpointer)] src 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_copy_func, [:pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(Gpointer)) 
  # :next_ ::
  #   (FFI::Pointer(*GNode)) 
  # :prev ::
  #   (FFI::Pointer(*GNode)) 
  # :parent ::
  #   (FFI::Pointer(*GNode)) 
  # :children ::
  #   (FFI::Pointer(*GNode)) 
  module GNodeWrappers
    # @return [nil] 
    def destroy()
      Glib.g_node_destroy(self)
    end
    
    # @return [nil] 
    def unlink()
      Glib.g_node_unlink(self)
    end
    
    # @param [Proc(_callback_g_copy_func_)] copy_func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GNode] 
    def copy_deep(copy_func, data)
      GNode.new Glib.g_node_copy_deep(self, copy_func, data)
    end
    
    # @return [GNode] 
    def copy()
      GNode.new Glib.g_node_copy(self)
    end
    
    # @param [Integer] position 
    # @param [FFI::Pointer(*GNode)] node 
    # @return [GNode] 
    def insert(position, node)
      GNode.new Glib.g_node_insert(self, position, node)
    end
    
    # @param [FFI::Pointer(*GNode)] sibling 
    # @param [FFI::Pointer(*GNode)] node 
    # @return [GNode] 
    def insert_before(sibling, node)
      GNode.new Glib.g_node_insert_before(self, sibling, node)
    end
    
    # @param [FFI::Pointer(*GNode)] sibling 
    # @param [FFI::Pointer(*GNode)] node 
    # @return [GNode] 
    def insert_after(sibling, node)
      GNode.new Glib.g_node_insert_after(self, sibling, node)
    end
    
    # @param [FFI::Pointer(*GNode)] node 
    # @return [GNode] 
    def prepend(node)
      GNode.new Glib.g_node_prepend(self, node)
    end
    
    # @param [Symbol from _enum_g_traverse_flags_] flags 
    # @return [Integer] 
    def n_nodes(flags)
      Glib.g_node_n_nodes(self, flags)
    end
    
    # @return [GNode] 
    def get_root()
      GNode.new Glib.g_node_get_root(self)
    end
    
    # @param [FFI::Pointer(*GNode)] descendant 
    # @return [Integer] 
    def is_ancestor(descendant)
      Glib.g_node_is_ancestor(self, descendant)
    end
    
    # @return [Integer] 
    def depth()
      Glib.g_node_depth(self)
    end
    
    # @param [Symbol from _enum_g_traverse_type_] order 
    # @param [Symbol from _enum_g_traverse_flags_] flags 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GNode] 
    def find(order, flags, data)
      GNode.new Glib.g_node_find(self, order, flags, data)
    end
    
    # @param [Symbol from _enum_g_traverse_type_] order 
    # @param [Symbol from _enum_g_traverse_flags_] flags 
    # @param [Integer] max_depth 
    # @param [Proc(_callback_g_node_traverse_func_)] func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def traverse(order, flags, max_depth, func, data)
      Glib.g_node_traverse(self, order, flags, max_depth, func, data)
    end
    
    # @return [Integer] 
    def max_height()
      Glib.g_node_max_height(self)
    end
    
    # @param [Symbol from _enum_g_traverse_flags_] flags 
    # @param [Proc(_callback_g_node_foreach_func_)] func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def children_foreach(flags, func, data)
      Glib.g_node_children_foreach(self, flags, func, data)
    end
    
    # @return [nil] 
    def reverse_children()
      Glib.g_node_reverse_children(self)
    end
    
    # @return [Integer] 
    def n_children()
      Glib.g_node_n_children(self)
    end
    
    # @param [Integer] n 
    # @return [GNode] 
    def nth_child(n)
      GNode.new Glib.g_node_nth_child(self, n)
    end
    
    # @return [GNode] 
    def last_child()
      GNode.new Glib.g_node_last_child(self)
    end
    
    # @param [Symbol from _enum_g_traverse_flags_] flags 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GNode] 
    def find_child(flags, data)
      GNode.new Glib.g_node_find_child(self, flags, data)
    end
    
    # @param [FFI::Pointer(*GNode)] child 
    # @return [Integer] 
    def child_position(child)
      Glib.g_node_child_position(self, child)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [Integer] 
    def child_index(data)
      Glib.g_node_child_index(self, data)
    end
    
    # @return [GNode] 
    def first_sibling()
      GNode.new Glib.g_node_first_sibling(self)
    end
    
    # @return [GNode] 
    def last_sibling()
      GNode.new Glib.g_node_last_sibling(self)
    end
  end
  
  class GNode < FFI::Struct
    include GNodeWrappers
    layout :data, :pointer,
           :next_, :pointer,
           :prev, :pointer,
           :parent, :pointer,
           :children, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_node_new(data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_new, :g_node_new, [:pointer], GNode
  
  # (Not documented)
  # 
  # @method g_node_destroy(root)
  # @param [GNode] root 
  # @return [nil] 
  # @scope class
  attach_function :g_node_destroy, :g_node_destroy, [GNode], :void
  
  # (Not documented)
  # 
  # @method g_node_unlink(node)
  # @param [GNode] node 
  # @return [nil] 
  # @scope class
  attach_function :g_node_unlink, :g_node_unlink, [GNode], :void
  
  # (Not documented)
  # 
  # @method g_node_copy_deep(node, copy_func, data)
  # @param [GNode] node 
  # @param [Proc(_callback_g_copy_func_)] copy_func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_copy_deep, :g_node_copy_deep, [GNode, :g_copy_func, :pointer], GNode
  
  # (Not documented)
  # 
  # @method g_node_copy(node)
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_copy, :g_node_copy, [GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_insert(parent, position, node)
  # @param [GNode] parent 
  # @param [Integer] position 
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_insert, :g_node_insert, [GNode, :int, GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_insert_before(parent, sibling, node)
  # @param [GNode] parent 
  # @param [GNode] sibling 
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_insert_before, :g_node_insert_before, [GNode, GNode, GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_insert_after(parent, sibling, node)
  # @param [GNode] parent 
  # @param [GNode] sibling 
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_insert_after, :g_node_insert_after, [GNode, GNode, GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_prepend(parent, node)
  # @param [GNode] parent 
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_prepend, :g_node_prepend, [GNode, GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_n_nodes(root, flags)
  # @param [GNode] root 
  # @param [Symbol from _enum_g_traverse_flags_] flags 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_n_nodes, :g_node_n_nodes, [GNode, :g_traverse_flags], :uint
  
  # (Not documented)
  # 
  # @method g_node_get_root(node)
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_get_root, :g_node_get_root, [GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_is_ancestor(node, descendant)
  # @param [GNode] node 
  # @param [GNode] descendant 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_is_ancestor, :g_node_is_ancestor, [GNode, GNode], :int
  
  # (Not documented)
  # 
  # @method g_node_depth(node)
  # @param [GNode] node 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_depth, :g_node_depth, [GNode], :uint
  
  # (Not documented)
  # 
  # @method g_node_find(root, order, flags, data)
  # @param [GNode] root 
  # @param [Symbol from _enum_g_traverse_type_] order 
  # @param [Symbol from _enum_g_traverse_flags_] flags 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_find, :g_node_find, [GNode, :g_traverse_type, :g_traverse_flags, :pointer], GNode
  
  # (Not documented)
  # 
  # @method g_node_traverse(root, order, flags, max_depth, func, data)
  # @param [GNode] root 
  # @param [Symbol from _enum_g_traverse_type_] order 
  # @param [Symbol from _enum_g_traverse_flags_] flags 
  # @param [Integer] max_depth 
  # @param [Proc(_callback_g_node_traverse_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_node_traverse, :g_node_traverse, [GNode, :g_traverse_type, :g_traverse_flags, :int, :g_node_traverse_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_node_max_height(root)
  # @param [GNode] root 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_max_height, :g_node_max_height, [GNode], :uint
  
  # (Not documented)
  # 
  # @method g_node_children_foreach(node, flags, func, data)
  # @param [GNode] node 
  # @param [Symbol from _enum_g_traverse_flags_] flags 
  # @param [Proc(_callback_g_node_foreach_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_node_children_foreach, :g_node_children_foreach, [GNode, :g_traverse_flags, :g_node_foreach_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_node_reverse_children(node)
  # @param [GNode] node 
  # @return [nil] 
  # @scope class
  attach_function :g_node_reverse_children, :g_node_reverse_children, [GNode], :void
  
  # (Not documented)
  # 
  # @method g_node_n_children(node)
  # @param [GNode] node 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_n_children, :g_node_n_children, [GNode], :uint
  
  # (Not documented)
  # 
  # @method g_node_nth_child(node, n)
  # @param [GNode] node 
  # @param [Integer] n 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_nth_child, :g_node_nth_child, [GNode, :uint], GNode
  
  # (Not documented)
  # 
  # @method g_node_last_child(node)
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_last_child, :g_node_last_child, [GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_find_child(node, flags, data)
  # @param [GNode] node 
  # @param [Symbol from _enum_g_traverse_flags_] flags 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_find_child, :g_node_find_child, [GNode, :g_traverse_flags, :pointer], GNode
  
  # (Not documented)
  # 
  # @method g_node_child_position(node, child)
  # @param [GNode] node 
  # @param [GNode] child 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_child_position, :g_node_child_position, [GNode, GNode], :int
  
  # (Not documented)
  # 
  # @method g_node_child_index(node, data)
  # @param [GNode] node 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_node_child_index, :g_node_child_index, [GNode, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_node_first_sibling(node)
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_first_sibling, :g_node_first_sibling, [GNode], GNode
  
  # (Not documented)
  # 
  # @method g_node_last_sibling(node)
  # @param [GNode] node 
  # @return [GNode] 
  # @scope class
  attach_function :g_node_last_sibling, :g_node_last_sibling, [GNode], GNode
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(Gpointer)) 
  # :next_ ::
  #   (FFI::Pointer(*GList)) 
  # :prev ::
  #   (FFI::Pointer(*GList)) 
  module GListWrappers
    # @return [nil] 
    def free()
      Glib.g_list_free(self)
    end
    
    # @return [nil] 
    def free_1()
      Glib.g_list_free_1(self)
    end
    
    # @param [FFI::Pointer(GDestroyNotify)] free_func 
    # @return [nil] 
    def free_full(free_func)
      Glib.g_list_free_full(self, free_func)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GList] 
    def append(data)
      GList.new Glib.g_list_append(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GList] 
    def prepend(data)
      GList.new Glib.g_list_prepend(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Integer] position 
    # @return [GList] 
    def insert(data, position)
      GList.new Glib.g_list_insert(self, data, position)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_func_)] func 
    # @return [GList] 
    def insert_sorted(data, func)
      GList.new Glib.g_list_insert_sorted(self, data, func)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GList] 
    def insert_sorted_with_data(data, func, user_data)
      GList.new Glib.g_list_insert_sorted_with_data(self, data, func, user_data)
    end
    
    # @param [FFI::Pointer(*GList)] sibling 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GList] 
    def insert_before(sibling, data)
      GList.new Glib.g_list_insert_before(self, sibling, data)
    end
    
    # @param [FFI::Pointer(*GList)] list2 
    # @return [GList] 
    def concat(list2)
      GList.new Glib.g_list_concat(self, list2)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GList] 
    def remove(data)
      GList.new Glib.g_list_remove(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GList] 
    def remove_all(data)
      GList.new Glib.g_list_remove_all(self, data)
    end
    
    # @param [FFI::Pointer(*GList)] llink 
    # @return [GList] 
    def remove_link(llink)
      GList.new Glib.g_list_remove_link(self, llink)
    end
    
    # @param [FFI::Pointer(*GList)] link 
    # @return [GList] 
    def delete_link(link)
      GList.new Glib.g_list_delete_link(self, link)
    end
    
    # @return [GList] 
    def reverse()
      GList.new Glib.g_list_reverse(self)
    end
    
    # @return [GList] 
    def copy()
      GList.new Glib.g_list_copy(self)
    end
    
    # @param [Proc(_callback_g_copy_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GList] 
    def copy_deep(func, user_data)
      GList.new Glib.g_list_copy_deep(self, func, user_data)
    end
    
    # @param [Integer] n 
    # @return [GList] 
    def nth(n)
      GList.new Glib.g_list_nth(self, n)
    end
    
    # @param [Integer] n 
    # @return [GList] 
    def nth_prev(n)
      GList.new Glib.g_list_nth_prev(self, n)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GList] 
    def find(data)
      GList.new Glib.g_list_find(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Proc(_callback_g_compare_func_)] func 
    # @return [GList] 
    def find_custom(data, func)
      GList.new Glib.g_list_find_custom(self, data, func)
    end
    
    # @param [FFI::Pointer(*GList)] llink 
    # @return [Integer] 
    def position(llink)
      Glib.g_list_position(self, llink)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [Integer] 
    def index(data)
      Glib.g_list_index(self, data)
    end
    
    # @return [GList] 
    def last()
      GList.new Glib.g_list_last(self)
    end
    
    # @return [GList] 
    def first()
      GList.new Glib.g_list_first(self)
    end
    
    # @return [Integer] 
    def length()
      Glib.g_list_length(self)
    end
    
    # @param [Proc(_callback_g_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_list_foreach(self, func, user_data)
    end
    
    # @param [Proc(_callback_g_compare_func_)] compare_func 
    # @return [GList] 
    def sort(compare_func)
      GList.new Glib.g_list_sort(self, compare_func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GList] 
    def sort_with_data(compare_func, user_data)
      GList.new Glib.g_list_sort_with_data(self, compare_func, user_data)
    end
    
    # @param [Integer] n 
    # @return [FFI::Pointer(Gpointer)] 
    def nth_data(n)
      Glib.g_list_nth_data(self, n)
    end
  end
  
  class GList < FFI::Struct
    include GListWrappers
    layout :data, :pointer,
           :next_, :pointer,
           :prev, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_list_alloc()
  # @return [GList] 
  # @scope class
  attach_function :g_list_alloc, :g_list_alloc, [], GList
  
  # (Not documented)
  # 
  # @method g_list_free(list)
  # @param [GList] list 
  # @return [nil] 
  # @scope class
  attach_function :g_list_free, :g_list_free, [GList], :void
  
  # (Not documented)
  # 
  # @method g_list_free_1(list)
  # @param [GList] list 
  # @return [nil] 
  # @scope class
  attach_function :g_list_free_1, :g_list_free_1, [GList], :void
  
  # (Not documented)
  # 
  # @method g_list_free_full(list, free_func)
  # @param [GList] list 
  # @param [FFI::Pointer(GDestroyNotify)] free_func 
  # @return [nil] 
  # @scope class
  attach_function :g_list_free_full, :g_list_free_full, [GList, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_list_append(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_append, :g_list_append, [GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_prepend(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_prepend, :g_list_prepend, [GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_insert(list, data, position)
  # @param [GList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Integer] position 
  # @return [GList] 
  # @scope class
  attach_function :g_list_insert, :g_list_insert, [GList, :pointer, :int], GList
  
  # (Not documented)
  # 
  # @method g_list_insert_sorted(list, data, func)
  # @param [GList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_func_)] func 
  # @return [GList] 
  # @scope class
  attach_function :g_list_insert_sorted, :g_list_insert_sorted, [GList, :pointer, :g_compare_func], GList
  
  # (Not documented)
  # 
  # @method g_list_insert_sorted_with_data(list, data, func, user_data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_insert_sorted_with_data, :g_list_insert_sorted_with_data, [GList, :pointer, :g_compare_data_func, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_insert_before(list, sibling, data)
  # @param [GList] list 
  # @param [GList] sibling 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_insert_before, :g_list_insert_before, [GList, GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_concat(list1, list2)
  # @param [GList] list1 
  # @param [GList] list2 
  # @return [GList] 
  # @scope class
  attach_function :g_list_concat, :g_list_concat, [GList, GList], GList
  
  # (Not documented)
  # 
  # @method g_list_remove(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_remove, :g_list_remove, [GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_remove_all(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_remove_all, :g_list_remove_all, [GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_remove_link(list, llink)
  # @param [GList] list 
  # @param [GList] llink 
  # @return [GList] 
  # @scope class
  attach_function :g_list_remove_link, :g_list_remove_link, [GList, GList], GList
  
  # (Not documented)
  # 
  # @method g_list_delete_link(list, link)
  # @param [GList] list 
  # @param [GList] link 
  # @return [GList] 
  # @scope class
  attach_function :g_list_delete_link, :g_list_delete_link, [GList, GList], GList
  
  # (Not documented)
  # 
  # @method g_list_reverse(list)
  # @param [GList] list 
  # @return [GList] 
  # @scope class
  attach_function :g_list_reverse, :g_list_reverse, [GList], GList
  
  # (Not documented)
  # 
  # @method g_list_copy(list)
  # @param [GList] list 
  # @return [GList] 
  # @scope class
  attach_function :g_list_copy, :g_list_copy, [GList], GList
  
  # (Not documented)
  # 
  # @method g_list_copy_deep(list, func, user_data)
  # @param [GList] list 
  # @param [Proc(_callback_g_copy_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_copy_deep, :g_list_copy_deep, [GList, :g_copy_func, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_nth(list, n)
  # @param [GList] list 
  # @param [Integer] n 
  # @return [GList] 
  # @scope class
  attach_function :g_list_nth, :g_list_nth, [GList, :uint], GList
  
  # (Not documented)
  # 
  # @method g_list_nth_prev(list, n)
  # @param [GList] list 
  # @param [Integer] n 
  # @return [GList] 
  # @scope class
  attach_function :g_list_nth_prev, :g_list_nth_prev, [GList, :uint], GList
  
  # (Not documented)
  # 
  # @method g_list_find(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_find, :g_list_find, [GList, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_find_custom(list, data, func)
  # @param [GList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Proc(_callback_g_compare_func_)] func 
  # @return [GList] 
  # @scope class
  attach_function :g_list_find_custom, :g_list_find_custom, [GList, :pointer, :g_compare_func], GList
  
  # (Not documented)
  # 
  # @method g_list_position(list, llink)
  # @param [GList] list 
  # @param [GList] llink 
  # @return [Integer] 
  # @scope class
  attach_function :g_list_position, :g_list_position, [GList, GList], :int
  
  # (Not documented)
  # 
  # @method g_list_index(list, data)
  # @param [GList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_list_index, :g_list_index, [GList, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_list_last(list)
  # @param [GList] list 
  # @return [GList] 
  # @scope class
  attach_function :g_list_last, :g_list_last, [GList], GList
  
  # (Not documented)
  # 
  # @method g_list_first(list)
  # @param [GList] list 
  # @return [GList] 
  # @scope class
  attach_function :g_list_first, :g_list_first, [GList], GList
  
  # (Not documented)
  # 
  # @method g_list_length(list)
  # @param [GList] list 
  # @return [Integer] 
  # @scope class
  attach_function :g_list_length, :g_list_length, [GList], :uint
  
  # (Not documented)
  # 
  # @method g_list_foreach(list, func, user_data)
  # @param [GList] list 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_list_foreach, :g_list_foreach, [GList, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_list_sort(list, compare_func)
  # @param [GList] list 
  # @param [Proc(_callback_g_compare_func_)] compare_func 
  # @return [GList] 
  # @scope class
  attach_function :g_list_sort, :g_list_sort, [GList, :g_compare_func], GList
  
  # (Not documented)
  # 
  # @method g_list_sort_with_data(list, compare_func, user_data)
  # @param [GList] list 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GList] 
  # @scope class
  attach_function :g_list_sort_with_data, :g_list_sort_with_data, [GList, :g_compare_data_func, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_list_nth_data(list, n)
  # @param [GList] list 
  # @param [Integer] n 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_list_nth_data, :g_list_nth_data, [GList, :uint], :pointer
  
  # (Not documented)
  module GHashTableWrappers
    # @return [nil] 
    def destroy()
      Glib.g_hash_table_destroy(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] key 
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def insert(key, value)
      Glib.g_hash_table_insert(self, key, value)
    end
    
    # @param [FFI::Pointer(Gpointer)] key 
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def replace(key, value)
      Glib.g_hash_table_replace(self, key, value)
    end
    
    # @param [FFI::Pointer(Gpointer)] key 
    # @return [nil] 
    def add(key)
      Glib.g_hash_table_add(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [Integer] 
    def remove(key)
      Glib.g_hash_table_remove(self, key)
    end
    
    # @return [nil] 
    def remove_all()
      Glib.g_hash_table_remove_all(self)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [Integer] 
    def steal(key)
      Glib.g_hash_table_steal(self, key)
    end
    
    # @return [nil] 
    def steal_all()
      Glib.g_hash_table_steal_all(self)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [FFI::Pointer(Gpointer)] 
    def lookup(key)
      Glib.g_hash_table_lookup(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [Integer] 
    def contains(key)
      Glib.g_hash_table_contains(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] lookup_key 
    # @param [FFI::Pointer(*Gpointer)] orig_key 
    # @param [FFI::Pointer(*Gpointer)] value 
    # @return [Integer] 
    def lookup_extended(lookup_key, orig_key, value)
      Glib.g_hash_table_lookup_extended(self, lookup_key, orig_key, value)
    end
    
    # @param [Proc(_callback_gh_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_hash_table_foreach(self, func, user_data)
    end
    
    # @param [Proc(_callback_ghr_func_)] predicate 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [FFI::Pointer(Gpointer)] 
    def find(predicate, user_data)
      Glib.g_hash_table_find(self, predicate, user_data)
    end
    
    # @param [Proc(_callback_ghr_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [Integer] 
    def foreach_remove(func, user_data)
      Glib.g_hash_table_foreach_remove(self, func, user_data)
    end
    
    # @param [Proc(_callback_ghr_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [Integer] 
    def foreach_steal(func, user_data)
      Glib.g_hash_table_foreach_steal(self, func, user_data)
    end
    
    # @return [Integer] 
    def size()
      Glib.g_hash_table_size(self)
    end
    
    # @return [GList] 
    def get_keys()
      GList.new Glib.g_hash_table_get_keys(self)
    end
    
    # @return [GList] 
    def get_values()
      GList.new Glib.g_hash_table_get_values(self)
    end
    
    # @return [GHashTable] 
    def ref()
      GHashTable.new Glib.g_hash_table_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_hash_table_unref(self)
    end
  end
  
  class GHashTable < FFI::Struct
    include GHashTableWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_ghr_func_(key, value, user_data)
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :ghr_func, [:pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # = Fields:
  # :dummy1 ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :dummy2 ::
  #   (FFI::Pointer(Gpointer)) 
  # :dummy3 ::
  #   (FFI::Pointer(Gpointer)) 
  # :dummy4 ::
  #   (Integer) 
  # :dummy5 ::
  #   (Integer) 
  # :dummy6 ::
  #   (FFI::Pointer(Gpointer)) 
  module GHashTableIterWrappers
    # @param [GHashTable] hash_table 
    # @return [nil] 
    def init(hash_table)
      Glib.g_hash_table_iter_init(self, hash_table)
    end
    
    # @param [FFI::Pointer(*Gpointer)] key 
    # @param [FFI::Pointer(*Gpointer)] value 
    # @return [Integer] 
    def next_(key, value)
      Glib.g_hash_table_iter_next(self, key, value)
    end
    
    # @return [GHashTable] 
    def get_hash_table()
      GHashTable.new Glib.g_hash_table_iter_get_hash_table(self)
    end
    
    # @return [nil] 
    def remove()
      Glib.g_hash_table_iter_remove(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def replace(value)
      Glib.g_hash_table_iter_replace(self, value)
    end
    
    # @return [nil] 
    def steal()
      Glib.g_hash_table_iter_steal(self)
    end
  end
  
  class GHashTableIter < FFI::Struct
    include GHashTableIterWrappers
    layout :dummy1, :pointer,
           :dummy2, :pointer,
           :dummy3, :pointer,
           :dummy4, :int,
           :dummy5, :int,
           :dummy6, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_hash_table_new(hash_func, key_equal_func)
  # @param [Proc(_callback_g_hash_func_)] hash_func 
  # @param [Proc(_callback_g_equal_func_)] key_equal_func 
  # @return [GHashTable] 
  # @scope class
  attach_function :g_hash_table_new, :g_hash_table_new, [:g_hash_func, :g_equal_func], GHashTable
  
  # (Not documented)
  # 
  # @method g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, value_destroy_func)
  # @param [Proc(_callback_g_hash_func_)] hash_func 
  # @param [Proc(_callback_g_equal_func_)] key_equal_func 
  # @param [FFI::Pointer(GDestroyNotify)] key_destroy_func 
  # @param [FFI::Pointer(GDestroyNotify)] value_destroy_func 
  # @return [GHashTable] 
  # @scope class
  attach_function :g_hash_table_new_full, :g_hash_table_new_full, [:g_hash_func, :g_equal_func, :pointer, :pointer], GHashTable
  
  # (Not documented)
  # 
  # @method g_hash_table_destroy(hash_table)
  # @param [GHashTable] hash_table 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_destroy, :g_hash_table_destroy, [GHashTable], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_insert(hash_table, key, value)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_insert, :g_hash_table_insert, [GHashTable, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_replace(hash_table, key, value)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_replace, :g_hash_table_replace, [GHashTable, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_add(hash_table, key)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gpointer)] key 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_add, :g_hash_table_add, [GHashTable, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_remove(hash_table, key)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_remove, :g_hash_table_remove, [GHashTable, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_hash_table_remove_all(hash_table)
  # @param [GHashTable] hash_table 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_remove_all, :g_hash_table_remove_all, [GHashTable], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_steal(hash_table, key)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_steal, :g_hash_table_steal, [GHashTable, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_hash_table_steal_all(hash_table)
  # @param [GHashTable] hash_table 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_steal_all, :g_hash_table_steal_all, [GHashTable], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_lookup(hash_table, key)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_hash_table_lookup, :g_hash_table_lookup, [GHashTable, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_hash_table_contains(hash_table, key)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_contains, :g_hash_table_contains, [GHashTable, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value)
  # @param [GHashTable] hash_table 
  # @param [FFI::Pointer(Gconstpointer)] lookup_key 
  # @param [FFI::Pointer(*Gpointer)] orig_key 
  # @param [FFI::Pointer(*Gpointer)] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_lookup_extended, :g_hash_table_lookup_extended, [GHashTable, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_hash_table_foreach(hash_table, func, user_data)
  # @param [GHashTable] hash_table 
  # @param [Proc(_callback_gh_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_foreach, :g_hash_table_foreach, [GHashTable, :gh_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_find(hash_table, predicate, user_data)
  # @param [GHashTable] hash_table 
  # @param [Proc(_callback_ghr_func_)] predicate 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_hash_table_find, :g_hash_table_find, [GHashTable, :ghr_func, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_hash_table_foreach_remove(hash_table, func, user_data)
  # @param [GHashTable] hash_table 
  # @param [Proc(_callback_ghr_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_foreach_remove, :g_hash_table_foreach_remove, [GHashTable, :ghr_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_hash_table_foreach_steal(hash_table, func, user_data)
  # @param [GHashTable] hash_table 
  # @param [Proc(_callback_ghr_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_foreach_steal, :g_hash_table_foreach_steal, [GHashTable, :ghr_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_hash_table_size(hash_table)
  # @param [GHashTable] hash_table 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_size, :g_hash_table_size, [GHashTable], :uint
  
  # (Not documented)
  # 
  # @method g_hash_table_get_keys(hash_table)
  # @param [GHashTable] hash_table 
  # @return [GList] 
  # @scope class
  attach_function :g_hash_table_get_keys, :g_hash_table_get_keys, [GHashTable], GList
  
  # (Not documented)
  # 
  # @method g_hash_table_get_values(hash_table)
  # @param [GHashTable] hash_table 
  # @return [GList] 
  # @scope class
  attach_function :g_hash_table_get_values, :g_hash_table_get_values, [GHashTable], GList
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_init(iter, hash_table)
  # @param [GHashTableIter] iter 
  # @param [GHashTable] hash_table 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_iter_init, :g_hash_table_iter_init, [GHashTableIter, GHashTable], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_next(iter, key, value)
  # @param [GHashTableIter] iter 
  # @param [FFI::Pointer(*Gpointer)] key 
  # @param [FFI::Pointer(*Gpointer)] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_hash_table_iter_next, :g_hash_table_iter_next, [GHashTableIter, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_get_hash_table(iter)
  # @param [GHashTableIter] iter 
  # @return [GHashTable] 
  # @scope class
  attach_function :g_hash_table_iter_get_hash_table, :g_hash_table_iter_get_hash_table, [GHashTableIter], GHashTable
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_remove(iter)
  # @param [GHashTableIter] iter 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_iter_remove, :g_hash_table_iter_remove, [GHashTableIter], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_replace(iter, value)
  # @param [GHashTableIter] iter 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_iter_replace, :g_hash_table_iter_replace, [GHashTableIter, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_iter_steal(iter)
  # @param [GHashTableIter] iter 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_iter_steal, :g_hash_table_iter_steal, [GHashTableIter], :void
  
  # (Not documented)
  # 
  # @method g_hash_table_ref(hash_table)
  # @param [GHashTable] hash_table 
  # @return [GHashTable] 
  # @scope class
  attach_function :g_hash_table_ref, :g_hash_table_ref, [GHashTable], GHashTable
  
  # (Not documented)
  # 
  # @method g_hash_table_unref(hash_table)
  # @param [GHashTable] hash_table 
  # @return [nil] 
  # @scope class
  attach_function :g_hash_table_unref, :g_hash_table_unref, [GHashTable], :void
  
  # (Not documented)
  # 
  # @method g_str_equal(v1, v2)
  # @param [FFI::Pointer(Gconstpointer)] v1 
  # @param [FFI::Pointer(Gconstpointer)] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_str_equal, :g_str_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_str_hash(v)
  # @param [FFI::Pointer(Gconstpointer)] v 
  # @return [Integer] 
  # @scope class
  attach_function :g_str_hash, :g_str_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_int_equal(v1, v2)
  # @param [FFI::Pointer(Gconstpointer)] v1 
  # @param [FFI::Pointer(Gconstpointer)] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_int_equal, :g_int_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_int_hash(v)
  # @param [FFI::Pointer(Gconstpointer)] v 
  # @return [Integer] 
  # @scope class
  attach_function :g_int_hash, :g_int_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_int64_equal(v1, v2)
  # @param [FFI::Pointer(Gconstpointer)] v1 
  # @param [FFI::Pointer(Gconstpointer)] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_int64_equal, :g_int64_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_int64_hash(v)
  # @param [FFI::Pointer(Gconstpointer)] v 
  # @return [Integer] 
  # @scope class
  attach_function :g_int64_hash, :g_int64_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_double_equal(v1, v2)
  # @param [FFI::Pointer(Gconstpointer)] v1 
  # @param [FFI::Pointer(Gconstpointer)] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_double_equal, :g_double_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_double_hash(v)
  # @param [FFI::Pointer(Gconstpointer)] v 
  # @return [Integer] 
  # @scope class
  attach_function :g_double_hash, :g_double_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_direct_hash(v)
  # @param [FFI::Pointer(Gconstpointer)] v 
  # @return [Integer] 
  # @scope class
  attach_function :g_direct_hash, :g_direct_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_direct_equal(v1, v2)
  # @param [FFI::Pointer(Gconstpointer)] v1 
  # @param [FFI::Pointer(Gconstpointer)] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_direct_equal, :g_direct_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  module GHmacWrappers
    # @return [GHmac] 
    def copy()
      GHmac.new Glib.g_hmac_copy(self)
    end
    
    # @return [GHmac] 
    def ref()
      GHmac.new Glib.g_hmac_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_hmac_unref(self)
    end
    
    # @param [FFI::Pointer(*Guchar)] data 
    # @param [Integer] length 
    # @return [nil] 
    def update(data, length)
      Glib.g_hmac_update(self, data, length)
    end
    
    # @return [String] 
    def get_string()
      Glib.g_hmac_get_string(self)
    end
    
    # @param [FFI::Pointer(*Guint8)] buffer 
    # @param [FFI::Pointer(*Gsize)] digest_len 
    # @return [nil] 
    def get_digest(buffer, digest_len)
      Glib.g_hmac_get_digest(self, buffer, digest_len)
    end
  end
  
  class GHmac < FFI::Struct
    include GHmacWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_hmac_new(digest_type, key, key_len)
  # @param [Symbol from _enum_g_checksum_type_] digest_type 
  # @param [FFI::Pointer(*Guchar)] key 
  # @param [Integer] key_len 
  # @return [GHmac] 
  # @scope class
  attach_function :g_hmac_new, :g_hmac_new, [:g_checksum_type, :pointer, :uint], GHmac
  
  # (Not documented)
  # 
  # @method g_hmac_copy(hmac)
  # @param [GHmac] hmac 
  # @return [GHmac] 
  # @scope class
  attach_function :g_hmac_copy, :g_hmac_copy, [GHmac], GHmac
  
  # (Not documented)
  # 
  # @method g_hmac_ref(hmac)
  # @param [GHmac] hmac 
  # @return [GHmac] 
  # @scope class
  attach_function :g_hmac_ref, :g_hmac_ref, [GHmac], GHmac
  
  # (Not documented)
  # 
  # @method g_hmac_unref(hmac)
  # @param [GHmac] hmac 
  # @return [nil] 
  # @scope class
  attach_function :g_hmac_unref, :g_hmac_unref, [GHmac], :void
  
  # (Not documented)
  # 
  # @method g_hmac_update(hmac, data, length)
  # @param [GHmac] hmac 
  # @param [FFI::Pointer(*Guchar)] data 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_hmac_update, :g_hmac_update, [GHmac, :pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_hmac_get_string(hmac)
  # @param [GHmac] hmac 
  # @return [String] 
  # @scope class
  attach_function :g_hmac_get_string, :g_hmac_get_string, [GHmac], :string
  
  # (Not documented)
  # 
  # @method g_hmac_get_digest(hmac, buffer, digest_len)
  # @param [GHmac] hmac 
  # @param [FFI::Pointer(*Guint8)] buffer 
  # @param [FFI::Pointer(*Gsize)] digest_len 
  # @return [nil] 
  # @scope class
  attach_function :g_hmac_get_digest, :g_hmac_get_digest, [GHmac, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_compute_hmac_for_data(digest_type, key, key_len, data, length)
  # @param [Symbol from _enum_g_checksum_type_] digest_type 
  # @param [FFI::Pointer(*Guchar)] key 
  # @param [Integer] key_len 
  # @param [FFI::Pointer(*Guchar)] data 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_compute_hmac_for_data, :g_compute_hmac_for_data, [:g_checksum_type, :pointer, :uint, :pointer, :uint], :string
  
  # (Not documented)
  # 
  # @method g_compute_hmac_for_string(digest_type, key, key_len, str, length)
  # @param [Symbol from _enum_g_checksum_type_] digest_type 
  # @param [FFI::Pointer(*Guchar)] key 
  # @param [Integer] key_len 
  # @param [String] str 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_compute_hmac_for_string, :g_compute_hmac_for_string, [:g_checksum_type, :pointer, :uint, :string, :int], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_compare_func_(new_hook, sibling)
  # @param [FFI::Pointer(*GHook)] new_hook 
  # @param [FFI::Pointer(*GHook)] sibling 
  # @return [Integer] 
  # @scope class
  callback :g_hook_compare_func, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_find_func_(hook, data)
  # @param [FFI::Pointer(*GHook)] hook 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_hook_find_func, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_marshaller_(marshal_data)
  # @param [FFI::Pointer(Gpointer)] marshal_data 
  # @return [FFI::Pointer(*GHook)] 
  # @scope class
  callback :g_hook_marshaller, [:pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_check_marshaller_(hook, marshal_data)
  # @param [FFI::Pointer(*GHook)] hook 
  # @param [FFI::Pointer(Gpointer)] marshal_data 
  # @return [Integer] 
  # @scope class
  callback :g_hook_check_marshaller, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_check_func_(data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_hook_check_func, [:pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_hook_finalize_func_(hook)
  # @param [FFI::Pointer(*GHook)] hook 
  # @return [FFI::Pointer(*GHookList)] 
  # @scope class
  callback :g_hook_finalize_func, [:pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_hook_flag_mask).</em>
  # 
  # === Options:
  # :active ::
  #   
  # :in_call ::
  #   
  # :mask ::
  #   
  # 
  # @method _enum_g_hook_flag_mask_
  # @return [Symbol]
  # @scope class
  enum :g_hook_flag_mask, [
    :active, 1,
    :in_call, 2,
    :mask, 15
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :seq_id ::
  #   (Integer) 
  # :hook_size ::
  #   (Integer) 
  # :is_setup ::
  #   (Integer) 
  # :hooks ::
  #   (FFI::Pointer(*GHook)) 
  # :dummy3 ::
  #   (FFI::Pointer(Gpointer)) 
  # :finalize_hook ::
  #   (Proc(_callback_g_hook_finalize_func_)) 
  # :dummy ::
  #   (Array<FFI::Pointer(*Void)>) 
  module GHookListWrappers
    # @param [Integer] hook_size 
    # @return [nil] 
    def init(hook_size)
      Glib.g_hook_list_init(self, hook_size)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_hook_list_clear(self)
    end
    
    # @param [Integer] may_recurse 
    # @return [nil] 
    def invoke(may_recurse)
      Glib.g_hook_list_invoke(self, may_recurse)
    end
    
    # @param [Integer] may_recurse 
    # @return [nil] 
    def invoke_check(may_recurse)
      Glib.g_hook_list_invoke_check(self, may_recurse)
    end
    
    # @param [Integer] may_recurse 
    # @param [Proc(_callback_g_hook_marshaller_)] marshaller 
    # @param [FFI::Pointer(Gpointer)] marshal_data 
    # @return [nil] 
    def marshal(may_recurse, marshaller, marshal_data)
      Glib.g_hook_list_marshal(self, may_recurse, marshaller, marshal_data)
    end
    
    # @param [Integer] may_recurse 
    # @param [Proc(_callback_g_hook_check_marshaller_)] marshaller 
    # @param [FFI::Pointer(Gpointer)] marshal_data 
    # @return [nil] 
    def marshal_check(may_recurse, marshaller, marshal_data)
      Glib.g_hook_list_marshal_check(self, may_recurse, marshaller, marshal_data)
    end
  end
  
  class GHookList < FFI::Struct
    include GHookListWrappers
    layout :seq_id, :ulong,
           :hook_size, :uint,
           :is_setup, :uint,
           :hooks, :pointer,
           :dummy3, :pointer,
           :finalize_hook, :g_hook_finalize_func,
           :dummy, [:pointer, 2]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(Gpointer)) 
  # :next_ ::
  #   (FFI::Pointer(*GHook)) 
  # :prev ::
  #   (FFI::Pointer(*GHook)) 
  # :ref_count ::
  #   (Integer) 
  # :hook_id ::
  #   (Integer) 
  # :flags ::
  #   (Integer) 
  # :func ::
  #   (FFI::Pointer(Gpointer)) 
  # :destroy ::
  #   (FFI::Pointer(GDestroyNotify)) 
  module GHookWrappers
    # @param [FFI::Pointer(*GHook)] sibling 
    # @return [Integer] 
    def compare_ids(sibling)
      Glib.g_hook_compare_ids(self, sibling)
    end
  end
  
  class GHook < FFI::Struct
    include GHookWrappers
    layout :data, :pointer,
           :next_, :pointer,
           :prev, :pointer,
           :ref_count, :uint,
           :hook_id, :ulong,
           :flags, :uint,
           :func, :pointer,
           :destroy, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_hook_list_init(hook_list, hook_size)
  # @param [GHookList] hook_list 
  # @param [Integer] hook_size 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_init, :g_hook_list_init, [GHookList, :uint], :void
  
  # (Not documented)
  # 
  # @method g_hook_list_clear(hook_list)
  # @param [GHookList] hook_list 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_clear, :g_hook_list_clear, [GHookList], :void
  
  # (Not documented)
  # 
  # @method g_hook_alloc(hook_list)
  # @param [GHookList] hook_list 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_alloc, :g_hook_alloc, [GHookList], GHook
  
  # (Not documented)
  # 
  # @method g_hook_free(hook_list, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_free, :g_hook_free, [GHookList, GHook], :void
  
  # (Not documented)
  # 
  # @method g_hook_ref(hook_list, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_ref, :g_hook_ref, [GHookList, GHook], GHook
  
  # (Not documented)
  # 
  # @method g_hook_unref(hook_list, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_unref, :g_hook_unref, [GHookList, GHook], :void
  
  # (Not documented)
  # 
  # @method g_hook_destroy(hook_list, hook_id)
  # @param [GHookList] hook_list 
  # @param [Integer] hook_id 
  # @return [Integer] 
  # @scope class
  attach_function :g_hook_destroy, :g_hook_destroy, [GHookList, :ulong], :int
  
  # (Not documented)
  # 
  # @method g_hook_destroy_link(hook_list, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_destroy_link, :g_hook_destroy_link, [GHookList, GHook], :void
  
  # (Not documented)
  # 
  # @method g_hook_prepend(hook_list, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_prepend, :g_hook_prepend, [GHookList, GHook], :void
  
  # (Not documented)
  # 
  # @method g_hook_insert_before(hook_list, sibling, hook)
  # @param [GHookList] hook_list 
  # @param [GHook] sibling 
  # @param [GHook] hook 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_insert_before, :g_hook_insert_before, [GHookList, GHook, GHook], :void
  
  # (Not documented)
  # 
  # @method g_hook_insert_sorted(hook_list, hook, func)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @param [Proc(_callback_g_hook_compare_func_)] func 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_insert_sorted, :g_hook_insert_sorted, [GHookList, GHook, :g_hook_compare_func], :void
  
  # (Not documented)
  # 
  # @method g_hook_get(hook_list, hook_id)
  # @param [GHookList] hook_list 
  # @param [Integer] hook_id 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_get, :g_hook_get, [GHookList, :ulong], GHook
  
  # (Not documented)
  # 
  # @method g_hook_find(hook_list, need_valids, func, data)
  # @param [GHookList] hook_list 
  # @param [Integer] need_valids 
  # @param [Proc(_callback_g_hook_find_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_find, :g_hook_find, [GHookList, :int, :g_hook_find_func, :pointer], GHook
  
  # (Not documented)
  # 
  # @method g_hook_find_data(hook_list, need_valids, data)
  # @param [GHookList] hook_list 
  # @param [Integer] need_valids 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_find_data, :g_hook_find_data, [GHookList, :int, :pointer], GHook
  
  # (Not documented)
  # 
  # @method g_hook_find_func(hook_list, need_valids, func)
  # @param [GHookList] hook_list 
  # @param [Integer] need_valids 
  # @param [FFI::Pointer(Gpointer)] func 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_find_func, :g_hook_find_func, [GHookList, :int, :pointer], GHook
  
  # (Not documented)
  # 
  # @method g_hook_find_func_data(hook_list, need_valids, func, data)
  # @param [GHookList] hook_list 
  # @param [Integer] need_valids 
  # @param [FFI::Pointer(Gpointer)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_find_func_data, :g_hook_find_func_data, [GHookList, :int, :pointer, :pointer], GHook
  
  # (Not documented)
  # 
  # @method g_hook_first_valid(hook_list, may_be_in_call)
  # @param [GHookList] hook_list 
  # @param [Integer] may_be_in_call 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_first_valid, :g_hook_first_valid, [GHookList, :int], GHook
  
  # (Not documented)
  # 
  # @method g_hook_next_valid(hook_list, hook, may_be_in_call)
  # @param [GHookList] hook_list 
  # @param [GHook] hook 
  # @param [Integer] may_be_in_call 
  # @return [GHook] 
  # @scope class
  attach_function :g_hook_next_valid, :g_hook_next_valid, [GHookList, GHook, :int], GHook
  
  # (Not documented)
  # 
  # @method g_hook_compare_ids(new_hook, sibling)
  # @param [GHook] new_hook 
  # @param [GHook] sibling 
  # @return [Integer] 
  # @scope class
  attach_function :g_hook_compare_ids, :g_hook_compare_ids, [GHook, GHook], :int
  
  # (Not documented)
  # 
  # @method g_hook_list_invoke(hook_list, may_recurse)
  # @param [GHookList] hook_list 
  # @param [Integer] may_recurse 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_invoke, :g_hook_list_invoke, [GHookList, :int], :void
  
  # (Not documented)
  # 
  # @method g_hook_list_invoke_check(hook_list, may_recurse)
  # @param [GHookList] hook_list 
  # @param [Integer] may_recurse 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_invoke_check, :g_hook_list_invoke_check, [GHookList, :int], :void
  
  # (Not documented)
  # 
  # @method g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data)
  # @param [GHookList] hook_list 
  # @param [Integer] may_recurse 
  # @param [Proc(_callback_g_hook_marshaller_)] marshaller 
  # @param [FFI::Pointer(Gpointer)] marshal_data 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_marshal, :g_hook_list_marshal, [GHookList, :int, :g_hook_marshaller, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marshal_data)
  # @param [GHookList] hook_list 
  # @param [Integer] may_recurse 
  # @param [Proc(_callback_g_hook_check_marshaller_)] marshaller 
  # @param [FFI::Pointer(Gpointer)] marshal_data 
  # @return [nil] 
  # @scope class
  attach_function :g_hook_list_marshal_check, :g_hook_list_marshal_check, [GHookList, :int, :g_hook_check_marshaller, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_hostname_is_non_ascii(hostname)
  # @param [String] hostname 
  # @return [Integer] 
  # @scope class
  attach_function :g_hostname_is_non_ascii, :g_hostname_is_non_ascii, [:string], :int
  
  # (Not documented)
  # 
  # @method g_hostname_is_ascii_encoded(hostname)
  # @param [String] hostname 
  # @return [Integer] 
  # @scope class
  attach_function :g_hostname_is_ascii_encoded, :g_hostname_is_ascii_encoded, [:string], :int
  
  # (Not documented)
  # 
  # @method g_hostname_is_ip_address(hostname)
  # @param [String] hostname 
  # @return [Integer] 
  # @scope class
  attach_function :g_hostname_is_ip_address, :g_hostname_is_ip_address, [:string], :int
  
  # (Not documented)
  # 
  # @method g_hostname_to_ascii(hostname)
  # @param [String] hostname 
  # @return [String] 
  # @scope class
  attach_function :g_hostname_to_ascii, :g_hostname_to_ascii, [:string], :string
  
  # (Not documented)
  # 
  # @method g_hostname_to_unicode(hostname)
  # @param [String] hostname 
  # @return [String] 
  # @scope class
  attach_function :g_hostname_to_unicode, :g_hostname_to_unicode, [:string], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_poll_func_(ufds, nfsd, timeout)
  # @param [FFI::Pointer(*GPollFD)] ufds 
  # @param [Integer] nfsd 
  # @param [Integer] timeout 
  # @return [Integer] 
  # @scope class
  callback :g_poll_func, [:pointer, :uint, :int], :int
  
  # (Not documented)
  # 
  # = Fields:
  # :fd ::
  #   (Integer) 
  # :events ::
  #   (Integer) 
  # :revents ::
  #   (Integer) 
  class GPollFD < FFI::Struct
    layout :fd, :int,
           :events, :ushort,
           :revents, :ushort
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(Gpointer)) 
  # :next_ ::
  #   (FFI::Pointer(*GSList)) 
  module GSListWrappers
    # @return [nil] 
    def free()
      Glib.g_slist_free(self)
    end
    
    # @return [nil] 
    def free_1()
      Glib.g_slist_free_1(self)
    end
    
    # @param [FFI::Pointer(GDestroyNotify)] free_func 
    # @return [nil] 
    def free_full(free_func)
      Glib.g_slist_free_full(self, free_func)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GSList] 
    def append(data)
      GSList.new Glib.g_slist_append(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GSList] 
    def prepend(data)
      GSList.new Glib.g_slist_prepend(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Integer] position 
    # @return [GSList] 
    def insert(data, position)
      GSList.new Glib.g_slist_insert(self, data, position)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_func_)] func 
    # @return [GSList] 
    def insert_sorted(data, func)
      GSList.new Glib.g_slist_insert_sorted(self, data, func)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GSList] 
    def insert_sorted_with_data(data, func, user_data)
      GSList.new Glib.g_slist_insert_sorted_with_data(self, data, func, user_data)
    end
    
    # @param [FFI::Pointer(*GSList)] sibling 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GSList] 
    def insert_before(sibling, data)
      GSList.new Glib.g_slist_insert_before(self, sibling, data)
    end
    
    # @param [FFI::Pointer(*GSList)] list2 
    # @return [GSList] 
    def concat(list2)
      GSList.new Glib.g_slist_concat(self, list2)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GSList] 
    def remove(data)
      GSList.new Glib.g_slist_remove(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GSList] 
    def remove_all(data)
      GSList.new Glib.g_slist_remove_all(self, data)
    end
    
    # @param [FFI::Pointer(*GSList)] link 
    # @return [GSList] 
    def remove_link(link)
      GSList.new Glib.g_slist_remove_link(self, link)
    end
    
    # @param [FFI::Pointer(*GSList)] link 
    # @return [GSList] 
    def delete_link(link)
      GSList.new Glib.g_slist_delete_link(self, link)
    end
    
    # @return [GSList] 
    def reverse()
      GSList.new Glib.g_slist_reverse(self)
    end
    
    # @return [GSList] 
    def copy()
      GSList.new Glib.g_slist_copy(self)
    end
    
    # @param [Proc(_callback_g_copy_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GSList] 
    def copy_deep(func, user_data)
      GSList.new Glib.g_slist_copy_deep(self, func, user_data)
    end
    
    # @param [Integer] n 
    # @return [GSList] 
    def nth(n)
      GSList.new Glib.g_slist_nth(self, n)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GSList] 
    def find(data)
      GSList.new Glib.g_slist_find(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Proc(_callback_g_compare_func_)] func 
    # @return [GSList] 
    def find_custom(data, func)
      GSList.new Glib.g_slist_find_custom(self, data, func)
    end
    
    # @param [FFI::Pointer(*GSList)] llink 
    # @return [Integer] 
    def position(llink)
      Glib.g_slist_position(self, llink)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [Integer] 
    def index(data)
      Glib.g_slist_index(self, data)
    end
    
    # @return [GSList] 
    def last()
      GSList.new Glib.g_slist_last(self)
    end
    
    # @return [Integer] 
    def length()
      Glib.g_slist_length(self)
    end
    
    # @param [Proc(_callback_g_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_slist_foreach(self, func, user_data)
    end
    
    # @param [Proc(_callback_g_compare_func_)] compare_func 
    # @return [GSList] 
    def sort(compare_func)
      GSList.new Glib.g_slist_sort(self, compare_func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GSList] 
    def sort_with_data(compare_func, user_data)
      GSList.new Glib.g_slist_sort_with_data(self, compare_func, user_data)
    end
    
    # @param [Integer] n 
    # @return [FFI::Pointer(Gpointer)] 
    def nth_data(n)
      Glib.g_slist_nth_data(self, n)
    end
  end
  
  class GSList < FFI::Struct
    include GSListWrappers
    layout :data, :pointer,
           :next_, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_slist_alloc()
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_alloc, :g_slist_alloc, [], GSList
  
  # (Not documented)
  # 
  # @method g_slist_free(list)
  # @param [GSList] list 
  # @return [nil] 
  # @scope class
  attach_function :g_slist_free, :g_slist_free, [GSList], :void
  
  # (Not documented)
  # 
  # @method g_slist_free_1(list)
  # @param [GSList] list 
  # @return [nil] 
  # @scope class
  attach_function :g_slist_free_1, :g_slist_free_1, [GSList], :void
  
  # (Not documented)
  # 
  # @method g_slist_free_full(list, free_func)
  # @param [GSList] list 
  # @param [FFI::Pointer(GDestroyNotify)] free_func 
  # @return [nil] 
  # @scope class
  attach_function :g_slist_free_full, :g_slist_free_full, [GSList, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_slist_append(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_append, :g_slist_append, [GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_prepend(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_prepend, :g_slist_prepend, [GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_insert(list, data, position)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Integer] position 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_insert, :g_slist_insert, [GSList, :pointer, :int], GSList
  
  # (Not documented)
  # 
  # @method g_slist_insert_sorted(list, data, func)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_func_)] func 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_insert_sorted, :g_slist_insert_sorted, [GSList, :pointer, :g_compare_func], GSList
  
  # (Not documented)
  # 
  # @method g_slist_insert_sorted_with_data(list, data, func, user_data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_insert_sorted_with_data, :g_slist_insert_sorted_with_data, [GSList, :pointer, :g_compare_data_func, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_insert_before(slist, sibling, data)
  # @param [GSList] slist 
  # @param [GSList] sibling 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_insert_before, :g_slist_insert_before, [GSList, GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_concat(list1, list2)
  # @param [GSList] list1 
  # @param [GSList] list2 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_concat, :g_slist_concat, [GSList, GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_remove(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_remove, :g_slist_remove, [GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_remove_all(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_remove_all, :g_slist_remove_all, [GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_remove_link(list, link)
  # @param [GSList] list 
  # @param [GSList] link 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_remove_link, :g_slist_remove_link, [GSList, GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_delete_link(list, link)
  # @param [GSList] list 
  # @param [GSList] link 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_delete_link, :g_slist_delete_link, [GSList, GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_reverse(list)
  # @param [GSList] list 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_reverse, :g_slist_reverse, [GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_copy(list)
  # @param [GSList] list 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_copy, :g_slist_copy, [GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_copy_deep(list, func, user_data)
  # @param [GSList] list 
  # @param [Proc(_callback_g_copy_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_copy_deep, :g_slist_copy_deep, [GSList, :g_copy_func, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_nth(list, n)
  # @param [GSList] list 
  # @param [Integer] n 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_nth, :g_slist_nth, [GSList, :uint], GSList
  
  # (Not documented)
  # 
  # @method g_slist_find(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_find, :g_slist_find, [GSList, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_find_custom(list, data, func)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Proc(_callback_g_compare_func_)] func 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_find_custom, :g_slist_find_custom, [GSList, :pointer, :g_compare_func], GSList
  
  # (Not documented)
  # 
  # @method g_slist_position(list, llink)
  # @param [GSList] list 
  # @param [GSList] llink 
  # @return [Integer] 
  # @scope class
  attach_function :g_slist_position, :g_slist_position, [GSList, GSList], :int
  
  # (Not documented)
  # 
  # @method g_slist_index(list, data)
  # @param [GSList] list 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_slist_index, :g_slist_index, [GSList, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_slist_last(list)
  # @param [GSList] list 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_last, :g_slist_last, [GSList], GSList
  
  # (Not documented)
  # 
  # @method g_slist_length(list)
  # @param [GSList] list 
  # @return [Integer] 
  # @scope class
  attach_function :g_slist_length, :g_slist_length, [GSList], :uint
  
  # (Not documented)
  # 
  # @method g_slist_foreach(list, func, user_data)
  # @param [GSList] list 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_slist_foreach, :g_slist_foreach, [GSList, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_slist_sort(list, compare_func)
  # @param [GSList] list 
  # @param [Proc(_callback_g_compare_func_)] compare_func 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_sort, :g_slist_sort, [GSList, :g_compare_func], GSList
  
  # (Not documented)
  # 
  # @method g_slist_sort_with_data(list, compare_func, user_data)
  # @param [GSList] list 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GSList] 
  # @scope class
  attach_function :g_slist_sort_with_data, :g_slist_sort_with_data, [GSList, :g_compare_data_func, :pointer], GSList
  
  # (Not documented)
  # 
  # @method g_slist_nth_data(list, n)
  # @param [GSList] list 
  # @param [Integer] n 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_slist_nth_data, :g_slist_nth_data, [GSList, :uint], :pointer
  
  # (Not documented)
  module GMainContextWrappers
    # @return [GMainContext] 
    def ref()
      GMainContext.new Glib.g_main_context_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_main_context_unref(self)
    end
    
    # @param [Integer] may_block 
    # @return [Integer] 
    def iteration(may_block)
      Glib.g_main_context_iteration(self, may_block)
    end
    
    # @return [Integer] 
    def pending()
      Glib.g_main_context_pending(self)
    end
    
    # @param [Integer] source_id 
    # @return [GSource] 
    def find_source_by_id(source_id)
      GSource.new Glib.g_main_context_find_source_by_id(self, source_id)
    end
    
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GSource] 
    def find_source_by_user_data(user_data)
      GSource.new Glib.g_main_context_find_source_by_user_data(self, user_data)
    end
    
    # @param [FFI::Pointer(*GSourceFuncs)] funcs 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [GSource] 
    def find_source_by_funcs_user_data(funcs, user_data)
      GSource.new Glib.g_main_context_find_source_by_funcs_user_data(self, funcs, user_data)
    end
    
    # @return [nil] 
    def wakeup()
      Glib.g_main_context_wakeup(self)
    end
    
    # @return [Integer] 
    def acquire()
      Glib.g_main_context_acquire(self)
    end
    
    # @return [nil] 
    def release()
      Glib.g_main_context_release(self)
    end
    
    # @return [Integer] 
    def is_owner()
      Glib.g_main_context_is_owner(self)
    end
    
    # @param [GCond] cond 
    # @param [GMutex] mutex 
    # @return [Integer] 
    def wait(cond, mutex)
      Glib.g_main_context_wait(self, cond, mutex)
    end
    
    # @param [FFI::Pointer(*Gint)] priority 
    # @return [Integer] 
    def prepare(priority)
      Glib.g_main_context_prepare(self, priority)
    end
    
    # @param [Integer] max_priority 
    # @param [FFI::Pointer(*Gint)] timeout 
    # @param [GPollFD] fds 
    # @param [Integer] n_fds 
    # @return [Integer] 
    def query(max_priority, timeout, fds, n_fds)
      Glib.g_main_context_query(self, max_priority, timeout, fds, n_fds)
    end
    
    # @param [Integer] max_priority 
    # @param [GPollFD] fds 
    # @param [Integer] n_fds 
    # @return [Integer] 
    def check(max_priority, fds, n_fds)
      Glib.g_main_context_check(self, max_priority, fds, n_fds)
    end
    
    # @return [nil] 
    def dispatch()
      Glib.g_main_context_dispatch(self)
    end
    
    # @param [Proc(_callback_g_poll_func_)] func 
    # @return [nil] 
    def set_poll_func(func)
      Glib.g_main_context_set_poll_func(self, func)
    end
    
    # @return [Proc(_callback_g_poll_func_)] 
    def get_poll_func()
      Glib.g_main_context_get_poll_func(self)
    end
    
    # @param [GPollFD] fd 
    # @param [Integer] priority 
    # @return [nil] 
    def add_poll(fd, priority)
      Glib.g_main_context_add_poll(self, fd, priority)
    end
    
    # @param [GPollFD] fd 
    # @return [nil] 
    def remove_poll(fd)
      Glib.g_main_context_remove_poll(self, fd)
    end
    
    # @return [nil] 
    def push_thread_default()
      Glib.g_main_context_push_thread_default(self)
    end
    
    # @return [nil] 
    def pop_thread_default()
      Glib.g_main_context_pop_thread_default(self)
    end
    
    # @param [Integer] priority 
    # @param [Proc(_callback_g_source_func_)] function 
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [FFI::Pointer(GDestroyNotify)] notify 
    # @return [nil] 
    def invoke_full(priority, function, data, notify)
      Glib.g_main_context_invoke_full(self, priority, function, data, notify)
    end
    
    # @param [Proc(_callback_g_source_func_)] function 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def invoke(function, data)
      Glib.g_main_context_invoke(self, function, data)
    end
  end
  
  class GMainContext < FFI::Struct
    include GMainContextWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  module GMainLoopWrappers
    # @return [nil] 
    def run()
      Glib.g_main_loop_run(self)
    end
    
    # @return [nil] 
    def quit()
      Glib.g_main_loop_quit(self)
    end
    
    # @return [GMainLoop] 
    def ref()
      GMainLoop.new Glib.g_main_loop_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_main_loop_unref(self)
    end
    
    # @return [Integer] 
    def is_running()
      Glib.g_main_loop_is_running(self)
    end
    
    # @return [GMainContext] 
    def get_context()
      GMainContext.new Glib.g_main_loop_get_context(self)
    end
  end
  
  class GMainLoop < FFI::Struct
    include GMainLoopWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  class GSourcePrivate < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_source_func_(user_data)
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :g_source_func, [:pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_child_watch_func_(status, user_data)
  # @param [Integer] status 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [FFI::Pointer(GPid)] 
  # @scope class
  callback :g_child_watch_func, [:int, :pointer], :pointer
  
  # (Not documented)
  # 
  # = Fields:
  # :callback_data ::
  #   (FFI::Pointer(Gpointer)) < private >
  # :callback_funcs ::
  #   (FFI::Pointer(*GSourceCallbackFuncs)) 
  # :source_funcs ::
  #   (FFI::Pointer(*GSourceFuncs)) 
  # :ref_count ::
  #   (Integer) 
  # :context ::
  #   (GMainContext) 
  # :priority ::
  #   (Integer) 
  # :flags ::
  #   (Integer) 
  # :source_id ::
  #   (Integer) 
  # :poll_fds ::
  #   (GSList) 
  # :prev ::
  #   (FFI::Pointer(*GSource)) 
  # :next_ ::
  #   (FFI::Pointer(*GSource)) 
  # :name ::
  #   (String) 
  # :priv ::
  #   (GSourcePrivate) 
  module GSourceWrappers
    # @return [GSource] 
    def ref()
      GSource.new Glib.g_source_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_source_unref(self)
    end
    
    # @param [GMainContext] context 
    # @return [Integer] 
    def attach(context)
      Glib.g_source_attach(self, context)
    end
    
    # @return [nil] 
    def destroy()
      Glib.g_source_destroy(self)
    end
    
    # @param [Integer] priority 
    # @return [nil] 
    def set_priority(priority)
      Glib.g_source_set_priority(self, priority)
    end
    
    # @return [Integer] 
    def get_priority()
      Glib.g_source_get_priority(self)
    end
    
    # @param [Integer] can_recurse 
    # @return [nil] 
    def set_can_recurse(can_recurse)
      Glib.g_source_set_can_recurse(self, can_recurse)
    end
    
    # @return [Integer] 
    def get_can_recurse()
      Glib.g_source_get_can_recurse(self)
    end
    
    # @return [Integer] 
    def get_id()
      Glib.g_source_get_id(self)
    end
    
    # @return [GMainContext] 
    def get_context()
      GMainContext.new Glib.g_source_get_context(self)
    end
    
    # @param [Proc(_callback_g_source_func_)] func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [FFI::Pointer(GDestroyNotify)] notify 
    # @return [nil] 
    def set_callback(func, data, notify)
      Glib.g_source_set_callback(self, func, data, notify)
    end
    
    # @param [FFI::Pointer(*GSourceFuncs)] funcs 
    # @return [nil] 
    def set_funcs(funcs)
      Glib.g_source_set_funcs(self, funcs)
    end
    
    # @return [Integer] 
    def is_destroyed()
      Glib.g_source_is_destroyed(self)
    end
    
    # @param [String] name 
    # @return [nil] 
    def set_name(name)
      Glib.g_source_set_name(self, name)
    end
    
    # @return [String] 
    def get_name()
      Glib.g_source_get_name(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] callback_data 
    # @param [FFI::Pointer(*GSourceCallbackFuncs)] callback_funcs 
    # @return [nil] 
    def set_callback_indirect(callback_data, callback_funcs)
      Glib.g_source_set_callback_indirect(self, callback_data, callback_funcs)
    end
    
    # @param [GPollFD] fd 
    # @return [nil] 
    def add_poll(fd)
      Glib.g_source_add_poll(self, fd)
    end
    
    # @param [GPollFD] fd 
    # @return [nil] 
    def remove_poll(fd)
      Glib.g_source_remove_poll(self, fd)
    end
    
    # @param [FFI::Pointer(*GSource)] child_source 
    # @return [nil] 
    def add_child_source(child_source)
      Glib.g_source_add_child_source(self, child_source)
    end
    
    # @param [FFI::Pointer(*GSource)] child_source 
    # @return [nil] 
    def remove_child_source(child_source)
      Glib.g_source_remove_child_source(self, child_source)
    end
    
    # @param [GTimeVal] timeval 
    # @return [nil] 
    def get_current_time(timeval)
      Glib.g_source_get_current_time(self, timeval)
    end
    
    # @return [Integer] 
    def get_time()
      Glib.g_source_get_time(self)
    end
  end
  
  class GSource < FFI::Struct
    include GSourceWrappers
    layout :callback_data, :pointer,
           :callback_funcs, :pointer,
           :source_funcs, :pointer,
           :ref_count, :uint,
           :context, GMainContext,
           :priority, :int,
           :flags, :uint,
           :source_id, :uint,
           :poll_fds, GSList,
           :prev, :pointer,
           :next_, :pointer,
           :name, :string,
           :priv, GSourcePrivate
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :ref ::
  #   (FFI::Pointer(*)) 
  # :unref ::
  #   (FFI::Pointer(*)) 
  # :get ::
  #   (FFI::Pointer(*)) 
  class GSourceCallbackFuncs < FFI::Struct
    layout :ref, :pointer,
           :unref, :pointer,
           :get, :pointer
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :prepare ::
  #   (FFI::Pointer(*)) 
  # :check ::
  #   (FFI::Pointer(*)) 
  # :dispatch ::
  #   (FFI::Pointer(*)) 
  # :finalize ::
  #   (FFI::Pointer(*)) Can be NULL
  # :closure_callback ::
  #   (Proc(_callback_g_source_func_)) For use by g_source_set_closure
  # :closure_marshal ::
  #   (FFI::Pointer(GSourceDummyMarshal)) Really is of type GClosureMarshal
  class GSourceFuncs < FFI::Struct
    layout :prepare, :pointer,
           :check, :pointer,
           :dispatch, :pointer,
           :finalize, :pointer,
           :closure_callback, :g_source_func,
           :closure_marshal, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_main_context_new()
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_context_new, :g_main_context_new, [], GMainContext
  
  # (Not documented)
  # 
  # @method g_main_context_ref(context)
  # @param [GMainContext] context 
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_context_ref, :g_main_context_ref, [GMainContext], GMainContext
  
  # (Not documented)
  # 
  # @method g_main_context_unref(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_unref, :g_main_context_unref, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_default()
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_context_default, :g_main_context_default, [], GMainContext
  
  # (Not documented)
  # 
  # @method g_main_context_iteration(context, may_block)
  # @param [GMainContext] context 
  # @param [Integer] may_block 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_iteration, :g_main_context_iteration, [GMainContext, :int], :int
  
  # (Not documented)
  # 
  # @method g_main_context_pending(context)
  # @param [GMainContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_pending, :g_main_context_pending, [GMainContext], :int
  
  # (Not documented)
  # 
  # @method g_main_context_find_source_by_id(context, source_id)
  # @param [GMainContext] context 
  # @param [Integer] source_id 
  # @return [GSource] 
  # @scope class
  attach_function :g_main_context_find_source_by_id, :g_main_context_find_source_by_id, [GMainContext, :uint], GSource
  
  # (Not documented)
  # 
  # @method g_main_context_find_source_by_user_data(context, user_data)
  # @param [GMainContext] context 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GSource] 
  # @scope class
  attach_function :g_main_context_find_source_by_user_data, :g_main_context_find_source_by_user_data, [GMainContext, :pointer], GSource
  
  # (Not documented)
  # 
  # @method g_main_context_find_source_by_funcs_user_data(context, funcs, user_data)
  # @param [GMainContext] context 
  # @param [GSourceFuncs] funcs 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GSource] 
  # @scope class
  attach_function :g_main_context_find_source_by_funcs_user_data, :g_main_context_find_source_by_funcs_user_data, [GMainContext, GSourceFuncs, :pointer], GSource
  
  # (Not documented)
  # 
  # @method g_main_context_wakeup(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_wakeup, :g_main_context_wakeup, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_acquire(context)
  # @param [GMainContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_acquire, :g_main_context_acquire, [GMainContext], :int
  
  # (Not documented)
  # 
  # @method g_main_context_release(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_release, :g_main_context_release, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_is_owner(context)
  # @param [GMainContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_is_owner, :g_main_context_is_owner, [GMainContext], :int
  
  # (Not documented)
  # 
  # @method g_main_context_wait(context, cond, mutex)
  # @param [GMainContext] context 
  # @param [GCond] cond 
  # @param [GMutex] mutex 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_wait, :g_main_context_wait, [GMainContext, GCond, GMutex], :int
  
  # (Not documented)
  # 
  # @method g_main_context_prepare(context, priority)
  # @param [GMainContext] context 
  # @param [FFI::Pointer(*Gint)] priority 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_prepare, :g_main_context_prepare, [GMainContext, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_main_context_query(context, max_priority, timeout, fds, n_fds)
  # @param [GMainContext] context 
  # @param [Integer] max_priority 
  # @param [FFI::Pointer(*Gint)] timeout 
  # @param [GPollFD] fds 
  # @param [Integer] n_fds 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_query, :g_main_context_query, [GMainContext, :int, :pointer, GPollFD, :int], :int
  
  # (Not documented)
  # 
  # @method g_main_context_check(context, max_priority, fds, n_fds)
  # @param [GMainContext] context 
  # @param [Integer] max_priority 
  # @param [GPollFD] fds 
  # @param [Integer] n_fds 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_context_check, :g_main_context_check, [GMainContext, :int, GPollFD, :int], :int
  
  # (Not documented)
  # 
  # @method g_main_context_dispatch(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_dispatch, :g_main_context_dispatch, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_set_poll_func(context, func)
  # @param [GMainContext] context 
  # @param [Proc(_callback_g_poll_func_)] func 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_set_poll_func, :g_main_context_set_poll_func, [GMainContext, :g_poll_func], :void
  
  # (Not documented)
  # 
  # @method g_main_context_get_poll_func(context)
  # @param [GMainContext] context 
  # @return [Proc(_callback_g_poll_func_)] 
  # @scope class
  attach_function :g_main_context_get_poll_func, :g_main_context_get_poll_func, [GMainContext], :g_poll_func
  
  # (Not documented)
  # 
  # @method g_main_context_add_poll(context, fd, priority)
  # @param [GMainContext] context 
  # @param [GPollFD] fd 
  # @param [Integer] priority 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_add_poll, :g_main_context_add_poll, [GMainContext, GPollFD, :int], :void
  
  # (Not documented)
  # 
  # @method g_main_context_remove_poll(context, fd)
  # @param [GMainContext] context 
  # @param [GPollFD] fd 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_remove_poll, :g_main_context_remove_poll, [GMainContext, GPollFD], :void
  
  # (Not documented)
  # 
  # @method g_main_depth()
  # @return [Integer] 
  # @scope class
  attach_function :g_main_depth, :g_main_depth, [], :int
  
  # (Not documented)
  # 
  # @method g_main_current_source()
  # @return [GSource] 
  # @scope class
  attach_function :g_main_current_source, :g_main_current_source, [], GSource
  
  # (Not documented)
  # 
  # @method g_main_context_push_thread_default(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_push_thread_default, :g_main_context_push_thread_default, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_pop_thread_default(context)
  # @param [GMainContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_pop_thread_default, :g_main_context_pop_thread_default, [GMainContext], :void
  
  # (Not documented)
  # 
  # @method g_main_context_get_thread_default()
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_context_get_thread_default, :g_main_context_get_thread_default, [], GMainContext
  
  # (Not documented)
  # 
  # @method g_main_context_ref_thread_default()
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_context_ref_thread_default, :g_main_context_ref_thread_default, [], GMainContext
  
  # (Not documented)
  # 
  # @method g_main_loop_new(context, is_running)
  # @param [GMainContext] context 
  # @param [Integer] is_running 
  # @return [GMainLoop] 
  # @scope class
  attach_function :g_main_loop_new, :g_main_loop_new, [GMainContext, :int], GMainLoop
  
  # (Not documented)
  # 
  # @method g_main_loop_run(loop)
  # @param [GMainLoop] loop 
  # @return [nil] 
  # @scope class
  attach_function :g_main_loop_run, :g_main_loop_run, [GMainLoop], :void
  
  # (Not documented)
  # 
  # @method g_main_loop_quit(loop)
  # @param [GMainLoop] loop 
  # @return [nil] 
  # @scope class
  attach_function :g_main_loop_quit, :g_main_loop_quit, [GMainLoop], :void
  
  # (Not documented)
  # 
  # @method g_main_loop_ref(loop)
  # @param [GMainLoop] loop 
  # @return [GMainLoop] 
  # @scope class
  attach_function :g_main_loop_ref, :g_main_loop_ref, [GMainLoop], GMainLoop
  
  # (Not documented)
  # 
  # @method g_main_loop_unref(loop)
  # @param [GMainLoop] loop 
  # @return [nil] 
  # @scope class
  attach_function :g_main_loop_unref, :g_main_loop_unref, [GMainLoop], :void
  
  # (Not documented)
  # 
  # @method g_main_loop_is_running(loop)
  # @param [GMainLoop] loop 
  # @return [Integer] 
  # @scope class
  attach_function :g_main_loop_is_running, :g_main_loop_is_running, [GMainLoop], :int
  
  # (Not documented)
  # 
  # @method g_main_loop_get_context(loop)
  # @param [GMainLoop] loop 
  # @return [GMainContext] 
  # @scope class
  attach_function :g_main_loop_get_context, :g_main_loop_get_context, [GMainLoop], GMainContext
  
  # (Not documented)
  # 
  # @method g_source_new(source_funcs, struct_size)
  # @param [GSourceFuncs] source_funcs 
  # @param [Integer] struct_size 
  # @return [GSource] 
  # @scope class
  attach_function :g_source_new, :g_source_new, [GSourceFuncs, :uint], GSource
  
  # (Not documented)
  # 
  # @method g_source_ref(source)
  # @param [GSource] source 
  # @return [GSource] 
  # @scope class
  attach_function :g_source_ref, :g_source_ref, [GSource], GSource
  
  # (Not documented)
  # 
  # @method g_source_unref(source)
  # @param [GSource] source 
  # @return [nil] 
  # @scope class
  attach_function :g_source_unref, :g_source_unref, [GSource], :void
  
  # (Not documented)
  # 
  # @method g_source_attach(source, context)
  # @param [GSource] source 
  # @param [GMainContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_attach, :g_source_attach, [GSource, GMainContext], :uint
  
  # (Not documented)
  # 
  # @method g_source_destroy(source)
  # @param [GSource] source 
  # @return [nil] 
  # @scope class
  attach_function :g_source_destroy, :g_source_destroy, [GSource], :void
  
  # (Not documented)
  # 
  # @method g_source_set_priority(source, priority)
  # @param [GSource] source 
  # @param [Integer] priority 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_priority, :g_source_set_priority, [GSource, :int], :void
  
  # (Not documented)
  # 
  # @method g_source_get_priority(source)
  # @param [GSource] source 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_get_priority, :g_source_get_priority, [GSource], :int
  
  # (Not documented)
  # 
  # @method g_source_set_can_recurse(source, can_recurse)
  # @param [GSource] source 
  # @param [Integer] can_recurse 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_can_recurse, :g_source_set_can_recurse, [GSource, :int], :void
  
  # (Not documented)
  # 
  # @method g_source_get_can_recurse(source)
  # @param [GSource] source 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_get_can_recurse, :g_source_get_can_recurse, [GSource], :int
  
  # (Not documented)
  # 
  # @method g_source_get_id(source)
  # @param [GSource] source 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_get_id, :g_source_get_id, [GSource], :uint
  
  # (Not documented)
  # 
  # @method g_source_get_context(source)
  # @param [GSource] source 
  # @return [GMainContext] 
  # @scope class
  attach_function :g_source_get_context, :g_source_get_context, [GSource], GMainContext
  
  # (Not documented)
  # 
  # @method g_source_set_callback(source, func, data, notify)
  # @param [GSource] source 
  # @param [Proc(_callback_g_source_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_callback, :g_source_set_callback, [GSource, :g_source_func, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_source_set_funcs(source, funcs)
  # @param [GSource] source 
  # @param [GSourceFuncs] funcs 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_funcs, :g_source_set_funcs, [GSource, GSourceFuncs], :void
  
  # (Not documented)
  # 
  # @method g_source_is_destroyed(source)
  # @param [GSource] source 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_is_destroyed, :g_source_is_destroyed, [GSource], :int
  
  # (Not documented)
  # 
  # @method g_source_set_name(source, name)
  # @param [GSource] source 
  # @param [String] name 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_name, :g_source_set_name, [GSource, :string], :void
  
  # (Not documented)
  # 
  # @method g_source_get_name(source)
  # @param [GSource] source 
  # @return [String] 
  # @scope class
  attach_function :g_source_get_name, :g_source_get_name, [GSource], :string
  
  # (Not documented)
  # 
  # @method g_source_set_name_by_id(tag, name)
  # @param [Integer] tag 
  # @param [String] name 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_name_by_id, :g_source_set_name_by_id, [:uint, :string], :void
  
  # (Not documented)
  # 
  # @method g_source_set_callback_indirect(source, callback_data, callback_funcs)
  # @param [GSource] source 
  # @param [FFI::Pointer(Gpointer)] callback_data 
  # @param [GSourceCallbackFuncs] callback_funcs 
  # @return [nil] 
  # @scope class
  attach_function :g_source_set_callback_indirect, :g_source_set_callback_indirect, [GSource, :pointer, GSourceCallbackFuncs], :void
  
  # (Not documented)
  # 
  # @method g_source_add_poll(source, fd)
  # @param [GSource] source 
  # @param [GPollFD] fd 
  # @return [nil] 
  # @scope class
  attach_function :g_source_add_poll, :g_source_add_poll, [GSource, GPollFD], :void
  
  # (Not documented)
  # 
  # @method g_source_remove_poll(source, fd)
  # @param [GSource] source 
  # @param [GPollFD] fd 
  # @return [nil] 
  # @scope class
  attach_function :g_source_remove_poll, :g_source_remove_poll, [GSource, GPollFD], :void
  
  # (Not documented)
  # 
  # @method g_source_add_child_source(source, child_source)
  # @param [GSource] source 
  # @param [GSource] child_source 
  # @return [nil] 
  # @scope class
  attach_function :g_source_add_child_source, :g_source_add_child_source, [GSource, GSource], :void
  
  # (Not documented)
  # 
  # @method g_source_remove_child_source(source, child_source)
  # @param [GSource] source 
  # @param [GSource] child_source 
  # @return [nil] 
  # @scope class
  attach_function :g_source_remove_child_source, :g_source_remove_child_source, [GSource, GSource], :void
  
  # (Not documented)
  # 
  # @method g_source_get_current_time(source, timeval)
  # @param [GSource] source 
  # @param [GTimeVal] timeval 
  # @return [nil] 
  # @scope class
  attach_function :g_source_get_current_time, :g_source_get_current_time, [GSource, GTimeVal], :void
  
  # (Not documented)
  # 
  # @method g_source_get_time(source)
  # @param [GSource] source 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_get_time, :g_source_get_time, [GSource], :long_long
  
  # (Not documented)
  # 
  # @method g_idle_source_new()
  # @return [GSource] 
  # @scope class
  attach_function :g_idle_source_new, :g_idle_source_new, [], GSource
  
  # (Not documented)
  # 
  # @method g_child_watch_source_new(pid)
  # @param [FFI::Pointer(GPid)] pid 
  # @return [GSource] 
  # @scope class
  attach_function :g_child_watch_source_new, :g_child_watch_source_new, [:pointer], GSource
  
  # (Not documented)
  # 
  # @method g_timeout_source_new(interval)
  # @param [Integer] interval 
  # @return [GSource] 
  # @scope class
  attach_function :g_timeout_source_new, :g_timeout_source_new, [:uint], GSource
  
  # (Not documented)
  # 
  # @method g_timeout_source_new_seconds(interval)
  # @param [Integer] interval 
  # @return [GSource] 
  # @scope class
  attach_function :g_timeout_source_new_seconds, :g_timeout_source_new_seconds, [:uint], GSource
  
  # (Not documented)
  # 
  # @method g_get_current_time(result)
  # @param [GTimeVal] result 
  # @return [nil] 
  # @scope class
  attach_function :g_get_current_time, :g_get_current_time, [GTimeVal], :void
  
  # (Not documented)
  # 
  # @method g_get_monotonic_time()
  # @return [Integer] 
  # @scope class
  attach_function :g_get_monotonic_time, :g_get_monotonic_time, [], :long_long
  
  # (Not documented)
  # 
  # @method g_get_real_time()
  # @return [Integer] 
  # @scope class
  attach_function :g_get_real_time, :g_get_real_time, [], :long_long
  
  # (Not documented)
  # 
  # @method g_source_remove(tag)
  # @param [Integer] tag 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_remove, :g_source_remove, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_source_remove_by_user_data(user_data)
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_remove_by_user_data, :g_source_remove_by_user_data, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_source_remove_by_funcs_user_data(funcs, user_data)
  # @param [GSourceFuncs] funcs 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_source_remove_by_funcs_user_data, :g_source_remove_by_funcs_user_data, [GSourceFuncs, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_timeout_add_full(priority, interval, function, data, notify)
  # @param [Integer] priority 
  # @param [Integer] interval 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [Integer] 
  # @scope class
  attach_function :g_timeout_add_full, :g_timeout_add_full, [:int, :uint, :g_source_func, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_timeout_add(interval, function, data)
  # @param [Integer] interval 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_timeout_add, :g_timeout_add, [:uint, :g_source_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_timeout_add_seconds_full(priority, interval, function, data, notify)
  # @param [Integer] priority 
  # @param [Integer] interval 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [Integer] 
  # @scope class
  attach_function :g_timeout_add_seconds_full, :g_timeout_add_seconds_full, [:int, :uint, :g_source_func, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_timeout_add_seconds(interval, function, data)
  # @param [Integer] interval 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_timeout_add_seconds, :g_timeout_add_seconds, [:uint, :g_source_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_child_watch_add_full(priority, pid, function, data, notify)
  # @param [Integer] priority 
  # @param [FFI::Pointer(GPid)] pid 
  # @param [Proc(_callback_g_child_watch_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [Integer] 
  # @scope class
  attach_function :g_child_watch_add_full, :g_child_watch_add_full, [:int, :pointer, :g_child_watch_func, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_child_watch_add(pid, function, data)
  # @param [FFI::Pointer(GPid)] pid 
  # @param [Proc(_callback_g_child_watch_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_child_watch_add, :g_child_watch_add, [:pointer, :g_child_watch_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_idle_add(function, data)
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_idle_add, :g_idle_add, [:g_source_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_idle_add_full(priority, function, data, notify)
  # @param [Integer] priority 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [Integer] 
  # @scope class
  attach_function :g_idle_add_full, :g_idle_add_full, [:int, :g_source_func, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_idle_remove_by_data(data)
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_idle_remove_by_data, :g_idle_remove_by_data, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_main_context_invoke_full(context, priority, function, data, notify)
  # @param [GMainContext] context 
  # @param [Integer] priority 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_invoke_full, :g_main_context_invoke_full, [GMainContext, :int, :g_source_func, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_main_context_invoke(context, function, data)
  # @param [GMainContext] context 
  # @param [Proc(_callback_g_source_func_)] function 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_main_context_invoke, :g_main_context_invoke, [GMainContext, :g_source_func, :pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_unicode_type).</em>
  # 
  # === Options:
  # :control ::
  #   
  # :format ::
  #   
  # :unassigned ::
  #   
  # :private_use ::
  #   
  # :surrogate ::
  #   
  # :lowercase_letter ::
  #   
  # :modifier_letter ::
  #   
  # :other_letter ::
  #   
  # :titlecase_letter ::
  #   
  # :uppercase_letter ::
  #   
  # :spacing_mark ::
  #   
  # :enclosing_mark ::
  #   
  # :non_spacing_mark ::
  #   
  # :decimal_number ::
  #   
  # :letter_number ::
  #   
  # :other_number ::
  #   
  # :connect_punctuation ::
  #   
  # :dash_punctuation ::
  #   
  # :close_punctuation ::
  #   
  # :final_punctuation ::
  #   
  # :initial_punctuation ::
  #   
  # :other_punctuation ::
  #   
  # :open_punctuation ::
  #   
  # :currency_symbol ::
  #   
  # :modifier_symbol ::
  #   
  # :math_symbol ::
  #   
  # :other_symbol ::
  #   
  # :line_separator ::
  #   
  # :paragraph_separator ::
  #   
  # :space_separator ::
  #   
  # 
  # @method _enum_g_unicode_type_
  # @return [Symbol]
  # @scope class
  enum :g_unicode_type, [
    :control, 0,
    :format, 1,
    :unassigned, 2,
    :private_use, 3,
    :surrogate, 4,
    :lowercase_letter, 5,
    :modifier_letter, 6,
    :other_letter, 7,
    :titlecase_letter, 8,
    :uppercase_letter, 9,
    :spacing_mark, 10,
    :enclosing_mark, 11,
    :non_spacing_mark, 12,
    :decimal_number, 13,
    :letter_number, 14,
    :other_number, 15,
    :connect_punctuation, 16,
    :dash_punctuation, 17,
    :close_punctuation, 18,
    :final_punctuation, 19,
    :initial_punctuation, 20,
    :other_punctuation, 21,
    :open_punctuation, 22,
    :currency_symbol, 23,
    :modifier_symbol, 24,
    :math_symbol, 25,
    :other_symbol, 26,
    :line_separator, 27,
    :paragraph_separator, 28,
    :space_separator, 29
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_unicode_break_type).</em>
  # 
  # === Options:
  # :mandatory ::
  #   
  # :carriage_return ::
  #   
  # :line_feed ::
  #   
  # :combining_mark ::
  #   
  # :surrogate ::
  #   
  # :zero_width_space ::
  #   
  # :inseparable ::
  #   
  # :non_breaking_glue ::
  #   
  # :contingent ::
  #   
  # :space ::
  #   
  # :after ::
  #   
  # :before ::
  #   
  # :before_and_after ::
  #   
  # :hyphen ::
  #   
  # :non_starter ::
  #   
  # :open_punctuation ::
  #   
  # :close_punctuation ::
  #   
  # :quotation ::
  #   
  # :exclamation ::
  #   
  # :ideographic ::
  #   
  # :numeric ::
  #   
  # :infix_separator ::
  #   
  # :symbol ::
  #   
  # :alphabetic ::
  #   
  # :prefix ::
  #   
  # :postfix ::
  #   
  # :complex_context ::
  #   
  # :ambiguous ::
  #   
  # :unknown ::
  #   
  # :next_line ::
  #   
  # :word_joiner ::
  #   
  # :hangul_l_jamo ::
  #   
  # :hangul_v_jamo ::
  #   
  # :hangul_t_jamo ::
  #   
  # :hangul_lv_syllable ::
  #   
  # :hangul_lvt_syllable ::
  #   
  # :close_paranthesis ::
  #   
  # :conditional_japanese_starter ::
  #   
  # :hebrew_letter ::
  #   
  # 
  # @method _enum_g_unicode_break_type_
  # @return [Symbol]
  # @scope class
  enum :g_unicode_break_type, [
    :mandatory, 0,
    :carriage_return, 1,
    :line_feed, 2,
    :combining_mark, 3,
    :surrogate, 4,
    :zero_width_space, 5,
    :inseparable, 6,
    :non_breaking_glue, 7,
    :contingent, 8,
    :space, 9,
    :after, 10,
    :before, 11,
    :before_and_after, 12,
    :hyphen, 13,
    :non_starter, 14,
    :open_punctuation, 15,
    :close_punctuation, 16,
    :quotation, 17,
    :exclamation, 18,
    :ideographic, 19,
    :numeric, 20,
    :infix_separator, 21,
    :symbol, 22,
    :alphabetic, 23,
    :prefix, 24,
    :postfix, 25,
    :complex_context, 26,
    :ambiguous, 27,
    :unknown, 28,
    :next_line, 29,
    :word_joiner, 30,
    :hangul_l_jamo, 31,
    :hangul_v_jamo, 32,
    :hangul_t_jamo, 33,
    :hangul_lv_syllable, 34,
    :hangul_lvt_syllable, 35,
    :close_paranthesis, 36,
    :conditional_japanese_starter, 37,
    :hebrew_letter, 38
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_unicode_script).</em>
  # 
  # === Options:
  # :invalid_code ::
  #   ISO 15924 code
  # :common ::
  #   
  # :inherited ::
  #   Zyyy
  # :arabic ::
  #   Zinh (Qaai)
  # :armenian ::
  #   Arab
  # :bengali ::
  #   Armn
  # :bopomofo ::
  #   Beng
  # :cherokee ::
  #   Bopo
  # :coptic ::
  #   Cher
  # :cyrillic ::
  #   Copt (Qaac)
  # :deseret ::
  #   Cyrl (Cyrs)
  # :devanagari ::
  #   Dsrt
  # :ethiopic ::
  #   Deva
  # :georgian ::
  #   Ethi
  # :gothic ::
  #   Geor (Geon, Geoa)
  # :greek ::
  #   Goth
  # :gujarati ::
  #   Grek
  # :gurmukhi ::
  #   Gujr
  # :han ::
  #   Guru
  # :hangul ::
  #   Hani
  # :hebrew ::
  #   Hang
  # :hiragana ::
  #   Hebr
  # :kannada ::
  #   Hira
  # :katakana ::
  #   Knda
  # :khmer ::
  #   Kana
  # :lao ::
  #   Khmr
  # :latin ::
  #   Laoo
  # :malayalam ::
  #   Latn (Latf, Latg)
  # :mongolian ::
  #   Mlym
  # :myanmar ::
  #   Mong
  # :ogham ::
  #   Mymr
  # :old_italic ::
  #   Ogam
  # :oriya ::
  #   Ital
  # :runic ::
  #   Orya
  # :sinhala ::
  #   Runr
  # :syriac ::
  #   Sinh
  # :tamil ::
  #   Syrc (Syrj, Syrn, Syre)
  # :telugu ::
  #   Taml
  # :thaana ::
  #   Telu
  # :thai ::
  #   Thaa
  # :tibetan ::
  #   Thai
  # :canadian_aboriginal ::
  #   Tibt
  # :yi ::
  #   Cans
  # :tagalog ::
  #   Yiii
  # :hanunoo ::
  #   Tglg
  # :buhid ::
  #   Hano
  # :tagbanwa ::
  #   Buhd
  # :braille ::
  #   Unicode-4.0 additions
  # :cypriot ::
  #   Brai
  # :limbu ::
  #   Cprt
  # :osmanya ::
  #   Limb
  # :shavian ::
  #   Osma
  # :linear_b ::
  #   Shaw
  # :tai_le ::
  #   Linb
  # :ugaritic ::
  #   Tale
  # :new_tai_lue ::
  #   Unicode-4.1 additions
  # :buginese ::
  #   Talu
  # :glagolitic ::
  #   Bugi
  # :tifinagh ::
  #   Glag
  # :syloti_nagri ::
  #   Tfng
  # :old_persian ::
  #   Sylo
  # :kharoshthi ::
  #   Xpeo
  # :unknown ::
  #   Unicode-5.0 additions
  # :balinese ::
  #   Zzzz
  # :cuneiform ::
  #   Bali
  # :phoenician ::
  #   Xsux
  # :phags_pa ::
  #   Phnx
  # :nko ::
  #   Phag
  # :kayah_li ::
  #   Unicode-5.1 additions
  # :lepcha ::
  #   Kali
  # :rejang ::
  #   Lepc
  # :sundanese ::
  #   Rjng
  # :saurashtra ::
  #   Sund
  # :cham ::
  #   Saur
  # :ol_chiki ::
  #   Cham
  # :vai ::
  #   Olck
  # :carian ::
  #   Vaii
  # :lycian ::
  #   Cari
  # :lydian ::
  #   Lyci
  # :avestan ::
  #   Unicode-5.2 additions
  # :bamum ::
  #   Avst
  # :egyptian_hieroglyphs ::
  #   Bamu
  # :imperial_aramaic ::
  #   Egyp
  # :inscriptional_pahlavi ::
  #   Armi
  # :inscriptional_parthian ::
  #   Phli
  # :javanese ::
  #   Prti
  # :kaithi ::
  #   Java
  # :lisu ::
  #   Kthi
  # :meetei_mayek ::
  #   Lisu
  # :old_south_arabian ::
  #   Mtei
  # :old_turkic ::
  #   Sarb
  # :samaritan ::
  #   Orkh
  # :tai_tham ::
  #   Samr
  # :tai_viet ::
  #   Lana
  # :batak ::
  #   Unicode-6.0 additions
  # :brahmi ::
  #   Batk
  # :mandaic ::
  #   Brah
  # :chakma ::
  #   Unicode-6.1 additions
  # :meroitic_cursive ::
  #   Cakm
  # :meroitic_hieroglyphs ::
  #   Merc
  # :miao ::
  #   Mero
  # :sharada ::
  #   Plrd
  # :sora_sompeng ::
  #   Shrd
  # :takri ::
  #   Sora
  # 
  # @method _enum_g_unicode_script_
  # @return [Symbol]
  # @scope class
  enum :g_unicode_script, [
    :invalid_code, -1,
    :common, 0,
    :inherited, 1,
    :arabic, 2,
    :armenian, 3,
    :bengali, 4,
    :bopomofo, 5,
    :cherokee, 6,
    :coptic, 7,
    :cyrillic, 8,
    :deseret, 9,
    :devanagari, 10,
    :ethiopic, 11,
    :georgian, 12,
    :gothic, 13,
    :greek, 14,
    :gujarati, 15,
    :gurmukhi, 16,
    :han, 17,
    :hangul, 18,
    :hebrew, 19,
    :hiragana, 20,
    :kannada, 21,
    :katakana, 22,
    :khmer, 23,
    :lao, 24,
    :latin, 25,
    :malayalam, 26,
    :mongolian, 27,
    :myanmar, 28,
    :ogham, 29,
    :old_italic, 30,
    :oriya, 31,
    :runic, 32,
    :sinhala, 33,
    :syriac, 34,
    :tamil, 35,
    :telugu, 36,
    :thaana, 37,
    :thai, 38,
    :tibetan, 39,
    :canadian_aboriginal, 40,
    :yi, 41,
    :tagalog, 42,
    :hanunoo, 43,
    :buhid, 44,
    :tagbanwa, 45,
    :braille, 46,
    :cypriot, 47,
    :limbu, 48,
    :osmanya, 49,
    :shavian, 50,
    :linear_b, 51,
    :tai_le, 52,
    :ugaritic, 53,
    :new_tai_lue, 54,
    :buginese, 55,
    :glagolitic, 56,
    :tifinagh, 57,
    :syloti_nagri, 58,
    :old_persian, 59,
    :kharoshthi, 60,
    :unknown, 61,
    :balinese, 62,
    :cuneiform, 63,
    :phoenician, 64,
    :phags_pa, 65,
    :nko, 66,
    :kayah_li, 67,
    :lepcha, 68,
    :rejang, 69,
    :sundanese, 70,
    :saurashtra, 71,
    :cham, 72,
    :ol_chiki, 73,
    :vai, 74,
    :carian, 75,
    :lycian, 76,
    :lydian, 77,
    :avestan, 78,
    :bamum, 79,
    :egyptian_hieroglyphs, 80,
    :imperial_aramaic, 81,
    :inscriptional_pahlavi, 82,
    :inscriptional_parthian, 83,
    :javanese, 84,
    :kaithi, 85,
    :lisu, 86,
    :meetei_mayek, 87,
    :old_south_arabian, 88,
    :old_turkic, 89,
    :samaritan, 90,
    :tai_tham, 91,
    :tai_viet, 92,
    :batak, 93,
    :brahmi, 94,
    :mandaic, 95,
    :chakma, 96,
    :meroitic_cursive, 97,
    :meroitic_hieroglyphs, 98,
    :miao, 99,
    :sharada, 100,
    :sora_sompeng, 101,
    :takri, 102
  ]
  
  # (Not documented)
  # 
  # @method g_unicode_script_to_iso15924(script)
  # @param [Symbol from _enum_g_unicode_script_] script 
  # @return [Integer] 
  # @scope class
  attach_function :g_unicode_script_to_iso15924, :g_unicode_script_to_iso15924, [:g_unicode_script], :uint
  
  # (Not documented)
  # 
  # @method g_unicode_script_from_iso15924(iso15924)
  # @param [Integer] iso15924 
  # @return [Symbol from _enum_g_unicode_script_] 
  # @scope class
  attach_function :g_unicode_script_from_iso15924, :g_unicode_script_from_iso15924, [:uint], :g_unicode_script
  
  # (Not documented)
  # 
  # @method g_unichar_isalnum(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isalnum, :g_unichar_isalnum, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isalpha(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isalpha, :g_unichar_isalpha, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_iscntrl(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_iscntrl, :g_unichar_iscntrl, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isdigit(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isdigit, :g_unichar_isdigit, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isgraph(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isgraph, :g_unichar_isgraph, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_islower(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_islower, :g_unichar_islower, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isprint(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isprint, :g_unichar_isprint, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_ispunct(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_ispunct, :g_unichar_ispunct, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isspace(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isspace, :g_unichar_isspace, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isupper(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isupper, :g_unichar_isupper, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isxdigit(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isxdigit, :g_unichar_isxdigit, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_istitle(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_istitle, :g_unichar_istitle, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_isdefined(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_isdefined, :g_unichar_isdefined, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_iswide(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_iswide, :g_unichar_iswide, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_iswide_cjk(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_iswide_cjk, :g_unichar_iswide_cjk, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_iszerowidth(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_iszerowidth, :g_unichar_iszerowidth, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_ismark(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_ismark, :g_unichar_ismark, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_toupper(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_toupper, :g_unichar_toupper, [:uint], :uint
  
  # (Not documented)
  # 
  # @method g_unichar_tolower(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_tolower, :g_unichar_tolower, [:uint], :uint
  
  # (Not documented)
  # 
  # @method g_unichar_totitle(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_totitle, :g_unichar_totitle, [:uint], :uint
  
  # (Not documented)
  # 
  # @method g_unichar_digit_value(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_digit_value, :g_unichar_digit_value, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_xdigit_value(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_xdigit_value, :g_unichar_xdigit_value, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_type(c)
  # @param [Integer] c 
  # @return [Symbol from _enum_g_unicode_type_] 
  # @scope class
  attach_function :g_unichar_type, :g_unichar_type, [:uint], :g_unicode_type
  
  # (Not documented)
  # 
  # @method g_unichar_break_type(c)
  # @param [Integer] c 
  # @return [Symbol from _enum_g_unicode_break_type_] 
  # @scope class
  attach_function :g_unichar_break_type, :g_unichar_break_type, [:uint], :g_unicode_break_type
  
  # (Not documented)
  # 
  # @method g_unichar_combining_class(uc)
  # @param [Integer] uc 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_combining_class, :g_unichar_combining_class, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_get_mirror_char(ch, mirrored_ch)
  # @param [Integer] ch 
  # @param [FFI::Pointer(*Gunichar)] mirrored_ch 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_get_mirror_char, :g_unichar_get_mirror_char, [:uint, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_unichar_get_script(ch)
  # @param [Integer] ch 
  # @return [Symbol from _enum_g_unicode_script_] 
  # @scope class
  attach_function :g_unichar_get_script, :g_unichar_get_script, [:uint], :g_unicode_script
  
  # (Not documented)
  # 
  # @method g_unichar_validate(ch)
  # @param [Integer] ch 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_validate, :g_unichar_validate, [:uint], :int
  
  # (Not documented)
  # 
  # @method g_unichar_compose(a, b, ch)
  # @param [Integer] a 
  # @param [Integer] b 
  # @param [FFI::Pointer(*Gunichar)] ch 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_compose, :g_unichar_compose, [:uint, :uint, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_unichar_decompose(ch, a, b)
  # @param [Integer] ch 
  # @param [FFI::Pointer(*Gunichar)] a 
  # @param [FFI::Pointer(*Gunichar)] b 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_decompose, :g_unichar_decompose, [:uint, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_unichar_fully_decompose(ch, compat, result, result_len)
  # @param [Integer] ch 
  # @param [Integer] compat 
  # @param [FFI::Pointer(*Gunichar)] result 
  # @param [Integer] result_len 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_fully_decompose, :g_unichar_fully_decompose, [:uint, :int, :pointer, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_unicode_canonical_ordering(string, len)
  # @param [FFI::Pointer(*Gunichar)] string 
  # @param [Integer] len 
  # @return [nil] 
  # @scope class
  attach_function :g_unicode_canonical_ordering, :g_unicode_canonical_ordering, [:pointer, :uint], :void
  
  # (Not documented)
  # 
  # @method g_unicode_canonical_decomposition(ch, result_len)
  # @param [Integer] ch 
  # @param [FFI::Pointer(*Gsize)] result_len 
  # @return [FFI::Pointer(*Gunichar)] 
  # @scope class
  attach_function :g_unicode_canonical_decomposition, :g_unicode_canonical_decomposition, [:uint, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_utf8_get_char(p)
  # @param [String] p 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_get_char, :g_utf8_get_char, [:string], :uint
  
  # (Not documented)
  # 
  # @method g_utf8_get_char_validated(p, max_len)
  # @param [String] p 
  # @param [Integer] max_len 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_get_char_validated, :g_utf8_get_char_validated, [:string, :int], :uint
  
  # (Not documented)
  # 
  # @method g_utf8_offset_to_pointer(str, offset)
  # @param [String] str 
  # @param [Integer] offset 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_offset_to_pointer, :g_utf8_offset_to_pointer, [:string, :long], :string
  
  # (Not documented)
  # 
  # @method g_utf8_pointer_to_offset(str, pos)
  # @param [String] str 
  # @param [String] pos 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_pointer_to_offset, :g_utf8_pointer_to_offset, [:string, :string], :long
  
  # (Not documented)
  # 
  # @method g_utf8_prev_char(p)
  # @param [String] p 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_prev_char, :g_utf8_prev_char, [:string], :string
  
  # (Not documented)
  # 
  # @method g_utf8_find_next_char(p, end_)
  # @param [String] p 
  # @param [String] end_ 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_find_next_char, :g_utf8_find_next_char, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_utf8_find_prev_char(str, p)
  # @param [String] str 
  # @param [String] p 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_find_prev_char, :g_utf8_find_prev_char, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strlen(p, max)
  # @param [String] p 
  # @param [Integer] max 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_strlen, :g_utf8_strlen, [:string, :int], :long
  
  # (Not documented)
  # 
  # @method g_utf8_substring(str, start_pos, end_pos)
  # @param [String] str 
  # @param [Integer] start_pos 
  # @param [Integer] end_pos 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_substring, :g_utf8_substring, [:string, :long, :long], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strncpy(dest, src, n)
  # @param [String] dest 
  # @param [String] src 
  # @param [Integer] n 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strncpy, :g_utf8_strncpy, [:string, :string, :uint], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strchr(p, len, c)
  # @param [String] p 
  # @param [Integer] len 
  # @param [Integer] c 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strchr, :g_utf8_strchr, [:string, :int, :uint], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strrchr(p, len, c)
  # @param [String] p 
  # @param [Integer] len 
  # @param [Integer] c 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strrchr, :g_utf8_strrchr, [:string, :int, :uint], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strreverse(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strreverse, :g_utf8_strreverse, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_utf8_to_utf16(str, len, items_read, items_written, error)
  # @param [String] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gunichar2)] 
  # @scope class
  attach_function :g_utf8_to_utf16, :g_utf8_to_utf16, [:string, :long, :pointer, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_utf8_to_ucs4(str, len, items_read, items_written, error)
  # @param [String] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gunichar)] 
  # @scope class
  attach_function :g_utf8_to_ucs4, :g_utf8_to_ucs4, [:string, :long, :pointer, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_utf8_to_ucs4_fast(str, len, items_written)
  # @param [String] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @return [FFI::Pointer(*Gunichar)] 
  # @scope class
  attach_function :g_utf8_to_ucs4_fast, :g_utf8_to_ucs4_fast, [:string, :long, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_utf16_to_ucs4(str, len, items_read, items_written, error)
  # @param [FFI::Pointer(*Gunichar2)] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gunichar)] 
  # @scope class
  attach_function :g_utf16_to_ucs4, :g_utf16_to_ucs4, [:pointer, :long, :pointer, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_utf16_to_utf8(str, len, items_read, items_written, error)
  # @param [FFI::Pointer(*Gunichar2)] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_utf16_to_utf8, :g_utf16_to_utf8, [:pointer, :long, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_ucs4_to_utf16(str, len, items_read, items_written, error)
  # @param [FFI::Pointer(*Gunichar)] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gunichar2)] 
  # @scope class
  attach_function :g_ucs4_to_utf16, :g_ucs4_to_utf16, [:pointer, :long, :pointer, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_ucs4_to_utf8(str, len, items_read, items_written, error)
  # @param [FFI::Pointer(*Gunichar)] str 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Glong)] items_read 
  # @param [FFI::Pointer(*Glong)] items_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_ucs4_to_utf8, :g_ucs4_to_utf8, [:pointer, :long, :pointer, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_unichar_to_utf8(c, outbuf)
  # @param [Integer] c 
  # @param [String] outbuf 
  # @return [Integer] 
  # @scope class
  attach_function :g_unichar_to_utf8, :g_unichar_to_utf8, [:uint, :string], :int
  
  # (Not documented)
  # 
  # @method g_utf8_validate(str, max_len, end_)
  # @param [String] str 
  # @param [Integer] max_len 
  # @param [FFI::Pointer(**Gchar)] end_ 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_validate, :g_utf8_validate, [:string, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_utf8_strup(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strup, :g_utf8_strup, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_utf8_strdown(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_strdown, :g_utf8_strdown, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_utf8_casefold(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_casefold, :g_utf8_casefold, [:string, :int], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_normalize_mode).</em>
  # 
  # === Options:
  # :default ::
  #   
  # :default_compose ::
  #   
  # :all ::
  #   
  # :all_compose ::
  #   
  # 
  # @method _enum_g_normalize_mode_
  # @return [Symbol]
  # @scope class
  enum :g_normalize_mode, [
    :default, 0,
    :default_compose, 1,
    :all, 2,
    :all_compose, 3
  ]
  
  # (Not documented)
  # 
  # @method g_utf8_normalize(str, len, mode)
  # @param [String] str 
  # @param [Integer] len 
  # @param [Symbol from _enum_g_normalize_mode_] mode 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_normalize, :g_utf8_normalize, [:string, :int, :g_normalize_mode], :string
  
  # (Not documented)
  # 
  # @method g_utf8_collate(str1, str2)
  # @param [String] str1 
  # @param [String] str2 
  # @return [Integer] 
  # @scope class
  attach_function :g_utf8_collate, :g_utf8_collate, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_utf8_collate_key(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_collate_key, :g_utf8_collate_key, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_utf8_collate_key_for_filename(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_collate_key_for_filename, :g_utf8_collate_key_for_filename, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_utf8_make_valid(name)
  # @param [String] name 
  # @return [String] 
  # @scope class
  attach_function :g_utf8_make_valid, :_g_utf8_make_valid, [:string], :string
  
  # (Not documented)
  # 
  # @method g_get_user_name_utf8()
  # @return [String] 
  # @scope class
  attach_function :g_get_user_name_utf8, :g_get_user_name_utf8, [], :string
  
  # (Not documented)
  # 
  # @method g_get_real_name_utf8()
  # @return [String] 
  # @scope class
  attach_function :g_get_real_name_utf8, :g_get_real_name_utf8, [], :string
  
  # (Not documented)
  # 
  # @method g_get_home_dir_utf8()
  # @return [String] 
  # @scope class
  attach_function :g_get_home_dir_utf8, :g_get_home_dir_utf8, [], :string
  
  # (Not documented)
  # 
  # @method g_get_tmp_dir_utf8()
  # @return [String] 
  # @scope class
  attach_function :g_get_tmp_dir_utf8, :g_get_tmp_dir_utf8, [], :string
  
  # (Not documented)
  # 
  # @method g_get_host_name()
  # @return [String] 
  # @scope class
  attach_function :g_get_host_name, :g_get_host_name, [], :string
  
  # (Not documented)
  # 
  # @method g_get_prgname()
  # @return [String] 
  # @scope class
  attach_function :g_get_prgname, :g_get_prgname, [], :string
  
  # (Not documented)
  # 
  # @method g_set_prgname(prgname)
  # @param [String] prgname 
  # @return [nil] 
  # @scope class
  attach_function :g_set_prgname, :g_set_prgname, [:string], :void
  
  # (Not documented)
  # 
  # @method g_get_application_name()
  # @return [String] 
  # @scope class
  attach_function :g_get_application_name, :g_get_application_name, [], :string
  
  # (Not documented)
  # 
  # @method g_set_application_name(application_name)
  # @param [String] application_name 
  # @return [nil] 
  # @scope class
  attach_function :g_set_application_name, :g_set_application_name, [:string], :void
  
  # (Not documented)
  # 
  # @method g_reload_user_special_dirs_cache()
  # @return [nil] 
  # @scope class
  attach_function :g_reload_user_special_dirs_cache, :g_reload_user_special_dirs_cache, [], :void
  
  # (Not documented)
  # 
  # @method g_get_user_data_dir()
  # @return [String] 
  # @scope class
  attach_function :g_get_user_data_dir, :g_get_user_data_dir, [], :string
  
  # (Not documented)
  # 
  # @method g_get_user_config_dir()
  # @return [String] 
  # @scope class
  attach_function :g_get_user_config_dir, :g_get_user_config_dir, [], :string
  
  # (Not documented)
  # 
  # @method g_get_user_cache_dir()
  # @return [String] 
  # @scope class
  attach_function :g_get_user_cache_dir, :g_get_user_cache_dir, [], :string
  
  # (Not documented)
  # 
  # @method g_get_system_data_dirs()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_get_system_data_dirs, :g_get_system_data_dirs, [], :pointer
  
  # (Not documented)
  # 
  # @method g_win32_get_system_data_dirs_for_module(address_of_function)
  # @param [FFI::Pointer(*)] address_of_function 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_win32_get_system_data_dirs_for_module, :g_win32_get_system_data_dirs_for_module, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_win32_get_system_data_dirs()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_win32_get_system_data_dirs, :_g_win32_get_system_data_dirs, [], :pointer
  
  # (Not documented)
  # 
  # @method g_get_system_config_dirs()
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_get_system_config_dirs, :g_get_system_config_dirs, [], :pointer
  
  # (Not documented)
  # 
  # @method g_get_user_runtime_dir()
  # @return [String] 
  # @scope class
  attach_function :g_get_user_runtime_dir, :g_get_user_runtime_dir, [], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_user_directory).</em>
  # 
  # === Options:
  # :directory_desktop ::
  #   
  # :directory_documents ::
  #   
  # :directory_download ::
  #   
  # :directory_music ::
  #   
  # :directory_pictures ::
  #   
  # :directory_public_share ::
  #   
  # :directory_templates ::
  #   
  # :directory_videos ::
  #   
  # :n_directories ::
  #   
  # 
  # @method _enum_g_user_directory_
  # @return [Symbol]
  # @scope class
  enum :g_user_directory, [
    :directory_desktop, 0,
    :directory_documents, 1,
    :directory_download, 2,
    :directory_music, 3,
    :directory_pictures, 4,
    :directory_public_share, 5,
    :directory_templates, 6,
    :directory_videos, 7,
    :n_directories, 8
  ]
  
  # (Not documented)
  # 
  # @method g_get_user_special_dir(directory)
  # @param [Symbol from _enum_g_user_directory_] directory 
  # @return [String] 
  # @scope class
  attach_function :g_get_user_special_dir, :g_get_user_special_dir, [:g_user_directory], :string
  
  # (Not documented)
  # 
  # = Fields:
  # :key ::
  #   (String) 
  # :value ::
  #   (Integer) 
  class GDebugKey < FFI::Struct
    layout :key, :string,
           :value, :uint
  end
  
  # (Not documented)
  # 
  # @method g_parse_debug_string(string, keys, nkeys)
  # @param [String] string 
  # @param [GDebugKey] keys 
  # @param [Integer] nkeys 
  # @return [Integer] 
  # @scope class
  attach_function :g_parse_debug_string, :g_parse_debug_string, [:string, GDebugKey, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_snprintf(string, n, format)
  # @param [String] string 
  # @param [Integer] n 
  # @param [String] format 
  # @return [Integer] 
  # @scope class
  attach_function :g_snprintf, :g_snprintf, [:string, :ulong, :string], :int
  
  # (Not documented)
  # 
  # @method g_vsnprintf(string, n, format, args)
  # @param [String] string 
  # @param [Integer] n 
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_vsnprintf, :g_vsnprintf, [:string, :ulong, :string, :string], :int
  
  # (Not documented)
  # 
  # @method g_nullify_pointer(nullify_location)
  # @param [FFI::Pointer(*Gpointer)] nullify_location 
  # @return [nil] 
  # @scope class
  attach_function :g_nullify_pointer, :g_nullify_pointer, [:pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_format_size_flags).</em>
  # 
  # === Options:
  # :default ::
  #   
  # :long_format ::
  #   
  # :iec_units ::
  #   
  # 
  # @method _enum_g_format_size_flags_
  # @return [Symbol]
  # @scope class
  enum :g_format_size_flags, [
    :default, 0,
    :long_format, 1,
    :iec_units, 2
  ]
  
  # (Not documented)
  # 
  # @method g_format_size_full(size, flags)
  # @param [Integer] size 
  # @param [Symbol from _enum_g_format_size_flags_] flags 
  # @return [String] 
  # @scope class
  attach_function :g_format_size_full, :g_format_size_full, [:ulong_long, :g_format_size_flags], :string
  
  # (Not documented)
  # 
  # @method g_format_size(size)
  # @param [Integer] size 
  # @return [String] 
  # @scope class
  attach_function :g_format_size, :g_format_size, [:ulong_long], :string
  
  # (Not documented)
  # 
  # @method g_format_size_for_display(size)
  # @param [Integer] size 
  # @return [String] 
  # @scope class
  attach_function :g_format_size_for_display, :g_format_size_for_display, [:long_long], :string
  
  # (Not documented)
  # 
  # @method g_atexit(func)
  # @param [FFI::Pointer(GVoidFunc)] func 
  # @return [nil] 
  # @scope class
  attach_function :g_atexit, :g_atexit, [:pointer], :void
  
  # (Not documented)
  # 
  # @method atexit()
  # @param [FFI::Pointer(*)]  
  # @return [Integer] 
  # @scope class
  attach_function :atexit, :atexit, [:pointer], :int
  
  # (Not documented)
  # 
  # @method g_find_program_in_path_utf8(program)
  # @param [String] program 
  # @return [String] 
  # @scope class
  attach_function :g_find_program_in_path_utf8, :g_find_program_in_path_utf8, [:string], :string
  
  # (Not documented)
  # 
  # @method g_bit_nth_lsf(mask, nth_bit)
  # @param [Integer] mask 
  # @param [Integer] nth_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_nth_lsf, :g_bit_nth_lsf, [:ulong, :int], :int
  
  # (Not documented)
  # 
  # @method g_bit_nth_msf(mask, nth_bit)
  # @param [Integer] mask 
  # @param [Integer] nth_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_nth_msf, :g_bit_nth_msf, [:ulong, :int], :int
  
  # (Not documented)
  # 
  # @method g_bit_storage(number)
  # @param [Integer] number 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_storage, :g_bit_storage, [:ulong], :uint
  
  # (Not documented)
  # 
  # @method g_bit_nth_lsf(mask, nth_bit)
  # @param [Integer] mask 
  # @param [Integer] nth_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_nth_lsf, :g_bit_nth_lsf, [:ulong, :int], :int
  
  # (Not documented)
  # 
  # @method g_bit_nth_msf(mask, nth_bit)
  # @param [Integer] mask 
  # @param [Integer] nth_bit 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_nth_msf, :g_bit_nth_msf, [:ulong, :int], :int
  
  # (Not documented)
  # 
  # @method g_bit_storage(number)
  # @param [Integer] number 
  # @return [Integer] 
  # @scope class
  attach_function :g_bit_storage, :g_bit_storage, [:ulong], :uint
  
  # (Not documented)
  # 
  # = Fields:
  # :str ::
  #   (String) 
  # :len ::
  #   (Integer) 
  # :allocated_len ::
  #   (Integer) 
  module GStringWrappers
    # @param [Integer] free_segment 
    # @return [String] 
    def free(free_segment)
      Glib.g_string_free(self, free_segment)
    end
    
    # @return [GBytes] 
    def free_to_bytes()
      GBytes.new Glib.g_string_free_to_bytes(self)
    end
    
    # @param [FFI::Pointer(*GString)] v2 
    # @return [Integer] 
    def equal(v2)
      Glib.g_string_equal(self, v2)
    end
    
    # @return [Integer] 
    def hash()
      Glib.g_string_hash(self)
    end
    
    # @param [String] rval 
    # @return [GString] 
    def assign(rval)
      GString.new Glib.g_string_assign(self, rval)
    end
    
    # @param [Integer] len 
    # @return [GString] 
    def truncate(len)
      GString.new Glib.g_string_truncate(self, len)
    end
    
    # @param [Integer] len 
    # @return [GString] 
    def set_size(len)
      GString.new Glib.g_string_set_size(self, len)
    end
    
    # @param [Integer] pos 
    # @param [String] val 
    # @param [Integer] len 
    # @return [GString] 
    def insert_len(pos, val, len)
      GString.new Glib.g_string_insert_len(self, pos, val, len)
    end
    
    # @param [String] val 
    # @return [GString] 
    def append(val)
      GString.new Glib.g_string_append(self, val)
    end
    
    # @param [String] val 
    # @param [Integer] len 
    # @return [GString] 
    def append_len(val, len)
      GString.new Glib.g_string_append_len(self, val, len)
    end
    
    # @param [Integer] c 
    # @return [GString] 
    def append_c(c)
      GString.new Glib.g_string_append_c(self, c)
    end
    
    # @param [Integer] wc 
    # @return [GString] 
    def append_unichar(wc)
      GString.new Glib.g_string_append_unichar(self, wc)
    end
    
    # @param [String] val 
    # @return [GString] 
    def prepend(val)
      GString.new Glib.g_string_prepend(self, val)
    end
    
    # @param [Integer] c 
    # @return [GString] 
    def prepend_c(c)
      GString.new Glib.g_string_prepend_c(self, c)
    end
    
    # @param [Integer] wc 
    # @return [GString] 
    def prepend_unichar(wc)
      GString.new Glib.g_string_prepend_unichar(self, wc)
    end
    
    # @param [String] val 
    # @param [Integer] len 
    # @return [GString] 
    def prepend_len(val, len)
      GString.new Glib.g_string_prepend_len(self, val, len)
    end
    
    # @param [Integer] pos 
    # @param [String] val 
    # @return [GString] 
    def insert(pos, val)
      GString.new Glib.g_string_insert(self, pos, val)
    end
    
    # @param [Integer] pos 
    # @param [Integer] c 
    # @return [GString] 
    def insert_c(pos, c)
      GString.new Glib.g_string_insert_c(self, pos, c)
    end
    
    # @param [Integer] pos 
    # @param [Integer] wc 
    # @return [GString] 
    def insert_unichar(pos, wc)
      GString.new Glib.g_string_insert_unichar(self, pos, wc)
    end
    
    # @param [Integer] pos 
    # @param [String] val 
    # @return [GString] 
    def overwrite(pos, val)
      GString.new Glib.g_string_overwrite(self, pos, val)
    end
    
    # @param [Integer] pos 
    # @param [String] val 
    # @param [Integer] len 
    # @return [GString] 
    def overwrite_len(pos, val, len)
      GString.new Glib.g_string_overwrite_len(self, pos, val, len)
    end
    
    # @param [Integer] pos 
    # @param [Integer] len 
    # @return [GString] 
    def erase(pos, len)
      GString.new Glib.g_string_erase(self, pos, len)
    end
    
    # @return [GString] 
    def ascii_down()
      GString.new Glib.g_string_ascii_down(self)
    end
    
    # @return [GString] 
    def ascii_up()
      GString.new Glib.g_string_ascii_up(self)
    end
    
    # @param [String] format 
    # @param [String] args 
    # @return [nil] 
    def vprintf(format, args)
      Glib.g_string_vprintf(self, format, args)
    end
    
    # @param [String] format 
    # @return [nil] 
    def printf(format)
      Glib.g_string_printf(self, format)
    end
    
    # @param [String] format 
    # @param [String] args 
    # @return [nil] 
    def append_vprintf(format, args)
      Glib.g_string_append_vprintf(self, format, args)
    end
    
    # @param [String] format 
    # @return [nil] 
    def append_printf(format)
      Glib.g_string_append_printf(self, format)
    end
    
    # @param [String] unescaped 
    # @param [String] reserved_chars_allowed 
    # @param [Integer] allow_utf8 
    # @return [GString] 
    def append_uri_escaped(unescaped, reserved_chars_allowed, allow_utf8)
      GString.new Glib.g_string_append_uri_escaped(self, unescaped, reserved_chars_allowed, allow_utf8)
    end
    
    # @param [Integer] c 
    # @return [GString] 
    def append_c_inline(c)
      GString.new Glib.g_string_append_c_inline(self, c)
    end
    
    # @return [GString] 
    def down()
      GString.new Glib.g_string_down(self)
    end
    
    # @return [GString] 
    def up()
      GString.new Glib.g_string_up(self)
    end
  end
  
  class GString < FFI::Struct
    include GStringWrappers
    layout :str, :string,
           :len, :uint,
           :allocated_len, :uint
  end
  
  # (Not documented)
  # 
  # @method g_string_new(init)
  # @param [String] init 
  # @return [GString] 
  # @scope class
  attach_function :g_string_new, :g_string_new, [:string], GString
  
  # (Not documented)
  # 
  # @method g_string_new_len(init, len)
  # @param [String] init 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_new_len, :g_string_new_len, [:string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_sized_new(dfl_size)
  # @param [Integer] dfl_size 
  # @return [GString] 
  # @scope class
  attach_function :g_string_sized_new, :g_string_sized_new, [:uint], GString
  
  # (Not documented)
  # 
  # @method g_string_free(string, free_segment)
  # @param [GString] string 
  # @param [Integer] free_segment 
  # @return [String] 
  # @scope class
  attach_function :g_string_free, :g_string_free, [GString, :int], :string
  
  # (Not documented)
  # 
  # @method g_string_free_to_bytes(string)
  # @param [GString] string 
  # @return [GBytes] 
  # @scope class
  attach_function :g_string_free_to_bytes, :g_string_free_to_bytes, [GString], GBytes
  
  # (Not documented)
  # 
  # @method g_string_equal(v, v2)
  # @param [GString] v 
  # @param [GString] v2 
  # @return [Integer] 
  # @scope class
  attach_function :g_string_equal, :g_string_equal, [GString, GString], :int
  
  # (Not documented)
  # 
  # @method g_string_hash(str)
  # @param [GString] str 
  # @return [Integer] 
  # @scope class
  attach_function :g_string_hash, :g_string_hash, [GString], :uint
  
  # (Not documented)
  # 
  # @method g_string_assign(string, rval)
  # @param [GString] string 
  # @param [String] rval 
  # @return [GString] 
  # @scope class
  attach_function :g_string_assign, :g_string_assign, [GString, :string], GString
  
  # (Not documented)
  # 
  # @method g_string_truncate(string, len)
  # @param [GString] string 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_truncate, :g_string_truncate, [GString, :uint], GString
  
  # (Not documented)
  # 
  # @method g_string_set_size(string, len)
  # @param [GString] string 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_set_size, :g_string_set_size, [GString, :uint], GString
  
  # (Not documented)
  # 
  # @method g_string_insert_len(string, pos, val, len)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [String] val 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_insert_len, :g_string_insert_len, [GString, :int, :string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_append(string, val)
  # @param [GString] string 
  # @param [String] val 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append, :g_string_append, [GString, :string], GString
  
  # (Not documented)
  # 
  # @method g_string_append_len(string, val, len)
  # @param [GString] string 
  # @param [String] val 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append_len, :g_string_append_len, [GString, :string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_append_c(string, c)
  # @param [GString] string 
  # @param [Integer] c 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append_c, :g_string_append_c, [GString, :char], GString
  
  # (Not documented)
  # 
  # @method g_string_append_unichar(string, wc)
  # @param [GString] string 
  # @param [Integer] wc 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append_unichar, :g_string_append_unichar, [GString, :uint], GString
  
  # (Not documented)
  # 
  # @method g_string_prepend(string, val)
  # @param [GString] string 
  # @param [String] val 
  # @return [GString] 
  # @scope class
  attach_function :g_string_prepend, :g_string_prepend, [GString, :string], GString
  
  # (Not documented)
  # 
  # @method g_string_prepend_c(string, c)
  # @param [GString] string 
  # @param [Integer] c 
  # @return [GString] 
  # @scope class
  attach_function :g_string_prepend_c, :g_string_prepend_c, [GString, :char], GString
  
  # (Not documented)
  # 
  # @method g_string_prepend_unichar(string, wc)
  # @param [GString] string 
  # @param [Integer] wc 
  # @return [GString] 
  # @scope class
  attach_function :g_string_prepend_unichar, :g_string_prepend_unichar, [GString, :uint], GString
  
  # (Not documented)
  # 
  # @method g_string_prepend_len(string, val, len)
  # @param [GString] string 
  # @param [String] val 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_prepend_len, :g_string_prepend_len, [GString, :string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_insert(string, pos, val)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [String] val 
  # @return [GString] 
  # @scope class
  attach_function :g_string_insert, :g_string_insert, [GString, :int, :string], GString
  
  # (Not documented)
  # 
  # @method g_string_insert_c(string, pos, c)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [Integer] c 
  # @return [GString] 
  # @scope class
  attach_function :g_string_insert_c, :g_string_insert_c, [GString, :int, :char], GString
  
  # (Not documented)
  # 
  # @method g_string_insert_unichar(string, pos, wc)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [Integer] wc 
  # @return [GString] 
  # @scope class
  attach_function :g_string_insert_unichar, :g_string_insert_unichar, [GString, :int, :uint], GString
  
  # (Not documented)
  # 
  # @method g_string_overwrite(string, pos, val)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [String] val 
  # @return [GString] 
  # @scope class
  attach_function :g_string_overwrite, :g_string_overwrite, [GString, :uint, :string], GString
  
  # (Not documented)
  # 
  # @method g_string_overwrite_len(string, pos, val, len)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [String] val 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_overwrite_len, :g_string_overwrite_len, [GString, :uint, :string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_erase(string, pos, len)
  # @param [GString] string 
  # @param [Integer] pos 
  # @param [Integer] len 
  # @return [GString] 
  # @scope class
  attach_function :g_string_erase, :g_string_erase, [GString, :int, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_ascii_down(string)
  # @param [GString] string 
  # @return [GString] 
  # @scope class
  attach_function :g_string_ascii_down, :g_string_ascii_down, [GString], GString
  
  # (Not documented)
  # 
  # @method g_string_ascii_up(string)
  # @param [GString] string 
  # @return [GString] 
  # @scope class
  attach_function :g_string_ascii_up, :g_string_ascii_up, [GString], GString
  
  # (Not documented)
  # 
  # @method g_string_vprintf(string, format, args)
  # @param [GString] string 
  # @param [String] format 
  # @param [String] args 
  # @return [nil] 
  # @scope class
  attach_function :g_string_vprintf, :g_string_vprintf, [GString, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_string_printf(string, format)
  # @param [GString] string 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_string_printf, :g_string_printf, [GString, :string], :void
  
  # (Not documented)
  # 
  # @method g_string_append_vprintf(string, format, args)
  # @param [GString] string 
  # @param [String] format 
  # @param [String] args 
  # @return [nil] 
  # @scope class
  attach_function :g_string_append_vprintf, :g_string_append_vprintf, [GString, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_string_append_printf(string, format)
  # @param [GString] string 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_string_append_printf, :g_string_append_printf, [GString, :string], :void
  
  # (Not documented)
  # 
  # @method g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed, allow_utf8)
  # @param [GString] string 
  # @param [String] unescaped 
  # @param [String] reserved_chars_allowed 
  # @param [Integer] allow_utf8 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append_uri_escaped, :g_string_append_uri_escaped, [GString, :string, :string, :int], GString
  
  # (Not documented)
  # 
  # @method g_string_append_c_inline(gstring, c)
  # @param [GString] gstring 
  # @param [Integer] c 
  # @return [GString] 
  # @scope class
  attach_function :g_string_append_c_inline, :g_string_append_c_inline, [GString, :char], GString
  
  # (Not documented)
  # 
  # @method g_string_down(string)
  # @param [GString] string 
  # @return [GString] 
  # @scope class
  attach_function :g_string_down, :g_string_down, [GString], GString
  
  # (Not documented)
  # 
  # @method g_string_up(string)
  # @param [GString] string 
  # @return [GString] 
  # @scope class
  attach_function :g_string_up, :g_string_up, [GString], GString
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:gio_error).</em>
  # 
  # === Options:
  # :g_io_error_none ::
  #   
  # :g_io_error_again ::
  #   
  # :g_io_error_inval ::
  #   
  # :g_io_error_unknown ::
  #   
  # 
  # @method _enum_gio_error_
  # @return [Symbol]
  # @scope class
  enum :gio_error, [
    :g_io_error_none, 0,
    :g_io_error_again, 1,
    :g_io_error_inval, 2,
    :g_io_error_unknown, 3
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:gio_channel_error).</em>
  # 
  # === Options:
  # :g_io_channel_error_fbig ::
  #   Derived from errno
  # :g_io_channel_error_inval ::
  #   
  # :g_io_channel_error_io ::
  #   
  # :g_io_channel_error_isdir ::
  #   
  # :g_io_channel_error_nospc ::
  #   
  # :g_io_channel_error_nxio ::
  #   
  # :g_io_channel_error_overflow ::
  #   
  # :g_io_channel_error_pipe ::
  #   
  # :g_io_channel_error_failed ::
  #   Other
  # 
  # @method _enum_gio_channel_error_
  # @return [Symbol]
  # @scope class
  enum :gio_channel_error, [
    :g_io_channel_error_fbig, 0,
    :g_io_channel_error_inval, 1,
    :g_io_channel_error_io, 2,
    :g_io_channel_error_isdir, 3,
    :g_io_channel_error_nospc, 4,
    :g_io_channel_error_nxio, 5,
    :g_io_channel_error_overflow, 6,
    :g_io_channel_error_pipe, 7,
    :g_io_channel_error_failed, 8
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:gio_status).</em>
  # 
  # === Options:
  # :g_io_status_error ::
  #   
  # :g_io_status_normal ::
  #   
  # :g_io_status_eof ::
  #   
  # :g_io_status_again ::
  #   
  # 
  # @method _enum_gio_status_
  # @return [Symbol]
  # @scope class
  enum :gio_status, [
    :g_io_status_error, 0,
    :g_io_status_normal, 1,
    :g_io_status_eof, 2,
    :g_io_status_again, 3
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_seek_type).</em>
  # 
  # === Options:
  # :cur ::
  #   
  # :set ::
  #   
  # :end_ ::
  #   
  # 
  # @method _enum_g_seek_type_
  # @return [Symbol]
  # @scope class
  enum :g_seek_type, [
    :cur, 0,
    :set, 1,
    :end_, 2
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:gio_flags).</em>
  # 
  # === Options:
  # :g_io_flag_append ::
  #   
  # :g_io_flag_nonblock ::
  #   
  # :g_io_flag_is_readable ::
  #   
  # :g_io_flag_is_writable ::
  #   Read only flag
  # :g_io_flag_is_seekable ::
  #   Read only flag
  # :g_io_flag_mask ::
  #   Read only flag
  # 
  # @method _enum_gio_flags_
  # @return [Symbol]
  # @scope class
  enum :gio_flags, [
    :g_io_flag_append, 1,
    :g_io_flag_nonblock, 2,
    :g_io_flag_is_readable, 4,
    :g_io_flag_is_writable, 8,
    :g_io_flag_is_seekable, 16,
    :g_io_flag_mask, 31
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :ref_count ::
  #   (Integer) < private >
  # :funcs ::
  #   (FFI::Pointer(*GIOFuncs)) 
  # :encoding ::
  #   (String) 
  # :read_cd ::
  #   (GIConv) 
  # :write_cd ::
  #   (GIConv) 
  # :line_term ::
  #   (String) String which indicates the end of a line of text
  # :line_term_len ::
  #   (Integer) So we can have null in the line term
  # :buf_size ::
  #   (Integer) 
  # :read_buf ::
  #   (GString) Raw data from the channel
  # :encoded_read_buf ::
  #   (GString) Channel data converted to UTF-8
  # :write_buf ::
  #   (GString) Data ready to be written to the file
  # :partial_write_buf ::
  #   (Array<Integer>) UTF-8 partial characters, null terminated
  # :use_buffer ::
  #   (Integer) The encoding uses the buffers
  # :do_encode ::
  #   (Integer) The encoding uses the GIConv coverters
  # :close_on_unref ::
  #   (Integer) Close the channel on final unref
  # :is_readable ::
  #   (Integer) Cached GIOFlag
  # :is_writeable ::
  #   (Integer) ditto
  # :is_seekable ::
  #   (Integer) ditto
  # :reserved1 ::
  #   (FFI::Pointer(Gpointer)) 
  # :reserved2 ::
  #   (FFI::Pointer(Gpointer)) 
  module GIOChannelWrappers
    # @return [nil] 
    def init()
      Glib.g_io_channel_init(self)
    end
    
    # @return [GIOChannel] 
    def ref()
      GIOChannel.new Glib.g_io_channel_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_io_channel_unref(self)
    end
    
    # @param [String] buf 
    # @param [Integer] count 
    # @param [FFI::Pointer(*Gsize)] bytes_read 
    # @return [Symbol from _enum_gio_error_] 
    def read(buf, count, bytes_read)
      Glib.g_io_channel_read(self, buf, count, bytes_read)
    end
    
    # @param [String] buf 
    # @param [Integer] count 
    # @param [FFI::Pointer(*Gsize)] bytes_written 
    # @return [Symbol from _enum_gio_error_] 
    def write(buf, count, bytes_written)
      Glib.g_io_channel_write(self, buf, count, bytes_written)
    end
    
    # @param [Integer] offset 
    # @param [Symbol from _enum_g_seek_type_] type 
    # @return [Symbol from _enum_gio_error_] 
    def seek(offset, type)
      Glib.g_io_channel_seek(self, offset, type)
    end
    
    # @return [nil] 
    def close()
      Glib.g_io_channel_close(self)
    end
    
    # @param [Integer] flush 
    # @param [FFI::Pointer(**GError)] err 
    # @return [Symbol from _enum_gio_status_] 
    def shutdown(flush, err)
      Glib.g_io_channel_shutdown(self, flush, err)
    end
    
    # @param [Integer] size 
    # @return [nil] 
    def set_buffer_size(size)
      Glib.g_io_channel_set_buffer_size(self, size)
    end
    
    # @return [Integer] 
    def get_buffer_size()
      Glib.g_io_channel_get_buffer_size(self)
    end
    
    # @return [unknown] 
    def get_buffer_condition()
      Glib.g_io_channel_get_buffer_condition(self)
    end
    
    # @param [Symbol from _enum_gio_flags_] flags 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def set_flags(flags, error)
      Glib.g_io_channel_set_flags(self, flags, error)
    end
    
    # @return [Symbol from _enum_gio_flags_] 
    def get_flags()
      Glib.g_io_channel_get_flags(self)
    end
    
    # @param [String] line_term 
    # @param [Integer] length 
    # @return [nil] 
    def set_line_term(line_term, length)
      Glib.g_io_channel_set_line_term(self, line_term, length)
    end
    
    # @param [FFI::Pointer(*Gint)] length 
    # @return [String] 
    def get_line_term(length)
      Glib.g_io_channel_get_line_term(self, length)
    end
    
    # @param [Integer] buffered 
    # @return [nil] 
    def set_buffered(buffered)
      Glib.g_io_channel_set_buffered(self, buffered)
    end
    
    # @return [Integer] 
    def get_buffered()
      Glib.g_io_channel_get_buffered(self)
    end
    
    # @param [String] encoding 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def set_encoding(encoding, error)
      Glib.g_io_channel_set_encoding(self, encoding, error)
    end
    
    # @return [String] 
    def get_encoding()
      Glib.g_io_channel_get_encoding(self)
    end
    
    # @param [Integer] do_close 
    # @return [nil] 
    def set_close_on_unref(do_close)
      Glib.g_io_channel_set_close_on_unref(self, do_close)
    end
    
    # @return [Integer] 
    def get_close_on_unref()
      Glib.g_io_channel_get_close_on_unref(self)
    end
    
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def flush(error)
      Glib.g_io_channel_flush(self, error)
    end
    
    # @param [FFI::Pointer(**Gchar)] str_return 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(*Gsize)] terminator_pos 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def read_line(str_return, length, terminator_pos, error)
      Glib.g_io_channel_read_line(self, str_return, length, terminator_pos, error)
    end
    
    # @param [GString] buffer 
    # @param [FFI::Pointer(*Gsize)] terminator_pos 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def read_line_string(buffer, terminator_pos, error)
      Glib.g_io_channel_read_line_string(self, buffer, terminator_pos, error)
    end
    
    # @param [FFI::Pointer(**Gchar)] str_return 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def read_to_end(str_return, length, error)
      Glib.g_io_channel_read_to_end(self, str_return, length, error)
    end
    
    # @param [String] buf 
    # @param [Integer] count 
    # @param [FFI::Pointer(*Gsize)] bytes_read 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def read_chars(buf, count, bytes_read, error)
      Glib.g_io_channel_read_chars(self, buf, count, bytes_read, error)
    end
    
    # @param [FFI::Pointer(*Gunichar)] thechar 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def read_unichar(thechar, error)
      Glib.g_io_channel_read_unichar(self, thechar, error)
    end
    
    # @param [String] buf 
    # @param [Integer] count 
    # @param [FFI::Pointer(*Gsize)] bytes_written 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def write_chars(buf, count, bytes_written, error)
      Glib.g_io_channel_write_chars(self, buf, count, bytes_written, error)
    end
    
    # @param [Integer] thechar 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def write_unichar(thechar, error)
      Glib.g_io_channel_write_unichar(self, thechar, error)
    end
    
    # @param [Integer] offset 
    # @param [Symbol from _enum_g_seek_type_] type 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Symbol from _enum_gio_status_] 
    def seek_position(offset, type, error)
      Glib.g_io_channel_seek_position(self, offset, type, error)
    end
    
    # @return [Integer] 
    def unix_get_fd()
      Glib.g_io_channel_unix_get_fd(self)
    end
    
    # @param [unknown] condition 
    # @param [GPollFD] fd 
    # @return [nil] 
    def win32_make_pollfd(condition, fd)
      Glib.g_io_channel_win32_make_pollfd(self, condition, fd)
    end
    
    # @return [Integer] 
    def win32_get_fd()
      Glib.g_io_channel_win32_get_fd(self)
    end
  end
  
  class GIOChannel < FFI::Struct
    include GIOChannelWrappers
    layout :ref_count, :int,
           :funcs, :pointer,
           :encoding, :string,
           :read_cd, GIConv,
           :write_cd, GIConv,
           :line_term, :string,
           :line_term_len, :uint,
           :buf_size, :uint,
           :read_buf, GString,
           :encoded_read_buf, GString,
           :write_buf, GString,
           :partial_write_buf, [:char, 6],
           :use_buffer, :uint,
           :do_encode, :uint,
           :close_on_unref, :uint,
           :is_readable, :uint,
           :is_writeable, :uint,
           :is_seekable, :uint,
           :reserved1, :pointer,
           :reserved2, :pointer
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_gio_func_(source, condition, data)
  # @param [GIOChannel] source 
  # @param [unknown] condition 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :gio_func, [GIOChannel, :char, :pointer], :int
  
  # (Not documented)
  # 
  # = Fields:
  # :io_read ::
  #   (FFI::Pointer(*)) 
  # :io_write ::
  #   (FFI::Pointer(*)) 
  # :io_seek ::
  #   (FFI::Pointer(*)) 
  # :io_close ::
  #   (FFI::Pointer(*)) 
  # :io_create_watch ::
  #   (FFI::Pointer(*)) 
  # :io_free ::
  #   (FFI::Pointer(*)) 
  # :io_set_flags ::
  #   (FFI::Pointer(*)) 
  # :io_get_flags ::
  #   (FFI::Pointer(*)) 
  class GIOFuncs < FFI::Struct
    layout :io_read, :pointer,
           :io_write, :pointer,
           :io_seek, :pointer,
           :io_close, :pointer,
           :io_create_watch, :pointer,
           :io_free, :pointer,
           :io_set_flags, :pointer,
           :io_get_flags, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_io_channel_init(channel)
  # @param [GIOChannel] channel 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_init, :g_io_channel_init, [GIOChannel], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_ref(channel)
  # @param [GIOChannel] channel 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_ref, :g_io_channel_ref, [GIOChannel], GIOChannel
  
  # (Not documented)
  # 
  # @method g_io_channel_unref(channel)
  # @param [GIOChannel] channel 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_unref, :g_io_channel_unref, [GIOChannel], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_read(channel, buf, count, bytes_read)
  # @param [GIOChannel] channel 
  # @param [String] buf 
  # @param [Integer] count 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @return [Symbol from _enum_gio_error_] 
  # @scope class
  attach_function :g_io_channel_read, :g_io_channel_read, [GIOChannel, :string, :uint, :pointer], :gio_error
  
  # (Not documented)
  # 
  # @method g_io_channel_write(channel, buf, count, bytes_written)
  # @param [GIOChannel] channel 
  # @param [String] buf 
  # @param [Integer] count 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @return [Symbol from _enum_gio_error_] 
  # @scope class
  attach_function :g_io_channel_write, :g_io_channel_write, [GIOChannel, :string, :uint, :pointer], :gio_error
  
  # (Not documented)
  # 
  # @method g_io_channel_seek(channel, offset, type)
  # @param [GIOChannel] channel 
  # @param [Integer] offset 
  # @param [Symbol from _enum_g_seek_type_] type 
  # @return [Symbol from _enum_gio_error_] 
  # @scope class
  attach_function :g_io_channel_seek, :g_io_channel_seek, [GIOChannel, :long_long, :g_seek_type], :gio_error
  
  # (Not documented)
  # 
  # @method g_io_channel_close(channel)
  # @param [GIOChannel] channel 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_close, :g_io_channel_close, [GIOChannel], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_shutdown(channel, flush, err)
  # @param [GIOChannel] channel 
  # @param [Integer] flush 
  # @param [FFI::Pointer(**GError)] err 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_shutdown, :g_io_channel_shutdown, [GIOChannel, :int, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_add_watch_full(channel, priority, condition, func, user_data, notify)
  # @param [GIOChannel] channel 
  # @param [Integer] priority 
  # @param [unknown] condition 
  # @param [Proc(_callback_gio_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_add_watch_full, :g_io_add_watch_full, [GIOChannel, :int, :char, :gio_func, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_io_create_watch(channel, condition)
  # @param [GIOChannel] channel 
  # @param [unknown] condition 
  # @return [GSource] 
  # @scope class
  attach_function :g_io_create_watch, :g_io_create_watch, [GIOChannel, :char], GSource
  
  # (Not documented)
  # 
  # @method g_io_add_watch(channel, condition, func, user_data)
  # @param [GIOChannel] channel 
  # @param [unknown] condition 
  # @param [Proc(_callback_gio_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_add_watch, :g_io_add_watch, [GIOChannel, :char, :gio_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_io_channel_set_buffer_size(channel, size)
  # @param [GIOChannel] channel 
  # @param [Integer] size 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_set_buffer_size, :g_io_channel_set_buffer_size, [GIOChannel, :uint], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_get_buffer_size(channel)
  # @param [GIOChannel] channel 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_get_buffer_size, :g_io_channel_get_buffer_size, [GIOChannel], :uint
  
  # (Not documented)
  # 
  # @method g_io_channel_get_buffer_condition(channel)
  # @param [GIOChannel] channel 
  # @return [unknown] 
  # @scope class
  attach_function :g_io_channel_get_buffer_condition, :g_io_channel_get_buffer_condition, [GIOChannel], :char
  
  # (Not documented)
  # 
  # @method g_io_channel_set_flags(channel, flags, error)
  # @param [GIOChannel] channel 
  # @param [Symbol from _enum_gio_flags_] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_set_flags, :g_io_channel_set_flags, [GIOChannel, :gio_flags, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_get_flags(channel)
  # @param [GIOChannel] channel 
  # @return [Symbol from _enum_gio_flags_] 
  # @scope class
  attach_function :g_io_channel_get_flags, :g_io_channel_get_flags, [GIOChannel], :gio_flags
  
  # (Not documented)
  # 
  # @method g_io_channel_set_line_term(channel, line_term, length)
  # @param [GIOChannel] channel 
  # @param [String] line_term 
  # @param [Integer] length 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_set_line_term, :g_io_channel_set_line_term, [GIOChannel, :string, :int], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_get_line_term(channel, length)
  # @param [GIOChannel] channel 
  # @param [FFI::Pointer(*Gint)] length 
  # @return [String] 
  # @scope class
  attach_function :g_io_channel_get_line_term, :g_io_channel_get_line_term, [GIOChannel, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_io_channel_set_buffered(channel, buffered)
  # @param [GIOChannel] channel 
  # @param [Integer] buffered 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_set_buffered, :g_io_channel_set_buffered, [GIOChannel, :int], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_get_buffered(channel)
  # @param [GIOChannel] channel 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_get_buffered, :g_io_channel_get_buffered, [GIOChannel], :int
  
  # (Not documented)
  # 
  # @method g_io_channel_set_encoding(channel, encoding, error)
  # @param [GIOChannel] channel 
  # @param [String] encoding 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_set_encoding, :g_io_channel_set_encoding, [GIOChannel, :string, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_get_encoding(channel)
  # @param [GIOChannel] channel 
  # @return [String] 
  # @scope class
  attach_function :g_io_channel_get_encoding, :g_io_channel_get_encoding, [GIOChannel], :string
  
  # (Not documented)
  # 
  # @method g_io_channel_set_close_on_unref(channel, do_close)
  # @param [GIOChannel] channel 
  # @param [Integer] do_close 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_set_close_on_unref, :g_io_channel_set_close_on_unref, [GIOChannel, :int], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_get_close_on_unref(channel)
  # @param [GIOChannel] channel 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_get_close_on_unref, :g_io_channel_get_close_on_unref, [GIOChannel], :int
  
  # (Not documented)
  # 
  # @method g_io_channel_flush(channel, error)
  # @param [GIOChannel] channel 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_flush, :g_io_channel_flush, [GIOChannel, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_read_line(channel, str_return, length, terminator_pos, error)
  # @param [GIOChannel] channel 
  # @param [FFI::Pointer(**Gchar)] str_return 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(*Gsize)] terminator_pos 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_read_line, :g_io_channel_read_line, [GIOChannel, :pointer, :pointer, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_read_line_string(channel, buffer, terminator_pos, error)
  # @param [GIOChannel] channel 
  # @param [GString] buffer 
  # @param [FFI::Pointer(*Gsize)] terminator_pos 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_read_line_string, :g_io_channel_read_line_string, [GIOChannel, GString, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_read_to_end(channel, str_return, length, error)
  # @param [GIOChannel] channel 
  # @param [FFI::Pointer(**Gchar)] str_return 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_read_to_end, :g_io_channel_read_to_end, [GIOChannel, :pointer, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_read_chars(channel, buf, count, bytes_read, error)
  # @param [GIOChannel] channel 
  # @param [String] buf 
  # @param [Integer] count 
  # @param [FFI::Pointer(*Gsize)] bytes_read 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_read_chars, :g_io_channel_read_chars, [GIOChannel, :string, :uint, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_read_unichar(channel, thechar, error)
  # @param [GIOChannel] channel 
  # @param [FFI::Pointer(*Gunichar)] thechar 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_read_unichar, :g_io_channel_read_unichar, [GIOChannel, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_write_chars(channel, buf, count, bytes_written, error)
  # @param [GIOChannel] channel 
  # @param [String] buf 
  # @param [Integer] count 
  # @param [FFI::Pointer(*Gsize)] bytes_written 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_write_chars, :g_io_channel_write_chars, [GIOChannel, :string, :int, :pointer, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_write_unichar(channel, thechar, error)
  # @param [GIOChannel] channel 
  # @param [Integer] thechar 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_write_unichar, :g_io_channel_write_unichar, [GIOChannel, :uint, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_seek_position(channel, offset, type, error)
  # @param [GIOChannel] channel 
  # @param [Integer] offset 
  # @param [Symbol from _enum_g_seek_type_] type 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Symbol from _enum_gio_status_] 
  # @scope class
  attach_function :g_io_channel_seek_position, :g_io_channel_seek_position, [GIOChannel, :long_long, :g_seek_type, :pointer], :gio_status
  
  # (Not documented)
  # 
  # @method g_io_channel_new_file_utf8(filename, mode, error)
  # @param [String] filename 
  # @param [String] mode 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_new_file_utf8, :g_io_channel_new_file_utf8, [:string, :string, :pointer], GIOChannel
  
  # (Not documented)
  # 
  # @method g_io_channel_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_error_quark, :g_io_channel_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_io_channel_error_from_errno(en)
  # @param [Integer] en 
  # @return [Symbol from _enum_gio_channel_error_] 
  # @scope class
  attach_function :g_io_channel_error_from_errno, :g_io_channel_error_from_errno, [:int], :gio_channel_error
  
  # (Not documented)
  # 
  # @method g_io_channel_unix_new(fd)
  # @param [Integer] fd 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_unix_new, :g_io_channel_unix_new, [:int], GIOChannel
  
  # (Not documented)
  # 
  # @method g_io_channel_unix_get_fd(channel)
  # @param [GIOChannel] channel 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_unix_get_fd, :g_io_channel_unix_get_fd, [GIOChannel], :int
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_make_pollfd(channel, condition, fd)
  # @param [GIOChannel] channel 
  # @param [unknown] condition 
  # @param [GPollFD] fd 
  # @return [nil] 
  # @scope class
  attach_function :g_io_channel_win32_make_pollfd, :g_io_channel_win32_make_pollfd, [GIOChannel, :char, GPollFD], :void
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_poll(fds, n_fds, timeout)
  # @param [GPollFD] fds 
  # @param [Integer] n_fds 
  # @param [Integer] timeout 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_win32_poll, :g_io_channel_win32_poll, [GPollFD, :int, :int], :int
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_new_messages(hwnd)
  # @param [Integer] hwnd 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_win32_new_messages, :g_io_channel_win32_new_messages, [:uint], GIOChannel
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_new_fd(fd)
  # @param [Integer] fd 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_win32_new_fd, :g_io_channel_win32_new_fd, [:int], GIOChannel
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_get_fd(channel)
  # @param [GIOChannel] channel 
  # @return [Integer] 
  # @scope class
  attach_function :g_io_channel_win32_get_fd, :g_io_channel_win32_get_fd, [GIOChannel], :int
  
  # (Not documented)
  # 
  # @method g_io_channel_win32_new_socket(socket)
  # @param [Integer] socket 
  # @return [GIOChannel] 
  # @scope class
  attach_function :g_io_channel_win32_new_socket, :g_io_channel_win32_new_socket, [:int], GIOChannel
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_key_file_error).</em>
  # 
  # === Options:
  # :unknown_encoding ::
  #   
  # :parse ::
  #   
  # :not_found ::
  #   
  # :key_not_found ::
  #   
  # :group_not_found ::
  #   
  # :invalid_value ::
  #   
  # 
  # @method _enum_g_key_file_error_
  # @return [Symbol]
  # @scope class
  enum :g_key_file_error, [
    :unknown_encoding, 0,
    :parse, 1,
    :not_found, 2,
    :key_not_found, 3,
    :group_not_found, 4,
    :invalid_value, 5
  ]
  
  # (Not documented)
  # 
  # @method g_key_file_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_error_quark, :g_key_file_error_quark, [], :uint
  
  # (Not documented)
  module GKeyFileWrappers
    # @return [GKeyFile] 
    def ref()
      GKeyFile.new Glib.g_key_file_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_key_file_unref(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_key_file_free(self)
    end
    
    # @param [Integer] separator 
    # @return [nil] 
    def set_list_separator(separator)
      Glib.g_key_file_set_list_separator(self, separator)
    end
    
    # @param [String] file 
    # @param [Symbol from _enum_g_key_file_flags_] flags 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_file(file, flags, error)
      Glib.g_key_file_load_from_file(self, file, flags, error)
    end
    
    # @param [String] data 
    # @param [Integer] length 
    # @param [Symbol from _enum_g_key_file_flags_] flags 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_data(data, length, flags, error)
      Glib.g_key_file_load_from_data(self, data, length, flags, error)
    end
    
    # @param [String] file 
    # @param [FFI::Pointer(**Gchar)] search_dirs 
    # @param [FFI::Pointer(**Gchar)] full_path 
    # @param [Symbol from _enum_g_key_file_flags_] flags 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_dirs(file, search_dirs, full_path, flags, error)
      Glib.g_key_file_load_from_dirs(self, file, search_dirs, full_path, flags, error)
    end
    
    # @param [String] file 
    # @param [FFI::Pointer(**Gchar)] full_path 
    # @param [Symbol from _enum_g_key_file_flags_] flags 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def load_from_data_dirs(file, full_path, flags, error)
      Glib.g_key_file_load_from_data_dirs(self, file, full_path, flags, error)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def to_data(length, error)
      Glib.g_key_file_to_data(self, length, error)
    end
    
    # @return [String] 
    def get_start_group()
      Glib.g_key_file_get_start_group(self)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def get_groups(length)
      Glib.g_key_file_get_groups(self, length)
    end
    
    # @param [String] group_name 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def get_keys(group_name, length, error)
      Glib.g_key_file_get_keys(self, group_name, length, error)
    end
    
    # @param [String] group_name 
    # @return [Integer] 
    def has_group(group_name)
      Glib.g_key_file_has_group(self, group_name)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def has_key(group_name, key, error)
      Glib.g_key_file_has_key(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_value(group_name, key, error)
      Glib.g_key_file_get_value(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] value 
    # @return [nil] 
    def set_value(group_name, key, value)
      Glib.g_key_file_set_value(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_string(group_name, key, error)
      Glib.g_key_file_get_string(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] string 
    # @return [nil] 
    def set_string(group_name, key, string)
      Glib.g_key_file_set_string(self, group_name, key, string)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] locale 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_locale_string(group_name, key, locale, error)
      Glib.g_key_file_get_locale_string(self, group_name, key, locale, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] locale 
    # @param [String] string 
    # @return [nil] 
    def set_locale_string(group_name, key, locale, string)
      Glib.g_key_file_set_locale_string(self, group_name, key, locale, string)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_boolean(group_name, key, error)
      Glib.g_key_file_get_boolean(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [Integer] value 
    # @return [nil] 
    def set_boolean(group_name, key, value)
      Glib.g_key_file_set_boolean(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_integer(group_name, key, error)
      Glib.g_key_file_get_integer(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [Integer] value 
    # @return [nil] 
    def set_integer(group_name, key, value)
      Glib.g_key_file_set_integer(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_int64(group_name, key, error)
      Glib.g_key_file_get_int64(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [Integer] value 
    # @return [nil] 
    def set_int64(group_name, key, value)
      Glib.g_key_file_set_int64(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def get_uint64(group_name, key, error)
      Glib.g_key_file_get_uint64(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [Integer] value 
    # @return [nil] 
    def set_uint64(group_name, key, value)
      Glib.g_key_file_set_uint64(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Float] 
    def get_double(group_name, key, error)
      Glib.g_key_file_get_double(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [Float] value 
    # @return [nil] 
    def set_double(group_name, key, value)
      Glib.g_key_file_set_double(self, group_name, key, value)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def get_string_list(group_name, key, length, error)
      Glib.g_key_file_get_string_list(self, group_name, key, length, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] locale 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def get_locale_string_list(group_name, key, locale, length, error)
      Glib.g_key_file_get_locale_string_list(self, group_name, key, locale, length, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(*Gboolean)] 
    def get_boolean_list(group_name, key, length, error)
      Glib.g_key_file_get_boolean_list(self, group_name, key, length, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(*Gint)] 
    def get_integer_list(group_name, key, length, error)
      Glib.g_key_file_get_integer_list(self, group_name, key, length, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(*Gsize)] length 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(*Gdouble)] 
    def get_double_list(group_name, key, length, error)
      Glib.g_key_file_get_double_list(self, group_name, key, length, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [String] comment 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def set_comment(group_name, key, comment, error)
      Glib.g_key_file_set_comment(self, group_name, key, comment, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def get_comment(group_name, key, error)
      Glib.g_key_file_get_comment(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_comment(group_name, key, error)
      Glib.g_key_file_remove_comment(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [String] key 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_key(group_name, key, error)
      Glib.g_key_file_remove_key(self, group_name, key, error)
    end
    
    # @param [String] group_name 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def remove_group(group_name, error)
      Glib.g_key_file_remove_group(self, group_name, error)
    end
  end
  
  class GKeyFile < FFI::Struct
    include GKeyFileWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_key_file_flags).</em>
  # 
  # === Options:
  # :none ::
  #   
  # :keep_comments ::
  #   
  # :keep_translations ::
  #   
  # 
  # @method _enum_g_key_file_flags_
  # @return [Symbol]
  # @scope class
  enum :g_key_file_flags, [
    :none, 0,
    :keep_comments, 1,
    :keep_translations, 2
  ]
  
  # (Not documented)
  # 
  # @method g_key_file_new()
  # @return [GKeyFile] 
  # @scope class
  attach_function :g_key_file_new, :g_key_file_new, [], GKeyFile
  
  # (Not documented)
  # 
  # @method g_key_file_ref(key_file)
  # @param [GKeyFile] key_file 
  # @return [GKeyFile] 
  # @scope class
  attach_function :g_key_file_ref, :g_key_file_ref, [GKeyFile], GKeyFile
  
  # (Not documented)
  # 
  # @method g_key_file_unref(key_file)
  # @param [GKeyFile] key_file 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_unref, :g_key_file_unref, [GKeyFile], :void
  
  # (Not documented)
  # 
  # @method g_key_file_free(key_file)
  # @param [GKeyFile] key_file 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_free, :g_key_file_free, [GKeyFile], :void
  
  # (Not documented)
  # 
  # @method g_key_file_set_list_separator(key_file, separator)
  # @param [GKeyFile] key_file 
  # @param [Integer] separator 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_list_separator, :g_key_file_set_list_separator, [GKeyFile, :char], :void
  
  # (Not documented)
  # 
  # @method g_key_file_load_from_file(key_file, file, flags, error)
  # @param [GKeyFile] key_file 
  # @param [String] file 
  # @param [Symbol from _enum_g_key_file_flags_] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_load_from_file, :g_key_file_load_from_file, [GKeyFile, :string, :g_key_file_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_load_from_data(key_file, data, length, flags, error)
  # @param [GKeyFile] key_file 
  # @param [String] data 
  # @param [Integer] length 
  # @param [Symbol from _enum_g_key_file_flags_] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_load_from_data, :g_key_file_load_from_data, [GKeyFile, :string, :uint, :g_key_file_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flags, error)
  # @param [GKeyFile] key_file 
  # @param [String] file 
  # @param [FFI::Pointer(**Gchar)] search_dirs 
  # @param [FFI::Pointer(**Gchar)] full_path 
  # @param [Symbol from _enum_g_key_file_flags_] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_load_from_dirs, :g_key_file_load_from_dirs, [GKeyFile, :string, :pointer, :pointer, :g_key_file_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error)
  # @param [GKeyFile] key_file 
  # @param [String] file 
  # @param [FFI::Pointer(**Gchar)] full_path 
  # @param [Symbol from _enum_g_key_file_flags_] flags 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_load_from_data_dirs, :g_key_file_load_from_data_dirs, [GKeyFile, :string, :pointer, :g_key_file_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_to_data(key_file, length, error)
  # @param [GKeyFile] key_file 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_to_data, :g_key_file_to_data, [GKeyFile, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_key_file_get_start_group(key_file)
  # @param [GKeyFile] key_file 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_get_start_group, :g_key_file_get_start_group, [GKeyFile], :string
  
  # (Not documented)
  # 
  # @method g_key_file_get_groups(key_file, length)
  # @param [GKeyFile] key_file 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_key_file_get_groups, :g_key_file_get_groups, [GKeyFile, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_get_keys(key_file, group_name, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_key_file_get_keys, :g_key_file_get_keys, [GKeyFile, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_has_group(key_file, group_name)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_has_group, :g_key_file_has_group, [GKeyFile, :string], :int
  
  # (Not documented)
  # 
  # @method g_key_file_has_key(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_has_key, :g_key_file_has_key, [GKeyFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_get_value(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_get_value, :g_key_file_get_value, [GKeyFile, :string, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_key_file_set_value(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_value, :g_key_file_set_value, [GKeyFile, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_string(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_get_string, :g_key_file_get_string, [GKeyFile, :string, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_key_file_set_string(key_file, group_name, key, string)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] string 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_string, :g_key_file_set_string, [GKeyFile, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_locale_string(key_file, group_name, key, locale, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] locale 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_get_locale_string, :g_key_file_get_locale_string, [GKeyFile, :string, :string, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_key_file_set_locale_string(key_file, group_name, key, locale, string)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] locale 
  # @param [String] string 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_locale_string, :g_key_file_set_locale_string, [GKeyFile, :string, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_boolean(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_get_boolean, :g_key_file_get_boolean, [GKeyFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_set_boolean(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [Integer] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_boolean, :g_key_file_set_boolean, [GKeyFile, :string, :string, :int], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_integer(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_get_integer, :g_key_file_get_integer, [GKeyFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_set_integer(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [Integer] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_integer, :g_key_file_set_integer, [GKeyFile, :string, :string, :int], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_int64(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_get_int64, :g_key_file_get_int64, [GKeyFile, :string, :string, :pointer], :long_long
  
  # (Not documented)
  # 
  # @method g_key_file_set_int64(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [Integer] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_int64, :g_key_file_set_int64, [GKeyFile, :string, :string, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_uint64(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_get_uint64, :g_key_file_get_uint64, [GKeyFile, :string, :string, :pointer], :ulong_long
  
  # (Not documented)
  # 
  # @method g_key_file_set_uint64(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [Integer] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_uint64, :g_key_file_set_uint64, [GKeyFile, :string, :string, :ulong_long], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_double(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Float] 
  # @scope class
  attach_function :g_key_file_get_double, :g_key_file_get_double, [GKeyFile, :string, :string, :pointer], :double
  
  # (Not documented)
  # 
  # @method g_key_file_set_double(key_file, group_name, key, value)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [Float] value 
  # @return [nil] 
  # @scope class
  attach_function :g_key_file_set_double, :g_key_file_set_double, [GKeyFile, :string, :string, :double], :void
  
  # (Not documented)
  # 
  # @method g_key_file_get_string_list(key_file, group_name, key, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_key_file_get_string_list, :g_key_file_get_string_list, [GKeyFile, :string, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_get_locale_string_list(key_file, group_name, key, locale, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] locale 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_key_file_get_locale_string_list, :g_key_file_get_locale_string_list, [GKeyFile, :string, :string, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_get_boolean_list(key_file, group_name, key, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gboolean)] 
  # @scope class
  attach_function :g_key_file_get_boolean_list, :g_key_file_get_boolean_list, [GKeyFile, :string, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_get_integer_list(key_file, group_name, key, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gint)] 
  # @scope class
  attach_function :g_key_file_get_integer_list, :g_key_file_get_integer_list, [GKeyFile, :string, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_get_double_list(key_file, group_name, key, length, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(*Gsize)] length 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(*Gdouble)] 
  # @scope class
  attach_function :g_key_file_get_double_list, :g_key_file_get_double_list, [GKeyFile, :string, :string, :pointer, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_key_file_set_comment(key_file, group_name, key, comment, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [String] comment 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_set_comment, :g_key_file_set_comment, [GKeyFile, :string, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_get_comment(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_key_file_get_comment, :g_key_file_get_comment, [GKeyFile, :string, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_key_file_remove_comment(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_remove_comment, :g_key_file_remove_comment, [GKeyFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_remove_key(key_file, group_name, key, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [String] key 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_remove_key, :g_key_file_remove_key, [GKeyFile, :string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_key_file_remove_group(key_file, group_name, error)
  # @param [GKeyFile] key_file 
  # @param [String] group_name 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_key_file_remove_group, :g_key_file_remove_group, [GKeyFile, :string, :pointer], :int
  
  # (Not documented)
  module GMappedFileWrappers
    # @return [Integer] 
    def get_length()
      Glib.g_mapped_file_get_length(self)
    end
    
    # @return [String] 
    def get_contents()
      Glib.g_mapped_file_get_contents(self)
    end
    
    # @return [GBytes] 
    def get_bytes()
      GBytes.new Glib.g_mapped_file_get_bytes(self)
    end
    
    # @return [GMappedFile] 
    def ref()
      GMappedFile.new Glib.g_mapped_file_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_mapped_file_unref(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_mapped_file_free(self)
    end
  end
  
  class GMappedFile < FFI::Struct
    include GMappedFileWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_mapped_file_new(filename, writable, error)
  # @param [String] filename 
  # @param [Integer] writable 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GMappedFile] 
  # @scope class
  attach_function :g_mapped_file_new, :g_mapped_file_new, [:string, :int, :pointer], GMappedFile
  
  # (Not documented)
  # 
  # @method g_mapped_file_new_from_fd(fd, writable, error)
  # @param [Integer] fd 
  # @param [Integer] writable 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GMappedFile] 
  # @scope class
  attach_function :g_mapped_file_new_from_fd, :g_mapped_file_new_from_fd, [:int, :int, :pointer], GMappedFile
  
  # (Not documented)
  # 
  # @method g_mapped_file_get_length(file)
  # @param [GMappedFile] file 
  # @return [Integer] 
  # @scope class
  attach_function :g_mapped_file_get_length, :g_mapped_file_get_length, [GMappedFile], :uint
  
  # (Not documented)
  # 
  # @method g_mapped_file_get_contents(file)
  # @param [GMappedFile] file 
  # @return [String] 
  # @scope class
  attach_function :g_mapped_file_get_contents, :g_mapped_file_get_contents, [GMappedFile], :string
  
  # (Not documented)
  # 
  # @method g_mapped_file_get_bytes(file)
  # @param [GMappedFile] file 
  # @return [GBytes] 
  # @scope class
  attach_function :g_mapped_file_get_bytes, :g_mapped_file_get_bytes, [GMappedFile], GBytes
  
  # (Not documented)
  # 
  # @method g_mapped_file_ref(file)
  # @param [GMappedFile] file 
  # @return [GMappedFile] 
  # @scope class
  attach_function :g_mapped_file_ref, :g_mapped_file_ref, [GMappedFile], GMappedFile
  
  # (Not documented)
  # 
  # @method g_mapped_file_unref(file)
  # @param [GMappedFile] file 
  # @return [nil] 
  # @scope class
  attach_function :g_mapped_file_unref, :g_mapped_file_unref, [GMappedFile], :void
  
  # (Not documented)
  # 
  # @method g_mapped_file_free(file)
  # @param [GMappedFile] file 
  # @return [nil] 
  # @scope class
  attach_function :g_mapped_file_free, :g_mapped_file_free, [GMappedFile], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_markup_error).</em>
  # 
  # === Options:
  # :bad_utf8 ::
  #   
  # :empty ::
  #   
  # :parse ::
  #   
  # :unknown_element ::
  #   The following are primarily intended for specific GMarkupParser
  #   implementations to set.
  # :unknown_attribute ::
  #   
  # :invalid_content ::
  #   
  # :missing_attribute ::
  #   
  # 
  # @method _enum_g_markup_error_
  # @return [Symbol]
  # @scope class
  enum :g_markup_error, [
    :bad_utf8, 0,
    :empty, 1,
    :parse, 2,
    :unknown_element, 3,
    :unknown_attribute, 4,
    :invalid_content, 5,
    :missing_attribute, 6
  ]
  
  # (Not documented)
  # 
  # @method g_markup_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_markup_error_quark, :g_markup_error_quark, [], :uint
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_markup_parse_flags).</em>
  # 
  # === Options:
  # :do_not_use_this_unsupported_flag ::
  #   
  # :treat_cdata_as_text ::
  #   
  # :prefix_error_position ::
  #   
  # 
  # @method _enum_g_markup_parse_flags_
  # @return [Symbol]
  # @scope class
  enum :g_markup_parse_flags, [
    :do_not_use_this_unsupported_flag, 1,
    :treat_cdata_as_text, 2,
    :prefix_error_position, 4
  ]
  
  # (Not documented)
  module GMarkupParseContextWrappers
    # @return [nil] 
    def free()
      Glib.g_markup_parse_context_free(self)
    end
    
    # @param [String] text 
    # @param [Integer] text_len 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def parse(text, text_len, error)
      Glib.g_markup_parse_context_parse(self, text, text_len, error)
    end
    
    # @param [FFI::Pointer(*GMarkupParser)] parser 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def push(parser, user_data)
      Glib.g_markup_parse_context_push(self, parser, user_data)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def pop()
      Glib.g_markup_parse_context_pop(self)
    end
    
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def end_parse(error)
      Glib.g_markup_parse_context_end_parse(self, error)
    end
    
    # @return [String] 
    def get_element()
      Glib.g_markup_parse_context_get_element(self)
    end
    
    # @return [GSList] 
    def get_element_stack()
      GSList.new Glib.g_markup_parse_context_get_element_stack(self)
    end
    
    # @param [FFI::Pointer(*Gint)] line_number 
    # @param [FFI::Pointer(*Gint)] char_number 
    # @return [nil] 
    def get_position(line_number, char_number)
      Glib.g_markup_parse_context_get_position(self, line_number, char_number)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def get_user_data()
      Glib.g_markup_parse_context_get_user_data(self)
    end
  end
  
  class GMarkupParseContext < FFI::Struct
    include GMarkupParseContextWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :start_element ::
  #   (FFI::Pointer(*)) Called for open tags <foo bar="baz">
  # :end_element ::
  #   (FFI::Pointer(*)) Called for close tags </foo>
  # :text ::
  #   (FFI::Pointer(*)) text is not nul-terminated
  # :passthrough ::
  #   (FFI::Pointer(*)) text is not nul-terminated.
  # :error ::
  #   (FFI::Pointer(*)) Called on error, including one set by other
  #   methods in the vtable. The GError should not be freed.
  class GMarkupParser < FFI::Struct
    layout :start_element, :pointer,
           :end_element, :pointer,
           :text, :pointer,
           :passthrough, :pointer,
           :error, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify)
  # @param [GMarkupParser] parser 
  # @param [Symbol from _enum_g_markup_parse_flags_] flags 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(GDestroyNotify)] user_data_dnotify 
  # @return [GMarkupParseContext] 
  # @scope class
  attach_function :g_markup_parse_context_new, :g_markup_parse_context_new, [GMarkupParser, :g_markup_parse_flags, :pointer, :pointer], GMarkupParseContext
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_free(context)
  # @param [GMarkupParseContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_markup_parse_context_free, :g_markup_parse_context_free, [GMarkupParseContext], :void
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_parse(context, text, text_len, error)
  # @param [GMarkupParseContext] context 
  # @param [String] text 
  # @param [Integer] text_len 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_markup_parse_context_parse, :g_markup_parse_context_parse, [GMarkupParseContext, :string, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_push(context, parser, user_data)
  # @param [GMarkupParseContext] context 
  # @param [GMarkupParser] parser 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_markup_parse_context_push, :g_markup_parse_context_push, [GMarkupParseContext, GMarkupParser, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_pop(context)
  # @param [GMarkupParseContext] context 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_markup_parse_context_pop, :g_markup_parse_context_pop, [GMarkupParseContext], :pointer
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_end_parse(context, error)
  # @param [GMarkupParseContext] context 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_markup_parse_context_end_parse, :g_markup_parse_context_end_parse, [GMarkupParseContext, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_get_element(context)
  # @param [GMarkupParseContext] context 
  # @return [String] 
  # @scope class
  attach_function :g_markup_parse_context_get_element, :g_markup_parse_context_get_element, [GMarkupParseContext], :string
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_get_element_stack(context)
  # @param [GMarkupParseContext] context 
  # @return [GSList] 
  # @scope class
  attach_function :g_markup_parse_context_get_element_stack, :g_markup_parse_context_get_element_stack, [GMarkupParseContext], GSList
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_get_position(context, line_number, char_number)
  # @param [GMarkupParseContext] context 
  # @param [FFI::Pointer(*Gint)] line_number 
  # @param [FFI::Pointer(*Gint)] char_number 
  # @return [nil] 
  # @scope class
  attach_function :g_markup_parse_context_get_position, :g_markup_parse_context_get_position, [GMarkupParseContext, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_markup_parse_context_get_user_data(context)
  # @param [GMarkupParseContext] context 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_markup_parse_context_get_user_data, :g_markup_parse_context_get_user_data, [GMarkupParseContext], :pointer
  
  # (Not documented)
  # 
  # @method g_markup_escape_text(text, length)
  # @param [String] text 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_markup_escape_text, :g_markup_escape_text, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_markup_printf_escaped(format)
  # @param [String] format 
  # @return [String] 
  # @scope class
  attach_function :g_markup_printf_escaped, :g_markup_printf_escaped, [:string], :string
  
  # (Not documented)
  # 
  # @method g_markup_vprintf_escaped(format, args)
  # @param [String] format 
  # @param [String] args 
  # @return [String] 
  # @scope class
  attach_function :g_markup_vprintf_escaped, :g_markup_vprintf_escaped, [:string, :string], :string
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_markup_collect_type).</em>
  # 
  # === Options:
  # :invalid ::
  #   
  # :string ::
  #   
  # :strdup ::
  #   
  # :boolean ::
  #   
  # :tristate ::
  #   
  # :optional ::
  #   
  # 
  # @method _enum_g_markup_collect_type_
  # @return [Symbol]
  # @scope class
  enum :g_markup_collect_type, [
    :invalid, 0,
    :string, 1,
    :strdup, 2,
    :boolean, 3,
    :tristate, 4,
    :optional, 65536
  ]
  
  # (Not documented)
  # 
  # @method g_markup_collect_attributes(element_name, attribute_names, attribute_values, error, first_type, first_attr)
  # @param [String] element_name 
  # @param [FFI::Pointer(**Gchar)] attribute_names 
  # @param [FFI::Pointer(**Gchar)] attribute_values 
  # @param [FFI::Pointer(**GError)] error 
  # @param [Symbol from _enum_g_markup_collect_type_] first_type 
  # @param [String] first_attr 
  # @return [Integer] 
  # @scope class
  attach_function :g_markup_collect_attributes, :g_markup_collect_attributes, [:string, :pointer, :pointer, :pointer, :g_markup_collect_type, :string], :int
  
  # (Not documented)
  # 
  # @method g_printf_string_upper_bound(format, args)
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_printf_string_upper_bound, :g_printf_string_upper_bound, [:string, :string], :uint
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_log_level_flags).</em>
  # 
  # === Options:
  # :flag_recursion ::
  #   log flags
  # :flag_fatal ::
  #   
  # :level_error ::
  #   GLib log levels
  # :level_critical ::
  #   always fatal
  # :level_warning ::
  #   
  # :level_message ::
  #   
  # :level_info ::
  #   
  # :level_debug ::
  #   
  # 
  # @method _enum_g_log_level_flags_
  # @return [Symbol]
  # @scope class
  enum :g_log_level_flags, [
    :flag_recursion, 1,
    :flag_fatal, 2,
    :level_error, 4,
    :level_critical, 8,
    :level_warning, 16,
    :level_message, 32,
    :level_info, 64,
    :level_debug, 128
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_log_func_(log_level, message, user_data)
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] message 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [String] 
  # @scope class
  callback :g_log_func, [:g_log_level_flags, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_log_set_handler(log_domain, log_levels, log_func, user_data)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_levels 
  # @param [Proc(_callback_g_log_func_)] log_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  attach_function :g_log_set_handler, :g_log_set_handler, [:string, :g_log_level_flags, :g_log_func, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_log_remove_handler(log_domain, handler_id)
  # @param [String] log_domain 
  # @param [Integer] handler_id 
  # @return [nil] 
  # @scope class
  attach_function :g_log_remove_handler, :g_log_remove_handler, [:string, :uint], :void
  
  # (Not documented)
  # 
  # @method g_log_default_handler(log_domain, log_level, message, unused_data)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] message 
  # @param [FFI::Pointer(Gpointer)] unused_data 
  # @return [nil] 
  # @scope class
  attach_function :g_log_default_handler, :g_log_default_handler, [:string, :g_log_level_flags, :string, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_log_set_default_handler(log_func, user_data)
  # @param [Proc(_callback_g_log_func_)] log_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Proc(_callback_g_log_func_)] 
  # @scope class
  attach_function :g_log_set_default_handler, :g_log_set_default_handler, [:g_log_func, :pointer], :g_log_func
  
  # (Not documented)
  # 
  # @method g_log(log_domain, log_level, format)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_log, :g_log, [:string, :g_log_level_flags, :string], :void
  
  # (Not documented)
  # 
  # @method g_logv(log_domain, log_level, format, args)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] format 
  # @param [String] args 
  # @return [nil] 
  # @scope class
  attach_function :g_logv, :g_logv, [:string, :g_log_level_flags, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_log_set_fatal_mask(log_domain, fatal_mask)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] fatal_mask 
  # @return [Symbol from _enum_g_log_level_flags_] 
  # @scope class
  attach_function :g_log_set_fatal_mask, :g_log_set_fatal_mask, [:string, :g_log_level_flags], :g_log_level_flags
  
  # (Not documented)
  # 
  # @method g_log_set_always_fatal(fatal_mask)
  # @param [Symbol from _enum_g_log_level_flags_] fatal_mask 
  # @return [Symbol from _enum_g_log_level_flags_] 
  # @scope class
  attach_function :g_log_set_always_fatal, :g_log_set_always_fatal, [:g_log_level_flags], :g_log_level_flags
  
  # (Not documented)
  # 
  # @method g_log_fallback_handler(log_domain, log_level, message, unused_data)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] message 
  # @param [FFI::Pointer(Gpointer)] unused_data 
  # @return [nil] 
  # @scope class
  attach_function :g_log_fallback_handler, :_g_log_fallback_handler, [:string, :g_log_level_flags, :string, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_return_if_fail_warning(log_domain, pretty_function, expression)
  # @param [String] log_domain 
  # @param [String] pretty_function 
  # @param [String] expression 
  # @return [nil] 
  # @scope class
  attach_function :g_return_if_fail_warning, :g_return_if_fail_warning, [:string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_warn_message(domain, file, line, func, warnexpr)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [String] warnexpr 
  # @return [nil] 
  # @scope class
  attach_function :g_warn_message, :g_warn_message, [:string, :string, :int, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_assert_warning(log_domain, file, line, pretty_function, expression)
  # @param [String] log_domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] pretty_function 
  # @param [String] expression 
  # @return [nil] 
  # @scope class
  attach_function :g_assert_warning, :g_assert_warning, [:string, :string, :int, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_print(format)
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_print, :g_print, [:string], :void
  
  # (Not documented)
  # 
  # @method g_set_print_handler(func)
  # @param [FFI::Pointer(GPrintFunc)] func 
  # @return [FFI::Pointer(GPrintFunc)] 
  # @scope class
  attach_function :g_set_print_handler, :g_set_print_handler, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_printerr(format)
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_printerr, :g_printerr, [:string], :void
  
  # (Not documented)
  # 
  # @method g_set_printerr_handler(func)
  # @param [FFI::Pointer(GPrintFunc)] func 
  # @return [FFI::Pointer(GPrintFunc)] 
  # @scope class
  attach_function :g_set_printerr_handler, :g_set_printerr_handler, [:pointer], :pointer
  
  # (Not documented)
  module GOptionContextWrappers
    # @param [String] summary 
    # @return [nil] 
    def set_summary(summary)
      Glib.g_option_context_set_summary(self, summary)
    end
    
    # @return [String] 
    def get_summary()
      Glib.g_option_context_get_summary(self)
    end
    
    # @param [String] description 
    # @return [nil] 
    def set_description(description)
      Glib.g_option_context_set_description(self, description)
    end
    
    # @return [String] 
    def get_description()
      Glib.g_option_context_get_description(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_option_context_free(self)
    end
    
    # @param [Integer] help_enabled 
    # @return [nil] 
    def set_help_enabled(help_enabled)
      Glib.g_option_context_set_help_enabled(self, help_enabled)
    end
    
    # @return [Integer] 
    def get_help_enabled()
      Glib.g_option_context_get_help_enabled(self)
    end
    
    # @param [Integer] ignore_unknown 
    # @return [nil] 
    def set_ignore_unknown_options(ignore_unknown)
      Glib.g_option_context_set_ignore_unknown_options(self, ignore_unknown)
    end
    
    # @return [Integer] 
    def get_ignore_unknown_options()
      Glib.g_option_context_get_ignore_unknown_options(self)
    end
    
    # @param [FFI::Pointer(*GOptionEntry)] entries 
    # @param [String] translation_domain 
    # @return [nil] 
    def add_main_entries(entries, translation_domain)
      Glib.g_option_context_add_main_entries(self, entries, translation_domain)
    end
    
    # @param [FFI::Pointer(*Gint)] argc 
    # @param [FFI::Pointer(***Gchar)] argv 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def parse(argc, argv, error)
      Glib.g_option_context_parse(self, argc, argv, error)
    end
    
    # @param [Proc(_callback_g_translate_func_)] func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [FFI::Pointer(GDestroyNotify)] destroy_notify 
    # @return [nil] 
    def set_translate_func(func, data, destroy_notify)
      Glib.g_option_context_set_translate_func(self, func, data, destroy_notify)
    end
    
    # @param [String] domain 
    # @return [nil] 
    def set_translation_domain(domain)
      Glib.g_option_context_set_translation_domain(self, domain)
    end
    
    # @param [FFI::Pointer(*GOptionGroup)] group 
    # @return [nil] 
    def add_group(group)
      Glib.g_option_context_add_group(self, group)
    end
    
    # @param [FFI::Pointer(*GOptionGroup)] group 
    # @return [nil] 
    def set_main_group(group)
      Glib.g_option_context_set_main_group(self, group)
    end
    
    # @return [GOptionGroup] 
    def get_main_group()
      GOptionGroup.new Glib.g_option_context_get_main_group(self)
    end
    
    # @param [Integer] main_help 
    # @param [FFI::Pointer(*GOptionGroup)] group 
    # @return [String] 
    def get_help(main_help, group)
      Glib.g_option_context_get_help(self, main_help, group)
    end
  end
  
  class GOptionContext < FFI::Struct
    include GOptionContextWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  module GOptionGroupWrappers
    # @param [Proc(_callback_g_option_parse_func_)] pre_parse_func 
    # @param [Proc(_callback_g_option_parse_func_)] post_parse_func 
    # @return [nil] 
    def set_parse_hooks(pre_parse_func, post_parse_func)
      Glib.g_option_group_set_parse_hooks(self, pre_parse_func, post_parse_func)
    end
    
    # @param [Proc(_callback_g_option_error_func_)] error_func 
    # @return [nil] 
    def set_error_hook(error_func)
      Glib.g_option_group_set_error_hook(self, error_func)
    end
    
    # @return [nil] 
    def free()
      Glib.g_option_group_free(self)
    end
    
    # @param [FFI::Pointer(*GOptionEntry)] entries 
    # @return [nil] 
    def add_entries(entries)
      Glib.g_option_group_add_entries(self, entries)
    end
    
    # @param [Proc(_callback_g_translate_func_)] func 
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [FFI::Pointer(GDestroyNotify)] destroy_notify 
    # @return [nil] 
    def set_translate_func(func, data, destroy_notify)
      Glib.g_option_group_set_translate_func(self, func, data, destroy_notify)
    end
    
    # @param [String] domain 
    # @return [nil] 
    def set_translation_domain(domain)
      Glib.g_option_group_set_translation_domain(self, domain)
    end
  end
  
  class GOptionGroup < FFI::Struct
    include GOptionGroupWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_option_flags).</em>
  # 
  # === Options:
  # :flag_hidden ::
  #   
  # :flag_in_main ::
  #   
  # :flag_reverse ::
  #   
  # :flag_no_arg ::
  #   
  # :flag_filename ::
  #   
  # :flag_optional_arg ::
  #   
  # :flag_noalias ::
  #   
  # 
  # @method _enum_g_option_flags_
  # @return [Symbol]
  # @scope class
  enum :g_option_flags, [
    :flag_hidden, 1,
    :flag_in_main, 2,
    :flag_reverse, 4,
    :flag_no_arg, 8,
    :flag_filename, 16,
    :flag_optional_arg, 32,
    :flag_noalias, 64
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_option_arg).</em>
  # 
  # === Options:
  # :none ::
  #   
  # :string ::
  #   
  # :int ::
  #   
  # :callback ::
  #   
  # :filename ::
  #   
  # :string_array ::
  #   
  # :filename_array ::
  #   
  # :double ::
  #   
  # :int64 ::
  #   
  # 
  # @method _enum_g_option_arg_
  # @return [Symbol]
  # @scope class
  enum :g_option_arg, [
    :none, 0,
    :string, 1,
    :int, 2,
    :callback, 3,
    :filename, 4,
    :string_array, 5,
    :filename_array, 6,
    :double, 7,
    :int64, 8
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_option_arg_func_(option_name, value, data, error)
  # @param [String] option_name 
  # @param [String] value 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  callback :g_option_arg_func, [:string, :string, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_option_parse_func_(context, group, data, error)
  # @param [GOptionContext] context 
  # @param [GOptionGroup] group 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  callback :g_option_parse_func, [GOptionContext, GOptionGroup, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_option_error_func_(group, data, error)
  # @param [GOptionGroup] group 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GOptionContext] 
  # @scope class
  callback :g_option_error_func, [GOptionGroup, :pointer, :pointer], GOptionContext
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_option_error).</em>
  # 
  # === Options:
  # :unknown_option ::
  #   
  # :bad_value ::
  #   
  # :failed ::
  #   
  # 
  # @method _enum_g_option_error_
  # @return [Symbol]
  # @scope class
  enum :g_option_error, [
    :unknown_option, 0,
    :bad_value, 1,
    :failed, 2
  ]
  
  # (Not documented)
  # 
  # @method g_option_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_option_error_quark, :g_option_error_quark, [], :uint
  
  # (Not documented)
  # 
  # = Fields:
  # :long_name ::
  #   (String) 
  # :short_name ::
  #   (Integer) 
  # :flags ::
  #   (Integer) 
  # :arg ::
  #   (Symbol from _enum_g_option_arg_) 
  # :arg_data ::
  #   (FFI::Pointer(Gpointer)) 
  # :description ::
  #   (String) 
  # :arg_description ::
  #   (String) 
  class GOptionEntry < FFI::Struct
    layout :long_name, :string,
           :short_name, :char,
           :flags, :int,
           :arg, :g_option_arg,
           :arg_data, :pointer,
           :description, :string,
           :arg_description, :string
  end
  
  # (Not documented)
  # 
  # @method g_option_context_new(parameter_string)
  # @param [String] parameter_string 
  # @return [GOptionContext] 
  # @scope class
  attach_function :g_option_context_new, :g_option_context_new, [:string], GOptionContext
  
  # (Not documented)
  # 
  # @method g_option_context_set_summary(context, summary)
  # @param [GOptionContext] context 
  # @param [String] summary 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_summary, :g_option_context_set_summary, [GOptionContext, :string], :void
  
  # (Not documented)
  # 
  # @method g_option_context_get_summary(context)
  # @param [GOptionContext] context 
  # @return [String] 
  # @scope class
  attach_function :g_option_context_get_summary, :g_option_context_get_summary, [GOptionContext], :string
  
  # (Not documented)
  # 
  # @method g_option_context_set_description(context, description)
  # @param [GOptionContext] context 
  # @param [String] description 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_description, :g_option_context_set_description, [GOptionContext, :string], :void
  
  # (Not documented)
  # 
  # @method g_option_context_get_description(context)
  # @param [GOptionContext] context 
  # @return [String] 
  # @scope class
  attach_function :g_option_context_get_description, :g_option_context_get_description, [GOptionContext], :string
  
  # (Not documented)
  # 
  # @method g_option_context_free(context)
  # @param [GOptionContext] context 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_free, :g_option_context_free, [GOptionContext], :void
  
  # (Not documented)
  # 
  # @method g_option_context_set_help_enabled(context, help_enabled)
  # @param [GOptionContext] context 
  # @param [Integer] help_enabled 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_help_enabled, :g_option_context_set_help_enabled, [GOptionContext, :int], :void
  
  # (Not documented)
  # 
  # @method g_option_context_get_help_enabled(context)
  # @param [GOptionContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_option_context_get_help_enabled, :g_option_context_get_help_enabled, [GOptionContext], :int
  
  # (Not documented)
  # 
  # @method g_option_context_set_ignore_unknown_options(context, ignore_unknown)
  # @param [GOptionContext] context 
  # @param [Integer] ignore_unknown 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_ignore_unknown_options, :g_option_context_set_ignore_unknown_options, [GOptionContext, :int], :void
  
  # (Not documented)
  # 
  # @method g_option_context_get_ignore_unknown_options(context)
  # @param [GOptionContext] context 
  # @return [Integer] 
  # @scope class
  attach_function :g_option_context_get_ignore_unknown_options, :g_option_context_get_ignore_unknown_options, [GOptionContext], :int
  
  # (Not documented)
  # 
  # @method g_option_context_add_main_entries(context, entries, translation_domain)
  # @param [GOptionContext] context 
  # @param [GOptionEntry] entries 
  # @param [String] translation_domain 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_add_main_entries, :g_option_context_add_main_entries, [GOptionContext, GOptionEntry, :string], :void
  
  # (Not documented)
  # 
  # @method g_option_context_parse(context, argc, argv, error)
  # @param [GOptionContext] context 
  # @param [FFI::Pointer(*Gint)] argc 
  # @param [FFI::Pointer(***Gchar)] argv 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_option_context_parse, :g_option_context_parse, [GOptionContext, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_option_context_set_translate_func(context, func, data, destroy_notify)
  # @param [GOptionContext] context 
  # @param [Proc(_callback_g_translate_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] destroy_notify 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_translate_func, :g_option_context_set_translate_func, [GOptionContext, :g_translate_func, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_option_context_set_translation_domain(context, domain)
  # @param [GOptionContext] context 
  # @param [String] domain 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_translation_domain, :g_option_context_set_translation_domain, [GOptionContext, :string], :void
  
  # (Not documented)
  # 
  # @method g_option_context_add_group(context, group)
  # @param [GOptionContext] context 
  # @param [GOptionGroup] group 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_add_group, :g_option_context_add_group, [GOptionContext, GOptionGroup], :void
  
  # (Not documented)
  # 
  # @method g_option_context_set_main_group(context, group)
  # @param [GOptionContext] context 
  # @param [GOptionGroup] group 
  # @return [nil] 
  # @scope class
  attach_function :g_option_context_set_main_group, :g_option_context_set_main_group, [GOptionContext, GOptionGroup], :void
  
  # (Not documented)
  # 
  # @method g_option_context_get_main_group(context)
  # @param [GOptionContext] context 
  # @return [GOptionGroup] 
  # @scope class
  attach_function :g_option_context_get_main_group, :g_option_context_get_main_group, [GOptionContext], GOptionGroup
  
  # (Not documented)
  # 
  # @method g_option_context_get_help(context, main_help, group)
  # @param [GOptionContext] context 
  # @param [Integer] main_help 
  # @param [GOptionGroup] group 
  # @return [String] 
  # @scope class
  attach_function :g_option_context_get_help, :g_option_context_get_help, [GOptionContext, :int, GOptionGroup], :string
  
  # (Not documented)
  # 
  # @method g_option_group_new(name, description, help_description, user_data, destroy)
  # @param [String] name 
  # @param [String] description 
  # @param [String] help_description 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(GDestroyNotify)] destroy 
  # @return [GOptionGroup] 
  # @scope class
  attach_function :g_option_group_new, :g_option_group_new, [:string, :string, :string, :pointer, :pointer], GOptionGroup
  
  # (Not documented)
  # 
  # @method g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_func)
  # @param [GOptionGroup] group 
  # @param [Proc(_callback_g_option_parse_func_)] pre_parse_func 
  # @param [Proc(_callback_g_option_parse_func_)] post_parse_func 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_set_parse_hooks, :g_option_group_set_parse_hooks, [GOptionGroup, :g_option_parse_func, :g_option_parse_func], :void
  
  # (Not documented)
  # 
  # @method g_option_group_set_error_hook(group, error_func)
  # @param [GOptionGroup] group 
  # @param [Proc(_callback_g_option_error_func_)] error_func 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_set_error_hook, :g_option_group_set_error_hook, [GOptionGroup, :g_option_error_func], :void
  
  # (Not documented)
  # 
  # @method g_option_group_free(group)
  # @param [GOptionGroup] group 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_free, :g_option_group_free, [GOptionGroup], :void
  
  # (Not documented)
  # 
  # @method g_option_group_add_entries(group, entries)
  # @param [GOptionGroup] group 
  # @param [GOptionEntry] entries 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_add_entries, :g_option_group_add_entries, [GOptionGroup, GOptionEntry], :void
  
  # (Not documented)
  # 
  # @method g_option_group_set_translate_func(group, func, data, destroy_notify)
  # @param [GOptionGroup] group 
  # @param [Proc(_callback_g_translate_func_)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GDestroyNotify)] destroy_notify 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_set_translate_func, :g_option_group_set_translate_func, [GOptionGroup, :g_translate_func, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_option_group_set_translation_domain(group, domain)
  # @param [GOptionGroup] group 
  # @param [String] domain 
  # @return [nil] 
  # @scope class
  attach_function :g_option_group_set_translation_domain, :g_option_group_set_translation_domain, [GOptionGroup, :string], :void
  
  # (Not documented)
  module GPatternSpecWrappers
    # @return [nil] 
    def free()
      Glib.g_pattern_spec_free(self)
    end
    
    # @param [FFI::Pointer(*GPatternSpec)] pspec2 
    # @return [Integer] 
    def equal(pspec2)
      Glib.g_pattern_spec_equal(self, pspec2)
    end
  end
  
  class GPatternSpec < FFI::Struct
    include GPatternSpecWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_pattern_spec_new(pattern)
  # @param [String] pattern 
  # @return [GPatternSpec] 
  # @scope class
  attach_function :g_pattern_spec_new, :g_pattern_spec_new, [:string], GPatternSpec
  
  # (Not documented)
  # 
  # @method g_pattern_spec_free(pspec)
  # @param [GPatternSpec] pspec 
  # @return [nil] 
  # @scope class
  attach_function :g_pattern_spec_free, :g_pattern_spec_free, [GPatternSpec], :void
  
  # (Not documented)
  # 
  # @method g_pattern_spec_equal(pspec1, pspec2)
  # @param [GPatternSpec] pspec1 
  # @param [GPatternSpec] pspec2 
  # @return [Integer] 
  # @scope class
  attach_function :g_pattern_spec_equal, :g_pattern_spec_equal, [GPatternSpec, GPatternSpec], :int
  
  # (Not documented)
  # 
  # @method g_pattern_match(pspec, string_length, string, string_reversed)
  # @param [GPatternSpec] pspec 
  # @param [Integer] string_length 
  # @param [String] string 
  # @param [String] string_reversed 
  # @return [Integer] 
  # @scope class
  attach_function :g_pattern_match, :g_pattern_match, [GPatternSpec, :uint, :string, :string], :int
  
  # (Not documented)
  # 
  # @method g_pattern_match_string(pspec, string)
  # @param [GPatternSpec] pspec 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_pattern_match_string, :g_pattern_match_string, [GPatternSpec, :string], :int
  
  # (Not documented)
  # 
  # @method g_pattern_match_simple(pattern, string)
  # @param [String] pattern 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_pattern_match_simple, :g_pattern_match_simple, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_spaced_primes_closest(num)
  # @param [Integer] num 
  # @return [Integer] 
  # @scope class
  attach_function :g_spaced_primes_closest, :g_spaced_primes_closest, [:uint], :uint
  
  # (Not documented)
  # 
  # @method g_qsort_with_data(pbase, total_elems, size, compare_func, user_data)
  # @param [FFI::Pointer(Gconstpointer)] pbase 
  # @param [Integer] total_elems 
  # @param [Integer] size 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_qsort_with_data, :g_qsort_with_data, [:pointer, :int, :uint, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # = Fields:
  # :head ::
  #   (GList) 
  # :tail ::
  #   (GList) 
  # :length ::
  #   (Integer) 
  module GQueueWrappers
    # @return [nil] 
    def free()
      Glib.g_queue_free(self)
    end
    
    # @param [FFI::Pointer(GDestroyNotify)] free_func 
    # @return [nil] 
    def free_full(free_func)
      Glib.g_queue_free_full(self, free_func)
    end
    
    # @return [nil] 
    def init()
      Glib.g_queue_init(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_queue_clear(self)
    end
    
    # @return [Integer] 
    def is_empty()
      Glib.g_queue_is_empty(self)
    end
    
    # @return [Integer] 
    def get_length()
      Glib.g_queue_get_length(self)
    end
    
    # @return [nil] 
    def reverse()
      Glib.g_queue_reverse(self)
    end
    
    # @return [GQueue] 
    def copy()
      GQueue.new Glib.g_queue_copy(self)
    end
    
    # @param [Proc(_callback_g_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_queue_foreach(self, func, user_data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [GList] 
    def find(data)
      GList.new Glib.g_queue_find(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @param [Proc(_callback_g_compare_func_)] func 
    # @return [GList] 
    def find_custom(data, func)
      GList.new Glib.g_queue_find_custom(self, data, func)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] compare_func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def sort(compare_func, user_data)
      Glib.g_queue_sort(self, compare_func, user_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def push_head(data)
      Glib.g_queue_push_head(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def push_tail(data)
      Glib.g_queue_push_tail(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Integer] n 
    # @return [nil] 
    def push_nth(data, n)
      Glib.g_queue_push_nth(self, data, n)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def pop_head()
      Glib.g_queue_pop_head(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def pop_tail()
      Glib.g_queue_pop_tail(self)
    end
    
    # @param [Integer] n 
    # @return [FFI::Pointer(Gpointer)] 
    def pop_nth(n)
      Glib.g_queue_pop_nth(self, n)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def peek_head()
      Glib.g_queue_peek_head(self)
    end
    
    # @return [FFI::Pointer(Gpointer)] 
    def peek_tail()
      Glib.g_queue_peek_tail(self)
    end
    
    # @param [Integer] n 
    # @return [FFI::Pointer(Gpointer)] 
    def peek_nth(n)
      Glib.g_queue_peek_nth(self, n)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [Integer] 
    def index(data)
      Glib.g_queue_index(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [Integer] 
    def remove(data)
      Glib.g_queue_remove(self, data)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] data 
    # @return [Integer] 
    def remove_all(data)
      Glib.g_queue_remove_all(self, data)
    end
    
    # @param [GList] sibling 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def insert_before(sibling, data)
      Glib.g_queue_insert_before(self, sibling, data)
    end
    
    # @param [GList] sibling 
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def insert_after(sibling, data)
      Glib.g_queue_insert_after(self, sibling, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def insert_sorted(data, func, user_data)
      Glib.g_queue_insert_sorted(self, data, func, user_data)
    end
    
    # @param [GList] link 
    # @return [nil] 
    def push_head_link(link)
      Glib.g_queue_push_head_link(self, link)
    end
    
    # @param [GList] link 
    # @return [nil] 
    def push_tail_link(link)
      Glib.g_queue_push_tail_link(self, link)
    end
    
    # @param [Integer] n 
    # @param [GList] link 
    # @return [nil] 
    def push_nth_link(n, link)
      Glib.g_queue_push_nth_link(self, n, link)
    end
    
    # @return [GList] 
    def pop_head_link()
      GList.new Glib.g_queue_pop_head_link(self)
    end
    
    # @return [GList] 
    def pop_tail_link()
      GList.new Glib.g_queue_pop_tail_link(self)
    end
    
    # @param [Integer] n 
    # @return [GList] 
    def pop_nth_link(n)
      GList.new Glib.g_queue_pop_nth_link(self, n)
    end
    
    # @return [GList] 
    def peek_head_link()
      GList.new Glib.g_queue_peek_head_link(self)
    end
    
    # @return [GList] 
    def peek_tail_link()
      GList.new Glib.g_queue_peek_tail_link(self)
    end
    
    # @param [Integer] n 
    # @return [GList] 
    def peek_nth_link(n)
      GList.new Glib.g_queue_peek_nth_link(self, n)
    end
    
    # @param [GList] link 
    # @return [Integer] 
    def link_index(link)
      Glib.g_queue_link_index(self, link)
    end
    
    # @param [GList] link 
    # @return [nil] 
    def unlink(link)
      Glib.g_queue_unlink(self, link)
    end
    
    # @param [GList] link 
    # @return [nil] 
    def delete_link(link)
      Glib.g_queue_delete_link(self, link)
    end
  end
  
  class GQueue < FFI::Struct
    include GQueueWrappers
    layout :head, GList,
           :tail, GList,
           :length, :uint
  end
  
  # (Not documented)
  # 
  # @method g_queue_new()
  # @return [GQueue] 
  # @scope class
  attach_function :g_queue_new, :g_queue_new, [], GQueue
  
  # (Not documented)
  # 
  # @method g_queue_free(queue)
  # @param [GQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_free, :g_queue_free, [GQueue], :void
  
  # (Not documented)
  # 
  # @method g_queue_free_full(queue, free_func)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(GDestroyNotify)] free_func 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_free_full, :g_queue_free_full, [GQueue, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_init(queue)
  # @param [GQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_init, :g_queue_init, [GQueue], :void
  
  # (Not documented)
  # 
  # @method g_queue_clear(queue)
  # @param [GQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_clear, :g_queue_clear, [GQueue], :void
  
  # (Not documented)
  # 
  # @method g_queue_is_empty(queue)
  # @param [GQueue] queue 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_is_empty, :g_queue_is_empty, [GQueue], :int
  
  # (Not documented)
  # 
  # @method g_queue_get_length(queue)
  # @param [GQueue] queue 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_get_length, :g_queue_get_length, [GQueue], :uint
  
  # (Not documented)
  # 
  # @method g_queue_reverse(queue)
  # @param [GQueue] queue 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_reverse, :g_queue_reverse, [GQueue], :void
  
  # (Not documented)
  # 
  # @method g_queue_copy(queue)
  # @param [GQueue] queue 
  # @return [GQueue] 
  # @scope class
  attach_function :g_queue_copy, :g_queue_copy, [GQueue], GQueue
  
  # (Not documented)
  # 
  # @method g_queue_foreach(queue, func, user_data)
  # @param [GQueue] queue 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_foreach, :g_queue_foreach, [GQueue, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_find(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_find, :g_queue_find, [GQueue, :pointer], GList
  
  # (Not documented)
  # 
  # @method g_queue_find_custom(queue, data, func)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Proc(_callback_g_compare_func_)] func 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_find_custom, :g_queue_find_custom, [GQueue, :pointer, :g_compare_func], GList
  
  # (Not documented)
  # 
  # @method g_queue_sort(queue, compare_func, user_data)
  # @param [GQueue] queue 
  # @param [Proc(_callback_g_compare_data_func_)] compare_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_sort, :g_queue_sort, [GQueue, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_head(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_head, :g_queue_push_head, [GQueue, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_tail(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_tail, :g_queue_push_tail, [GQueue, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_nth(queue, data, n)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Integer] n 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_nth, :g_queue_push_nth, [GQueue, :pointer, :int], :void
  
  # (Not documented)
  # 
  # @method g_queue_pop_head(queue)
  # @param [GQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_pop_head, :g_queue_pop_head, [GQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_pop_tail(queue)
  # @param [GQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_pop_tail, :g_queue_pop_tail, [GQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_pop_nth(queue, n)
  # @param [GQueue] queue 
  # @param [Integer] n 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_pop_nth, :g_queue_pop_nth, [GQueue, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_peek_head(queue)
  # @param [GQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_peek_head, :g_queue_peek_head, [GQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_peek_tail(queue)
  # @param [GQueue] queue 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_peek_tail, :g_queue_peek_tail, [GQueue], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_peek_nth(queue, n)
  # @param [GQueue] queue 
  # @param [Integer] n 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_queue_peek_nth, :g_queue_peek_nth, [GQueue, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_queue_index(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_index, :g_queue_index, [GQueue, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_queue_remove(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_remove, :g_queue_remove, [GQueue, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_queue_remove_all(queue, data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_remove_all, :g_queue_remove_all, [GQueue, :pointer], :uint
  
  # (Not documented)
  # 
  # @method g_queue_insert_before(queue, sibling, data)
  # @param [GQueue] queue 
  # @param [GList] sibling 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_insert_before, :g_queue_insert_before, [GQueue, GList, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_insert_after(queue, sibling, data)
  # @param [GQueue] queue 
  # @param [GList] sibling 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_insert_after, :g_queue_insert_after, [GQueue, GList, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_insert_sorted(queue, data, func, user_data)
  # @param [GQueue] queue 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_insert_sorted, :g_queue_insert_sorted, [GQueue, :pointer, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_head_link(queue, link)
  # @param [GQueue] queue 
  # @param [GList] link 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_head_link, :g_queue_push_head_link, [GQueue, GList], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_tail_link(queue, link)
  # @param [GQueue] queue 
  # @param [GList] link 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_tail_link, :g_queue_push_tail_link, [GQueue, GList], :void
  
  # (Not documented)
  # 
  # @method g_queue_push_nth_link(queue, n, link)
  # @param [GQueue] queue 
  # @param [Integer] n 
  # @param [GList] link 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_push_nth_link, :g_queue_push_nth_link, [GQueue, :int, GList], :void
  
  # (Not documented)
  # 
  # @method g_queue_pop_head_link(queue)
  # @param [GQueue] queue 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_pop_head_link, :g_queue_pop_head_link, [GQueue], GList
  
  # (Not documented)
  # 
  # @method g_queue_pop_tail_link(queue)
  # @param [GQueue] queue 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_pop_tail_link, :g_queue_pop_tail_link, [GQueue], GList
  
  # (Not documented)
  # 
  # @method g_queue_pop_nth_link(queue, n)
  # @param [GQueue] queue 
  # @param [Integer] n 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_pop_nth_link, :g_queue_pop_nth_link, [GQueue, :uint], GList
  
  # (Not documented)
  # 
  # @method g_queue_peek_head_link(queue)
  # @param [GQueue] queue 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_peek_head_link, :g_queue_peek_head_link, [GQueue], GList
  
  # (Not documented)
  # 
  # @method g_queue_peek_tail_link(queue)
  # @param [GQueue] queue 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_peek_tail_link, :g_queue_peek_tail_link, [GQueue], GList
  
  # (Not documented)
  # 
  # @method g_queue_peek_nth_link(queue, n)
  # @param [GQueue] queue 
  # @param [Integer] n 
  # @return [GList] 
  # @scope class
  attach_function :g_queue_peek_nth_link, :g_queue_peek_nth_link, [GQueue, :uint], GList
  
  # (Not documented)
  # 
  # @method g_queue_link_index(queue, link)
  # @param [GQueue] queue 
  # @param [GList] link 
  # @return [Integer] 
  # @scope class
  attach_function :g_queue_link_index, :g_queue_link_index, [GQueue, GList], :int
  
  # (Not documented)
  # 
  # @method g_queue_unlink(queue, link)
  # @param [GQueue] queue 
  # @param [GList] link 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_unlink, :g_queue_unlink, [GQueue, GList], :void
  
  # (Not documented)
  # 
  # @method g_queue_delete_link(queue, link)
  # @param [GQueue] queue 
  # @param [GList] link 
  # @return [nil] 
  # @scope class
  attach_function :g_queue_delete_link, :g_queue_delete_link, [GQueue, GList], :void
  
  # (Not documented)
  module GRandWrappers
    # @return [nil] 
    def free()
      Glib.g_rand_free(self)
    end
    
    # @return [GRand] 
    def copy()
      GRand.new Glib.g_rand_copy(self)
    end
    
    # @param [Integer] seed 
    # @return [nil] 
    def set_seed(seed)
      Glib.g_rand_set_seed(self, seed)
    end
    
    # @param [FFI::Pointer(*Guint32)] seed 
    # @param [Integer] seed_length 
    # @return [nil] 
    def set_seed_array(seed, seed_length)
      Glib.g_rand_set_seed_array(self, seed, seed_length)
    end
    
    # @return [Integer] 
    def int()
      Glib.g_rand_int(self)
    end
    
    # @param [Integer] begin_ 
    # @param [Integer] end_ 
    # @return [Integer] 
    def int_range(begin_, end_)
      Glib.g_rand_int_range(self, begin_, end_)
    end
    
    # @return [Float] 
    def double()
      Glib.g_rand_double(self)
    end
    
    # @param [Float] begin_ 
    # @param [Float] end_ 
    # @return [Float] 
    def double_range(begin_, end_)
      Glib.g_rand_double_range(self, begin_, end_)
    end
  end
  
  class GRand < FFI::Struct
    include GRandWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_rand_new_with_seed(seed)
  # @param [Integer] seed 
  # @return [GRand] 
  # @scope class
  attach_function :g_rand_new_with_seed, :g_rand_new_with_seed, [:uint], GRand
  
  # (Not documented)
  # 
  # @method g_rand_new_with_seed_array(seed, seed_length)
  # @param [FFI::Pointer(*Guint32)] seed 
  # @param [Integer] seed_length 
  # @return [GRand] 
  # @scope class
  attach_function :g_rand_new_with_seed_array, :g_rand_new_with_seed_array, [:pointer, :uint], GRand
  
  # (Not documented)
  # 
  # @method g_rand_new()
  # @return [GRand] 
  # @scope class
  attach_function :g_rand_new, :g_rand_new, [], GRand
  
  # (Not documented)
  # 
  # @method g_rand_free(rand)
  # @param [GRand] rand 
  # @return [nil] 
  # @scope class
  attach_function :g_rand_free, :g_rand_free, [GRand], :void
  
  # (Not documented)
  # 
  # @method g_rand_copy(rand)
  # @param [GRand] rand 
  # @return [GRand] 
  # @scope class
  attach_function :g_rand_copy, :g_rand_copy, [GRand], GRand
  
  # (Not documented)
  # 
  # @method g_rand_set_seed(rand, seed)
  # @param [GRand] rand 
  # @param [Integer] seed 
  # @return [nil] 
  # @scope class
  attach_function :g_rand_set_seed, :g_rand_set_seed, [GRand, :uint], :void
  
  # (Not documented)
  # 
  # @method g_rand_set_seed_array(rand, seed, seed_length)
  # @param [GRand] rand 
  # @param [FFI::Pointer(*Guint32)] seed 
  # @param [Integer] seed_length 
  # @return [nil] 
  # @scope class
  attach_function :g_rand_set_seed_array, :g_rand_set_seed_array, [GRand, :pointer, :uint], :void
  
  # (Not documented)
  # 
  # @method g_rand_int(rand)
  # @param [GRand] rand 
  # @return [Integer] 
  # @scope class
  attach_function :g_rand_int, :g_rand_int, [GRand], :uint
  
  # (Not documented)
  # 
  # @method g_rand_int_range(rand, begin_, end_)
  # @param [GRand] rand 
  # @param [Integer] begin_ 
  # @param [Integer] end_ 
  # @return [Integer] 
  # @scope class
  attach_function :g_rand_int_range, :g_rand_int_range, [GRand, :int, :int], :int
  
  # (Not documented)
  # 
  # @method g_rand_double(rand)
  # @param [GRand] rand 
  # @return [Float] 
  # @scope class
  attach_function :g_rand_double, :g_rand_double, [GRand], :double
  
  # (Not documented)
  # 
  # @method g_rand_double_range(rand, begin_, end_)
  # @param [GRand] rand 
  # @param [Float] begin_ 
  # @param [Float] end_ 
  # @return [Float] 
  # @scope class
  attach_function :g_rand_double_range, :g_rand_double_range, [GRand, :double, :double], :double
  
  # (Not documented)
  # 
  # @method g_random_set_seed(seed)
  # @param [Integer] seed 
  # @return [nil] 
  # @scope class
  attach_function :g_random_set_seed, :g_random_set_seed, [:uint], :void
  
  # (Not documented)
  # 
  # @method g_random_int()
  # @return [Integer] 
  # @scope class
  attach_function :g_random_int, :g_random_int, [], :uint
  
  # (Not documented)
  # 
  # @method g_random_int_range(begin_, end_)
  # @param [Integer] begin_ 
  # @param [Integer] end_ 
  # @return [Integer] 
  # @scope class
  attach_function :g_random_int_range, :g_random_int_range, [:int, :int], :int
  
  # (Not documented)
  # 
  # @method g_random_double()
  # @return [Float] 
  # @scope class
  attach_function :g_random_double, :g_random_double, [], :double
  
  # (Not documented)
  # 
  # @method g_random_double_range(begin_, end_)
  # @param [Float] begin_ 
  # @param [Float] end_ 
  # @return [Float] 
  # @scope class
  attach_function :g_random_double_range, :g_random_double_range, [:double, :double], :double
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_regex_error).</em>
  # 
  # === Options:
  # :compile ::
  #   
  # :optimize ::
  #   
  # :replace ::
  #   
  # :match ::
  #   
  # :internal ::
  #   
  # :stray_backslash ::
  #   These are the error codes from PCRE + 100
  # :missing_control_char ::
  #   
  # :unrecognized_escape ::
  #   
  # :quantifiers_out_of_order ::
  #   
  # :quantifier_too_big ::
  #   
  # :unterminated_character_class ::
  #   
  # :invalid_escape_in_character_class ::
  #   
  # :range_out_of_order ::
  #   
  # :nothing_to_repeat ::
  #   
  # :unrecognized_character ::
  #   
  # :posix_named_class_outside_class ::
  #   
  # :unmatched_parenthesis ::
  #   
  # :inexistent_subpattern_reference ::
  #   
  # :unterminated_comment ::
  #   
  # :expression_too_large ::
  #   
  # :memory_error ::
  #   
  # :variable_length_lookbehind ::
  #   
  # :malformed_condition ::
  #   
  # :too_many_conditional_branches ::
  #   
  # :assertion_expected ::
  #   
  # :unknown_posix_class_name ::
  #   
  # :posix_collating_elements_not_supported ::
  #   
  # :hex_code_too_large ::
  #   
  # :invalid_condition ::
  #   
  # :single_byte_match_in_lookbehind ::
  #   
  # :infinite_loop ::
  #   
  # :missing_subpattern_name_terminator ::
  #   
  # :duplicate_subpattern_name ::
  #   
  # :malformed_property ::
  #   
  # :unknown_property ::
  #   
  # :subpattern_name_too_long ::
  #   
  # :too_many_subpatterns ::
  #   
  # :invalid_octal_value ::
  #   
  # :too_many_branches_in_define ::
  #   
  # :define_repetion ::
  #   
  # :inconsistent_newline_options ::
  #   
  # :missing_back_reference ::
  #   
  # :invalid_relative_reference ::
  #   
  # :backtracking_control_verb_argument_forbidden ::
  #   
  # :unknown_backtracking_control_verb ::
  #   
  # :number_too_big ::
  #   
  # :missing_subpattern_name ::
  #   
  # :missing_digit ::
  #   
  # :invalid_data_character ::
  #   
  # :extra_subpattern_name ::
  #   
  # :backtracking_control_verb_argument_required ::
  #   
  # :invalid_control_char ::
  #   
  # :missing_name ::
  #   
  # :not_supported_in_class ::
  #   
  # :too_many_forward_references ::
  #   
  # :name_too_long ::
  #   
  # :character_value_too_large ::
  #   
  # 
  # @method _enum_g_regex_error_
  # @return [Symbol]
  # @scope class
  enum :g_regex_error, [
    :compile, 0,
    :optimize, 1,
    :replace, 2,
    :match, 3,
    :internal, 4,
    :stray_backslash, 101,
    :missing_control_char, 102,
    :unrecognized_escape, 103,
    :quantifiers_out_of_order, 104,
    :quantifier_too_big, 105,
    :unterminated_character_class, 106,
    :invalid_escape_in_character_class, 107,
    :range_out_of_order, 108,
    :nothing_to_repeat, 109,
    :unrecognized_character, 112,
    :posix_named_class_outside_class, 113,
    :unmatched_parenthesis, 114,
    :inexistent_subpattern_reference, 115,
    :unterminated_comment, 118,
    :expression_too_large, 120,
    :memory_error, 121,
    :variable_length_lookbehind, 125,
    :malformed_condition, 126,
    :too_many_conditional_branches, 127,
    :assertion_expected, 128,
    :unknown_posix_class_name, 130,
    :posix_collating_elements_not_supported, 131,
    :hex_code_too_large, 134,
    :invalid_condition, 135,
    :single_byte_match_in_lookbehind, 136,
    :infinite_loop, 140,
    :missing_subpattern_name_terminator, 142,
    :duplicate_subpattern_name, 143,
    :malformed_property, 146,
    :unknown_property, 147,
    :subpattern_name_too_long, 148,
    :too_many_subpatterns, 149,
    :invalid_octal_value, 151,
    :too_many_branches_in_define, 154,
    :define_repetion, 155,
    :inconsistent_newline_options, 156,
    :missing_back_reference, 157,
    :invalid_relative_reference, 158,
    :backtracking_control_verb_argument_forbidden, 159,
    :unknown_backtracking_control_verb, 160,
    :number_too_big, 161,
    :missing_subpattern_name, 162,
    :missing_digit, 163,
    :invalid_data_character, 164,
    :extra_subpattern_name, 165,
    :backtracking_control_verb_argument_required, 166,
    :invalid_control_char, 168,
    :missing_name, 169,
    :not_supported_in_class, 171,
    :too_many_forward_references, 172,
    :name_too_long, 175,
    :character_value_too_large, 176
  ]
  
  # (Not documented)
  # 
  # @method g_regex_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_error_quark, :g_regex_error_quark, [], :uint
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_regex_compile_flags).</em>
  # 
  # === Options:
  # :caseless ::
  #   
  # :multiline ::
  #   
  # :dotall ::
  #   
  # :extended ::
  #   
  # :anchored ::
  #   
  # :dollar_endonly ::
  #   
  # :ungreedy ::
  #   
  # :raw ::
  #   
  # :no_auto_capture ::
  #   
  # :optimize ::
  #   
  # :firstline ::
  #   
  # :dupnames ::
  #   
  # :newline_cr ::
  #   
  # :newline_lf ::
  #   
  # :bsr_anycrlf ::
  #   
  # :javascript_compat ::
  #   
  # 
  # @method _enum_g_regex_compile_flags_
  # @return [Symbol]
  # @scope class
  enum :g_regex_compile_flags, [
    :caseless, 1,
    :multiline, 2,
    :dotall, 4,
    :extended, 8,
    :anchored, 16,
    :dollar_endonly, 32,
    :ungreedy, 512,
    :raw, 2048,
    :no_auto_capture, 4096,
    :optimize, 8192,
    :firstline, 262144,
    :dupnames, 524288,
    :newline_cr, 1048576,
    :newline_lf, 2097152,
    :bsr_anycrlf, 8388608,
    :javascript_compat, 33554432
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_regex_match_flags).</em>
  # 
  # === Options:
  # :anchored ::
  #   
  # :notbol ::
  #   
  # :noteol ::
  #   
  # :notempty ::
  #   
  # :partial ::
  #   
  # :newline_cr ::
  #   
  # :newline_lf ::
  #   
  # :newline_any ::
  #   
  # :bsr_anycrlf ::
  #   
  # :bsr_any ::
  #   
  # :partial_hard ::
  #   
  # :notempty_atstart ::
  #   
  # 
  # @method _enum_g_regex_match_flags_
  # @return [Symbol]
  # @scope class
  enum :g_regex_match_flags, [
    :anchored, 16,
    :notbol, 128,
    :noteol, 256,
    :notempty, 1024,
    :partial, 32768,
    :newline_cr, 1048576,
    :newline_lf, 2097152,
    :newline_any, 4194304,
    :bsr_anycrlf, 8388608,
    :bsr_any, 16777216,
    :partial_hard, 134217728,
    :notempty_atstart, 268435456
  ]
  
  # (Not documented)
  module GRegexWrappers
    # @return [GRegex] 
    def ref()
      GRegex.new Glib.g_regex_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_regex_unref(self)
    end
    
    # @return [String] 
    def get_pattern()
      Glib.g_regex_get_pattern(self)
    end
    
    # @return [Integer] 
    def get_max_backref()
      Glib.g_regex_get_max_backref(self)
    end
    
    # @return [Integer] 
    def get_capture_count()
      Glib.g_regex_get_capture_count(self)
    end
    
    # @return [Integer] 
    def get_has_cr_or_lf()
      Glib.g_regex_get_has_cr_or_lf(self)
    end
    
    # @param [String] name 
    # @return [Integer] 
    def get_string_number(name)
      Glib.g_regex_get_string_number(self, name)
    end
    
    # @return [Symbol from _enum_g_regex_compile_flags_] 
    def get_compile_flags()
      Glib.g_regex_get_compile_flags(self)
    end
    
    # @return [Symbol from _enum_g_regex_match_flags_] 
    def get_match_flags()
      Glib.g_regex_get_match_flags(self)
    end
    
    # @param [String] string 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GMatchInfo)] match_info 
    # @return [Integer] 
    def match(string, match_options, match_info)
      Glib.g_regex_match(self, string, match_options, match_info)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GMatchInfo)] match_info 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def match_full(string, string_len, start_position, match_options, match_info, error)
      Glib.g_regex_match_full(self, string, string_len, start_position, match_options, match_info, error)
    end
    
    # @param [String] string 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GMatchInfo)] match_info 
    # @return [Integer] 
    def match_all(string, match_options, match_info)
      Glib.g_regex_match_all(self, string, match_options, match_info)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GMatchInfo)] match_info 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def match_all_full(string, string_len, start_position, match_options, match_info, error)
      Glib.g_regex_match_all_full(self, string, string_len, start_position, match_options, match_info, error)
    end
    
    # @param [String] string 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @return [FFI::Pointer(**Gchar)] 
    def split(string, match_options)
      Glib.g_regex_split(self, string, match_options)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [Integer] max_tokens 
    # @param [FFI::Pointer(**GError)] error 
    # @return [FFI::Pointer(**Gchar)] 
    def split_full(string, string_len, start_position, match_options, max_tokens, error)
      Glib.g_regex_split_full(self, string, string_len, start_position, match_options, max_tokens, error)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [String] replacement 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def replace(string, string_len, start_position, replacement, match_options, error)
      Glib.g_regex_replace(self, string, string_len, start_position, replacement, match_options, error)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [String] replacement 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def replace_literal(string, string_len, start_position, replacement, match_options, error)
      Glib.g_regex_replace_literal(self, string, string_len, start_position, replacement, match_options, error)
    end
    
    # @param [String] string 
    # @param [Integer] string_len 
    # @param [Integer] start_position 
    # @param [Symbol from _enum_g_regex_match_flags_] match_options 
    # @param [Proc(_callback_g_regex_eval_callback_)] eval 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def replace_eval(string, string_len, start_position, match_options, eval, user_data, error)
      Glib.g_regex_replace_eval(self, string, string_len, start_position, match_options, eval, user_data, error)
    end
  end
  
  class GRegex < FFI::Struct
    include GRegexWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  module GMatchInfoWrappers
    # @return [GRegex] 
    def get_regex()
      GRegex.new Glib.g_match_info_get_regex(self)
    end
    
    # @return [String] 
    def get_string()
      Glib.g_match_info_get_string(self)
    end
    
    # @return [GMatchInfo] 
    def ref()
      GMatchInfo.new Glib.g_match_info_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_match_info_unref(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_match_info_free(self)
    end
    
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def next_(error)
      Glib.g_match_info_next(self, error)
    end
    
    # @return [Integer] 
    def matches()
      Glib.g_match_info_matches(self)
    end
    
    # @return [Integer] 
    def get_match_count()
      Glib.g_match_info_get_match_count(self)
    end
    
    # @return [Integer] 
    def is_partial_match()
      Glib.g_match_info_is_partial_match(self)
    end
    
    # @param [String] string_to_expand 
    # @param [FFI::Pointer(**GError)] error 
    # @return [String] 
    def expand_references(string_to_expand, error)
      Glib.g_match_info_expand_references(self, string_to_expand, error)
    end
    
    # @param [Integer] match_num 
    # @return [String] 
    def fetch(match_num)
      Glib.g_match_info_fetch(self, match_num)
    end
    
    # @param [Integer] match_num 
    # @param [FFI::Pointer(*Gint)] start_pos 
    # @param [FFI::Pointer(*Gint)] end_pos 
    # @return [Integer] 
    def fetch_pos(match_num, start_pos, end_pos)
      Glib.g_match_info_fetch_pos(self, match_num, start_pos, end_pos)
    end
    
    # @param [String] name 
    # @return [String] 
    def fetch_named(name)
      Glib.g_match_info_fetch_named(self, name)
    end
    
    # @param [String] name 
    # @param [FFI::Pointer(*Gint)] start_pos 
    # @param [FFI::Pointer(*Gint)] end_pos 
    # @return [Integer] 
    def fetch_named_pos(name, start_pos, end_pos)
      Glib.g_match_info_fetch_named_pos(self, name, start_pos, end_pos)
    end
    
    # @return [FFI::Pointer(**Gchar)] 
    def fetch_all()
      Glib.g_match_info_fetch_all(self)
    end
  end
  
  class GMatchInfo < FFI::Struct
    include GMatchInfoWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_regex_eval_callback_(match_info, result, user_data)
  # @param [GMatchInfo] match_info 
  # @param [GString] result 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :g_regex_eval_callback, [GMatchInfo, GString, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_regex_new(pattern, compile_options, match_options, error)
  # @param [String] pattern 
  # @param [Symbol from _enum_g_regex_compile_flags_] compile_options 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GRegex] 
  # @scope class
  attach_function :g_regex_new, :g_regex_new, [:string, :g_regex_compile_flags, :g_regex_match_flags, :pointer], GRegex
  
  # (Not documented)
  # 
  # @method g_regex_ref(regex)
  # @param [GRegex] regex 
  # @return [GRegex] 
  # @scope class
  attach_function :g_regex_ref, :g_regex_ref, [GRegex], GRegex
  
  # (Not documented)
  # 
  # @method g_regex_unref(regex)
  # @param [GRegex] regex 
  # @return [nil] 
  # @scope class
  attach_function :g_regex_unref, :g_regex_unref, [GRegex], :void
  
  # (Not documented)
  # 
  # @method g_regex_get_pattern(regex)
  # @param [GRegex] regex 
  # @return [String] 
  # @scope class
  attach_function :g_regex_get_pattern, :g_regex_get_pattern, [GRegex], :string
  
  # (Not documented)
  # 
  # @method g_regex_get_max_backref(regex)
  # @param [GRegex] regex 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_get_max_backref, :g_regex_get_max_backref, [GRegex], :int
  
  # (Not documented)
  # 
  # @method g_regex_get_capture_count(regex)
  # @param [GRegex] regex 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_get_capture_count, :g_regex_get_capture_count, [GRegex], :int
  
  # (Not documented)
  # 
  # @method g_regex_get_has_cr_or_lf(regex)
  # @param [GRegex] regex 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_get_has_cr_or_lf, :g_regex_get_has_cr_or_lf, [GRegex], :int
  
  # (Not documented)
  # 
  # @method g_regex_get_string_number(regex, name)
  # @param [GRegex] regex 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_get_string_number, :g_regex_get_string_number, [GRegex, :string], :int
  
  # (Not documented)
  # 
  # @method g_regex_escape_string(string, length)
  # @param [String] string 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_regex_escape_string, :g_regex_escape_string, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_regex_escape_nul(string, length)
  # @param [String] string 
  # @param [Integer] length 
  # @return [String] 
  # @scope class
  attach_function :g_regex_escape_nul, :g_regex_escape_nul, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_regex_get_compile_flags(regex)
  # @param [GRegex] regex 
  # @return [Symbol from _enum_g_regex_compile_flags_] 
  # @scope class
  attach_function :g_regex_get_compile_flags, :g_regex_get_compile_flags, [GRegex], :g_regex_compile_flags
  
  # (Not documented)
  # 
  # @method g_regex_get_match_flags(regex)
  # @param [GRegex] regex 
  # @return [Symbol from _enum_g_regex_match_flags_] 
  # @scope class
  attach_function :g_regex_get_match_flags, :g_regex_get_match_flags, [GRegex], :g_regex_match_flags
  
  # (Not documented)
  # 
  # @method g_regex_match_simple(pattern, string, compile_options, match_options)
  # @param [String] pattern 
  # @param [String] string 
  # @param [Symbol from _enum_g_regex_compile_flags_] compile_options 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_match_simple, :g_regex_match_simple, [:string, :string, :g_regex_compile_flags, :g_regex_match_flags], :int
  
  # (Not documented)
  # 
  # @method g_regex_match(regex, string, match_options, match_info)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GMatchInfo)] match_info 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_match, :g_regex_match, [GRegex, :string, :g_regex_match_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_regex_match_full(regex, string, string_len, start_position, match_options, match_info, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GMatchInfo)] match_info 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_match_full, :g_regex_match_full, [GRegex, :string, :int, :int, :g_regex_match_flags, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_regex_match_all(regex, string, match_options, match_info)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GMatchInfo)] match_info 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_match_all, :g_regex_match_all, [GRegex, :string, :g_regex_match_flags, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_regex_match_all_full(regex, string, string_len, start_position, match_options, match_info, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GMatchInfo)] match_info 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_match_all_full, :g_regex_match_all_full, [GRegex, :string, :int, :int, :g_regex_match_flags, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_regex_split_simple(pattern, string, compile_options, match_options)
  # @param [String] pattern 
  # @param [String] string 
  # @param [Symbol from _enum_g_regex_compile_flags_] compile_options 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_regex_split_simple, :g_regex_split_simple, [:string, :string, :g_regex_compile_flags, :g_regex_match_flags], :pointer
  
  # (Not documented)
  # 
  # @method g_regex_split(regex, string, match_options)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_regex_split, :g_regex_split, [GRegex, :string, :g_regex_match_flags], :pointer
  
  # (Not documented)
  # 
  # @method g_regex_split_full(regex, string, string_len, start_position, match_options, max_tokens, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [Integer] max_tokens 
  # @param [FFI::Pointer(**GError)] error 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_regex_split_full, :g_regex_split_full, [GRegex, :string, :int, :int, :g_regex_match_flags, :int, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_regex_replace(regex, string, string_len, start_position, replacement, match_options, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [String] replacement 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_regex_replace, :g_regex_replace, [GRegex, :string, :int, :int, :string, :g_regex_match_flags, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_regex_replace_literal(regex, string, string_len, start_position, replacement, match_options, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [String] replacement 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_regex_replace_literal, :g_regex_replace_literal, [GRegex, :string, :int, :int, :string, :g_regex_match_flags, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_regex_replace_eval(regex, string, string_len, start_position, match_options, eval, user_data, error)
  # @param [GRegex] regex 
  # @param [String] string 
  # @param [Integer] string_len 
  # @param [Integer] start_position 
  # @param [Symbol from _enum_g_regex_match_flags_] match_options 
  # @param [Proc(_callback_g_regex_eval_callback_)] eval 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_regex_replace_eval, :g_regex_replace_eval, [GRegex, :string, :int, :int, :g_regex_match_flags, :g_regex_eval_callback, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_regex_check_replacement(replacement, has_references, error)
  # @param [String] replacement 
  # @param [FFI::Pointer(*Gboolean)] has_references 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_regex_check_replacement, :g_regex_check_replacement, [:string, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_match_info_get_regex(match_info)
  # @param [GMatchInfo] match_info 
  # @return [GRegex] 
  # @scope class
  attach_function :g_match_info_get_regex, :g_match_info_get_regex, [GMatchInfo], GRegex
  
  # (Not documented)
  # 
  # @method g_match_info_get_string(match_info)
  # @param [GMatchInfo] match_info 
  # @return [String] 
  # @scope class
  attach_function :g_match_info_get_string, :g_match_info_get_string, [GMatchInfo], :string
  
  # (Not documented)
  # 
  # @method g_match_info_ref(match_info)
  # @param [GMatchInfo] match_info 
  # @return [GMatchInfo] 
  # @scope class
  attach_function :g_match_info_ref, :g_match_info_ref, [GMatchInfo], GMatchInfo
  
  # (Not documented)
  # 
  # @method g_match_info_unref(match_info)
  # @param [GMatchInfo] match_info 
  # @return [nil] 
  # @scope class
  attach_function :g_match_info_unref, :g_match_info_unref, [GMatchInfo], :void
  
  # (Not documented)
  # 
  # @method g_match_info_free(match_info)
  # @param [GMatchInfo] match_info 
  # @return [nil] 
  # @scope class
  attach_function :g_match_info_free, :g_match_info_free, [GMatchInfo], :void
  
  # (Not documented)
  # 
  # @method g_match_info_next(match_info, error)
  # @param [GMatchInfo] match_info 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_next, :g_match_info_next, [GMatchInfo, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_match_info_matches(match_info)
  # @param [GMatchInfo] match_info 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_matches, :g_match_info_matches, [GMatchInfo], :int
  
  # (Not documented)
  # 
  # @method g_match_info_get_match_count(match_info)
  # @param [GMatchInfo] match_info 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_get_match_count, :g_match_info_get_match_count, [GMatchInfo], :int
  
  # (Not documented)
  # 
  # @method g_match_info_is_partial_match(match_info)
  # @param [GMatchInfo] match_info 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_is_partial_match, :g_match_info_is_partial_match, [GMatchInfo], :int
  
  # (Not documented)
  # 
  # @method g_match_info_expand_references(match_info, string_to_expand, error)
  # @param [GMatchInfo] match_info 
  # @param [String] string_to_expand 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_match_info_expand_references, :g_match_info_expand_references, [GMatchInfo, :string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_match_info_fetch(match_info, match_num)
  # @param [GMatchInfo] match_info 
  # @param [Integer] match_num 
  # @return [String] 
  # @scope class
  attach_function :g_match_info_fetch, :g_match_info_fetch, [GMatchInfo, :int], :string
  
  # (Not documented)
  # 
  # @method g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos)
  # @param [GMatchInfo] match_info 
  # @param [Integer] match_num 
  # @param [FFI::Pointer(*Gint)] start_pos 
  # @param [FFI::Pointer(*Gint)] end_pos 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_fetch_pos, :g_match_info_fetch_pos, [GMatchInfo, :int, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_match_info_fetch_named(match_info, name)
  # @param [GMatchInfo] match_info 
  # @param [String] name 
  # @return [String] 
  # @scope class
  attach_function :g_match_info_fetch_named, :g_match_info_fetch_named, [GMatchInfo, :string], :string
  
  # (Not documented)
  # 
  # @method g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos)
  # @param [GMatchInfo] match_info 
  # @param [String] name 
  # @param [FFI::Pointer(*Gint)] start_pos 
  # @param [FFI::Pointer(*Gint)] end_pos 
  # @return [Integer] 
  # @scope class
  attach_function :g_match_info_fetch_named_pos, :g_match_info_fetch_named_pos, [GMatchInfo, :string, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_match_info_fetch_all(match_info)
  # @param [GMatchInfo] match_info 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_match_info_fetch_all, :g_match_info_fetch_all, [GMatchInfo], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_scanner_msg_func_(message, error)
  # @param [String] message 
  # @param [Integer] error 
  # @return [FFI::Pointer(*GScanner)] 
  # @scope class
  callback :g_scanner_msg_func, [:string, :int], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_error_type).</em>
  # 
  # === Options:
  # :err_unknown ::
  #   
  # :err_unexp_eof ::
  #   
  # :err_unexp_eof_in_string ::
  #   
  # :err_unexp_eof_in_comment ::
  #   
  # :err_non_digit_in_const ::
  #   
  # :err_digit_radix ::
  #   
  # :err_float_radix ::
  #   
  # :err_float_malformed ::
  #   
  # 
  # @method _enum_g_error_type_
  # @return [Symbol]
  # @scope class
  enum :g_error_type, [
    :err_unknown, 0,
    :err_unexp_eof, 1,
    :err_unexp_eof_in_string, 2,
    :err_unexp_eof_in_comment, 3,
    :err_non_digit_in_const, 4,
    :err_digit_radix, 5,
    :err_float_radix, 6,
    :err_float_malformed, 7
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_token_type).</em>
  # 
  # === Options:
  # :eof ::
  #   
  # :left_paren ::
  #   
  # :right_paren ::
  #   
  # :left_curly ::
  #   
  # :right_curly ::
  #   
  # :left_brace ::
  #   
  # :right_brace ::
  #   
  # :equal_sign ::
  #   
  # :comma ::
  #   
  # :none ::
  #   
  # :error ::
  #   
  # :char ::
  #   
  # :binary ::
  #   
  # :octal ::
  #   
  # :int ::
  #   
  # :hex ::
  #   
  # :float ::
  #   
  # :string ::
  #   
  # :symbol ::
  #   
  # :identifier ::
  #   
  # :identifier_null ::
  #   
  # :comment_single ::
  #   
  # :comment_multi ::
  #   
  # :last ::
  #   < private >
  # 
  # @method _enum_g_token_type_
  # @return [Symbol]
  # @scope class
  enum :g_token_type, [
    :eof, 0,
    :left_paren, 40,
    :right_paren, 41,
    :left_curly, 123,
    :right_curly, 125,
    :left_brace, 91,
    :right_brace, 93,
    :equal_sign, 61,
    :comma, 44,
    :none, 256,
    :error, 257,
    :char, 258,
    :binary, 259,
    :octal, 260,
    :int, 261,
    :hex, 262,
    :float, 263,
    :string, 264,
    :symbol, 265,
    :identifier, 266,
    :identifier_null, 267,
    :comment_single, 268,
    :comment_multi, 269,
    :last, 270
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :v_symbol ::
  #   (FFI::Pointer(Gpointer)) 
  # :v_identifier ::
  #   (String) 
  # :v_binary ::
  #   (Integer) 
  # :v_octal ::
  #   (Integer) 
  # :v_int ::
  #   (Integer) 
  # :v_int64 ::
  #   (Integer) 
  # :v_float ::
  #   (Float) 
  # :v_hex ::
  #   (Integer) 
  # :v_string ::
  #   (String) 
  # :v_comment ::
  #   (String) 
  # :v_char ::
  #   (Integer) 
  # :v_error ::
  #   (Integer) 
  class GTokenValue < FFI::Union
    layout :v_symbol, :pointer,
           :v_identifier, :string,
           :v_binary, :ulong,
           :v_octal, :ulong,
           :v_int, :ulong,
           :v_int64, :ulong_long,
           :v_float, :double,
           :v_hex, :ulong,
           :v_string, :string,
           :v_comment, :string,
           :v_char, :uchar,
           :v_error, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :cset_skip_characters ::
  #   (String) default: " \t\n"
  # :cset_identifier_first ::
  #   (String) 
  # :cset_identifier_nth ::
  #   (String) 
  # :cpair_comment_single ::
  #   (String) default: "#\n"
  # :case_sensitive ::
  #   (Integer) Should symbol lookup work case sensitive?
  # :skip_comment_multi ::
  #   (Integer) C like comment
  # :skip_comment_single ::
  #   (Integer) single line comment
  # :scan_comment_multi ::
  #   (Integer) scan multi line comments?
  # :scan_identifier ::
  #   (Integer) 
  # :scan_identifier_1char ::
  #   (Integer) 
  # :scan_identifier_null ::
  #   (Integer) 
  # :scan_symbols ::
  #   (Integer) 
  # :scan_binary ::
  #   (Integer) 
  # :scan_octal ::
  #   (Integer) 
  # :scan_float ::
  #   (Integer) 
  # :scan_hex ::
  #   (Integer) `0x0ff0'
  # :scan_hex_dollar ::
  #   (Integer) `$0ff0'
  # :scan_string_sq ::
  #   (Integer) string: 'anything'
  # :scan_string_dq ::
  #   (Integer) string: "\\-escapes!\n"
  # :numbers_2_int ::
  #   (Integer) bin, octal, hex => int
  # :int_2_float ::
  #   (Integer) int => G_TOKEN_FLOAT?
  # :identifier_2_string ::
  #   (Integer) 
  # :char_2_token ::
  #   (Integer) return G_TOKEN_CHAR?
  # :symbol_2_token ::
  #   (Integer) 
  # :scope_0_fallback ::
  #   (Integer) try scope 0 on lookups?
  # :store_int64 ::
  #   (Integer) use value.v_int64 rather than v_int
  # :padding_dummy ::
  #   (Integer) < private >
  class GScannerConfig < FFI::Struct
    layout :cset_skip_characters, :string,
           :cset_identifier_first, :string,
           :cset_identifier_nth, :string,
           :cpair_comment_single, :string,
           :case_sensitive, :uint,
           :skip_comment_multi, :uint,
           :skip_comment_single, :uint,
           :scan_comment_multi, :uint,
           :scan_identifier, :uint,
           :scan_identifier_1char, :uint,
           :scan_identifier_null, :uint,
           :scan_symbols, :uint,
           :scan_binary, :uint,
           :scan_octal, :uint,
           :scan_float, :uint,
           :scan_hex, :uint,
           :scan_hex_dollar, :uint,
           :scan_string_sq, :uint,
           :scan_string_dq, :uint,
           :numbers_2_int, :uint,
           :int_2_float, :uint,
           :identifier_2_string, :uint,
           :char_2_token, :uint,
           :symbol_2_token, :uint,
           :scope_0_fallback, :uint,
           :store_int64, :uint,
           :padding_dummy, :uint
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :user_data ::
  #   (FFI::Pointer(Gpointer)) unused fields
  # :max_parse_errors ::
  #   (Integer) 
  # :parse_errors ::
  #   (Integer) g_scanner_error() increments this field
  # :input_name ::
  #   (String) name of input stream, featured by the default message handler
  # :qdata ::
  #   (GData) quarked data
  # :config ::
  #   (GScannerConfig) link into the scanner configuration
  # :token ::
  #   (Symbol from _enum_g_token_type_) fields filled in after g_scanner_get_next_token()
  # :value ::
  #   (GTokenValue) 
  # :line ::
  #   (Integer) 
  # :position ::
  #   (Integer) 
  # :next_token ::
  #   (Symbol from _enum_g_token_type_) fields filled in after g_scanner_peek_next_token()
  # :next_value ::
  #   (GTokenValue) 
  # :next_line ::
  #   (Integer) 
  # :next_position ::
  #   (Integer) 
  # :symbol_table ::
  #   (GHashTable) to be considered private
  # :input_fd ::
  #   (Integer) 
  # :text ::
  #   (String) 
  # :text_end ::
  #   (String) 
  # :buffer ::
  #   (String) 
  # :scope_id ::
  #   (Integer) 
  # :msg_handler ::
  #   (Proc(_callback_g_scanner_msg_func_)) handler function for _warn and _error
  module GScannerWrappers
    # @return [nil] 
    def destroy()
      Glib.g_scanner_destroy(self)
    end
    
    # @param [Integer] input_fd 
    # @return [nil] 
    def input_file(input_fd)
      Glib.g_scanner_input_file(self, input_fd)
    end
    
    # @return [nil] 
    def sync_file_offset()
      Glib.g_scanner_sync_file_offset(self)
    end
    
    # @param [String] text 
    # @param [Integer] text_len 
    # @return [nil] 
    def input_text(text, text_len)
      Glib.g_scanner_input_text(self, text, text_len)
    end
    
    # @return [Symbol from _enum_g_token_type_] 
    def get_next_token()
      Glib.g_scanner_get_next_token(self)
    end
    
    # @return [Symbol from _enum_g_token_type_] 
    def peek_next_token()
      Glib.g_scanner_peek_next_token(self)
    end
    
    # @return [Symbol from _enum_g_token_type_] 
    def cur_token()
      Glib.g_scanner_cur_token(self)
    end
    
    # @return [GTokenValue] 
    def cur_value()
      Glib.g_scanner_cur_value(self)
    end
    
    # @return [Integer] 
    def cur_line()
      Glib.g_scanner_cur_line(self)
    end
    
    # @return [Integer] 
    def cur_position()
      Glib.g_scanner_cur_position(self)
    end
    
    # @return [Integer] 
    def eof()
      Glib.g_scanner_eof(self)
    end
    
    # @param [Integer] scope_id 
    # @return [Integer] 
    def set_scope(scope_id)
      Glib.g_scanner_set_scope(self, scope_id)
    end
    
    # @param [Integer] scope_id 
    # @param [String] symbol 
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def scope_add_symbol(scope_id, symbol, value)
      Glib.g_scanner_scope_add_symbol(self, scope_id, symbol, value)
    end
    
    # @param [Integer] scope_id 
    # @param [String] symbol 
    # @return [nil] 
    def scope_remove_symbol(scope_id, symbol)
      Glib.g_scanner_scope_remove_symbol(self, scope_id, symbol)
    end
    
    # @param [Integer] scope_id 
    # @param [String] symbol 
    # @return [FFI::Pointer(Gpointer)] 
    def scope_lookup_symbol(scope_id, symbol)
      Glib.g_scanner_scope_lookup_symbol(self, scope_id, symbol)
    end
    
    # @param [Integer] scope_id 
    # @param [Proc(_callback_gh_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def scope_foreach_symbol(scope_id, func, user_data)
      Glib.g_scanner_scope_foreach_symbol(self, scope_id, func, user_data)
    end
    
    # @param [String] symbol 
    # @return [FFI::Pointer(Gpointer)] 
    def lookup_symbol(symbol)
      Glib.g_scanner_lookup_symbol(self, symbol)
    end
    
    # @param [Symbol from _enum_g_token_type_] expected_token 
    # @param [String] identifier_spec 
    # @param [String] symbol_spec 
    # @param [String] symbol_name 
    # @param [String] message 
    # @param [Integer] is_error 
    # @return [nil] 
    def unexp_token(expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error)
      Glib.g_scanner_unexp_token(self, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error)
    end
    
    # @param [String] format 
    # @return [nil] 
    def error(format)
      Glib.g_scanner_error(self, format)
    end
    
    # @param [String] format 
    # @return [nil] 
    def warn(format)
      Glib.g_scanner_warn(self, format)
    end
  end
  
  class GScanner < FFI::Struct
    include GScannerWrappers
    layout :user_data, :pointer,
           :max_parse_errors, :uint,
           :parse_errors, :uint,
           :input_name, :string,
           :qdata, GData,
           :config, GScannerConfig,
           :token, :g_token_type,
           :value, GTokenValue.by_value,
           :line, :uint,
           :position, :uint,
           :next_token, :g_token_type,
           :next_value, GTokenValue.by_value,
           :next_line, :uint,
           :next_position, :uint,
           :symbol_table, GHashTable,
           :input_fd, :int,
           :text, :string,
           :text_end, :string,
           :buffer, :string,
           :scope_id, :uint,
           :msg_handler, :g_scanner_msg_func
  end
  
  # (Not documented)
  # 
  # @method g_scanner_new(config_templ)
  # @param [GScannerConfig] config_templ 
  # @return [GScanner] 
  # @scope class
  attach_function :g_scanner_new, :g_scanner_new, [GScannerConfig], GScanner
  
  # (Not documented)
  # 
  # @method g_scanner_destroy(scanner)
  # @param [GScanner] scanner 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_destroy, :g_scanner_destroy, [GScanner], :void
  
  # (Not documented)
  # 
  # @method g_scanner_input_file(scanner, input_fd)
  # @param [GScanner] scanner 
  # @param [Integer] input_fd 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_input_file, :g_scanner_input_file, [GScanner, :int], :void
  
  # (Not documented)
  # 
  # @method g_scanner_sync_file_offset(scanner)
  # @param [GScanner] scanner 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_sync_file_offset, :g_scanner_sync_file_offset, [GScanner], :void
  
  # (Not documented)
  # 
  # @method g_scanner_input_text(scanner, text, text_len)
  # @param [GScanner] scanner 
  # @param [String] text 
  # @param [Integer] text_len 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_input_text, :g_scanner_input_text, [GScanner, :string, :uint], :void
  
  # (Not documented)
  # 
  # @method g_scanner_get_next_token(scanner)
  # @param [GScanner] scanner 
  # @return [Symbol from _enum_g_token_type_] 
  # @scope class
  attach_function :g_scanner_get_next_token, :g_scanner_get_next_token, [GScanner], :g_token_type
  
  # (Not documented)
  # 
  # @method g_scanner_peek_next_token(scanner)
  # @param [GScanner] scanner 
  # @return [Symbol from _enum_g_token_type_] 
  # @scope class
  attach_function :g_scanner_peek_next_token, :g_scanner_peek_next_token, [GScanner], :g_token_type
  
  # (Not documented)
  # 
  # @method g_scanner_cur_token(scanner)
  # @param [GScanner] scanner 
  # @return [Symbol from _enum_g_token_type_] 
  # @scope class
  attach_function :g_scanner_cur_token, :g_scanner_cur_token, [GScanner], :g_token_type
  
  # (Not documented)
  # 
  # @method g_scanner_cur_value(scanner)
  # @param [GScanner] scanner 
  # @return [GTokenValue] 
  # @scope class
  attach_function :g_scanner_cur_value, :g_scanner_cur_value, [GScanner], GTokenValue.by_value
  
  # (Not documented)
  # 
  # @method g_scanner_cur_line(scanner)
  # @param [GScanner] scanner 
  # @return [Integer] 
  # @scope class
  attach_function :g_scanner_cur_line, :g_scanner_cur_line, [GScanner], :uint
  
  # (Not documented)
  # 
  # @method g_scanner_cur_position(scanner)
  # @param [GScanner] scanner 
  # @return [Integer] 
  # @scope class
  attach_function :g_scanner_cur_position, :g_scanner_cur_position, [GScanner], :uint
  
  # (Not documented)
  # 
  # @method g_scanner_eof(scanner)
  # @param [GScanner] scanner 
  # @return [Integer] 
  # @scope class
  attach_function :g_scanner_eof, :g_scanner_eof, [GScanner], :int
  
  # (Not documented)
  # 
  # @method g_scanner_set_scope(scanner, scope_id)
  # @param [GScanner] scanner 
  # @param [Integer] scope_id 
  # @return [Integer] 
  # @scope class
  attach_function :g_scanner_set_scope, :g_scanner_set_scope, [GScanner, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_scanner_scope_add_symbol(scanner, scope_id, symbol, value)
  # @param [GScanner] scanner 
  # @param [Integer] scope_id 
  # @param [String] symbol 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_scope_add_symbol, :g_scanner_scope_add_symbol, [GScanner, :uint, :string, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_scanner_scope_remove_symbol(scanner, scope_id, symbol)
  # @param [GScanner] scanner 
  # @param [Integer] scope_id 
  # @param [String] symbol 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_scope_remove_symbol, :g_scanner_scope_remove_symbol, [GScanner, :uint, :string], :void
  
  # (Not documented)
  # 
  # @method g_scanner_scope_lookup_symbol(scanner, scope_id, symbol)
  # @param [GScanner] scanner 
  # @param [Integer] scope_id 
  # @param [String] symbol 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_scanner_scope_lookup_symbol, :g_scanner_scope_lookup_symbol, [GScanner, :uint, :string], :pointer
  
  # (Not documented)
  # 
  # @method g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data)
  # @param [GScanner] scanner 
  # @param [Integer] scope_id 
  # @param [Proc(_callback_gh_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_scope_foreach_symbol, :g_scanner_scope_foreach_symbol, [GScanner, :uint, :gh_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_scanner_lookup_symbol(scanner, symbol)
  # @param [GScanner] scanner 
  # @param [String] symbol 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_scanner_lookup_symbol, :g_scanner_lookup_symbol, [GScanner, :string], :pointer
  
  # (Not documented)
  # 
  # @method g_scanner_unexp_token(scanner, expected_token, identifier_spec, symbol_spec, symbol_name, message, is_error)
  # @param [GScanner] scanner 
  # @param [Symbol from _enum_g_token_type_] expected_token 
  # @param [String] identifier_spec 
  # @param [String] symbol_spec 
  # @param [String] symbol_name 
  # @param [String] message 
  # @param [Integer] is_error 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_unexp_token, :g_scanner_unexp_token, [GScanner, :g_token_type, :string, :string, :string, :string, :int], :void
  
  # (Not documented)
  # 
  # @method g_scanner_error(scanner, format)
  # @param [GScanner] scanner 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_error, :g_scanner_error, [GScanner, :string], :void
  
  # (Not documented)
  # 
  # @method g_scanner_warn(scanner, format)
  # @param [GScanner] scanner 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_scanner_warn, :g_scanner_warn, [GScanner, :string], :void
  
  # (Not documented)
  module GSequenceWrappers
    # @return [nil] 
    def free()
      Glib.g_sequence_free(self)
    end
    
    # @return [Integer] 
    def get_length()
      Glib.g_sequence_get_length(self)
    end
    
    # @param [Proc(_callback_g_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_sequence_foreach(self, func, user_data)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [nil] 
    def sort(cmp_func, cmp_data)
      Glib.g_sequence_sort(self, cmp_func, cmp_data)
    end
    
    # @param [Proc(_callback_g_sequence_iter_compare_func_)] cmp_func 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [nil] 
    def sort_iter(cmp_func, cmp_data)
      Glib.g_sequence_sort_iter(self, cmp_func, cmp_data)
    end
    
    # @return [GSequenceNode] 
    def get_begin_iter()
      GSequenceNode.new Glib.g_sequence_get_begin_iter(self)
    end
    
    # @return [GSequenceNode] 
    def get_end_iter()
      GSequenceNode.new Glib.g_sequence_get_end_iter(self)
    end
    
    # @param [Integer] pos 
    # @return [GSequenceNode] 
    def get_iter_at_pos(pos)
      GSequenceNode.new Glib.g_sequence_get_iter_at_pos(self, pos)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GSequenceNode] 
    def append(data)
      GSequenceNode.new Glib.g_sequence_append(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [GSequenceNode] 
    def prepend(data)
      GSequenceNode.new Glib.g_sequence_prepend(self, data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def insert_sorted(data, cmp_func, cmp_data)
      GSequenceNode.new Glib.g_sequence_insert_sorted(self, data, cmp_func, cmp_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def insert_sorted_iter(data, iter_cmp, cmp_data)
      GSequenceNode.new Glib.g_sequence_insert_sorted_iter(self, data, iter_cmp, cmp_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def search(data, cmp_func, cmp_data)
      GSequenceNode.new Glib.g_sequence_search(self, data, cmp_func, cmp_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def search_iter(data, iter_cmp, cmp_data)
      GSequenceNode.new Glib.g_sequence_search_iter(self, data, iter_cmp, cmp_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def lookup(data, cmp_func, cmp_data)
      GSequenceNode.new Glib.g_sequence_lookup(self, data, cmp_func, cmp_data)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
    # @param [FFI::Pointer(Gpointer)] cmp_data 
    # @return [GSequenceNode] 
    def lookup_iter(data, iter_cmp, cmp_data)
      GSequenceNode.new Glib.g_sequence_lookup_iter(self, data, iter_cmp, cmp_data)
    end
  end
  
  class GSequence < FFI::Struct
    include GSequenceWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  class GSequenceNode < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_sequence_iter_compare_func_(a, b, data)
  # @param [GSequenceNode] a 
  # @param [GSequenceNode] b 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_sequence_iter_compare_func, [GSequenceNode, GSequenceNode, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_sequence_new(data_destroy)
  # @param [FFI::Pointer(GDestroyNotify)] data_destroy 
  # @return [GSequence] 
  # @scope class
  attach_function :g_sequence_new, :g_sequence_new, [:pointer], GSequence
  
  # (Not documented)
  # 
  # @method g_sequence_free(seq)
  # @param [GSequence] seq 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_free, :g_sequence_free, [GSequence], :void
  
  # (Not documented)
  # 
  # @method g_sequence_get_length(seq)
  # @param [GSequence] seq 
  # @return [Integer] 
  # @scope class
  attach_function :g_sequence_get_length, :g_sequence_get_length, [GSequence], :int
  
  # (Not documented)
  # 
  # @method g_sequence_foreach(seq, func, user_data)
  # @param [GSequence] seq 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_foreach, :g_sequence_foreach, [GSequence, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_foreach_range(begin_, end_, func, user_data)
  # @param [GSequenceNode] begin_ 
  # @param [GSequenceNode] end_ 
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_foreach_range, :g_sequence_foreach_range, [GSequenceNode, GSequenceNode, :g_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_sort(seq, cmp_func, cmp_data)
  # @param [GSequence] seq 
  # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_sort, :g_sequence_sort, [GSequence, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_sort_iter(seq, cmp_func, cmp_data)
  # @param [GSequence] seq 
  # @param [Proc(_callback_g_sequence_iter_compare_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_sort_iter, :g_sequence_sort_iter, [GSequence, :g_sequence_iter_compare_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_get_begin_iter(seq)
  # @param [GSequence] seq 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_get_begin_iter, :g_sequence_get_begin_iter, [GSequence], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_get_end_iter(seq)
  # @param [GSequence] seq 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_get_end_iter, :g_sequence_get_end_iter, [GSequence], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_get_iter_at_pos(seq, pos)
  # @param [GSequence] seq 
  # @param [Integer] pos 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_get_iter_at_pos, :g_sequence_get_iter_at_pos, [GSequence, :int], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_append(seq, data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_append, :g_sequence_append, [GSequence, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_prepend(seq, data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_prepend, :g_sequence_prepend, [GSequence, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_insert_before(iter, data)
  # @param [GSequenceNode] iter 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_insert_before, :g_sequence_insert_before, [GSequenceNode, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_move(src, dest)
  # @param [GSequenceNode] src 
  # @param [GSequenceNode] dest 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_move, :g_sequence_move, [GSequenceNode, GSequenceNode], :void
  
  # (Not documented)
  # 
  # @method g_sequence_swap(a, b)
  # @param [GSequenceNode] a 
  # @param [GSequenceNode] b 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_swap, :g_sequence_swap, [GSequenceNode, GSequenceNode], :void
  
  # (Not documented)
  # 
  # @method g_sequence_insert_sorted(seq, data, cmp_func, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_insert_sorted, :g_sequence_insert_sorted, [GSequence, :pointer, :g_compare_data_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_insert_sorted_iter, :g_sequence_insert_sorted_iter, [GSequence, :pointer, :g_sequence_iter_compare_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_sort_changed(iter, cmp_func, cmp_data)
  # @param [GSequenceNode] iter 
  # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_sort_changed, :g_sequence_sort_changed, [GSequenceNode, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data)
  # @param [GSequenceNode] iter 
  # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_sort_changed_iter, :g_sequence_sort_changed_iter, [GSequenceNode, :g_sequence_iter_compare_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_remove(iter)
  # @param [GSequenceNode] iter 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_remove, :g_sequence_remove, [GSequenceNode], :void
  
  # (Not documented)
  # 
  # @method g_sequence_remove_range(begin_, end_)
  # @param [GSequenceNode] begin_ 
  # @param [GSequenceNode] end_ 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_remove_range, :g_sequence_remove_range, [GSequenceNode, GSequenceNode], :void
  
  # (Not documented)
  # 
  # @method g_sequence_move_range(dest, begin_, end_)
  # @param [GSequenceNode] dest 
  # @param [GSequenceNode] begin_ 
  # @param [GSequenceNode] end_ 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_move_range, :g_sequence_move_range, [GSequenceNode, GSequenceNode, GSequenceNode], :void
  
  # (Not documented)
  # 
  # @method g_sequence_search(seq, data, cmp_func, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_search, :g_sequence_search, [GSequence, :pointer, :g_compare_data_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_search_iter(seq, data, iter_cmp, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_search_iter, :g_sequence_search_iter, [GSequence, :pointer, :g_sequence_iter_compare_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_lookup(seq, data, cmp_func, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_compare_data_func_)] cmp_func 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_lookup, :g_sequence_lookup, [GSequence, :pointer, :g_compare_data_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data)
  # @param [GSequence] seq 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [Proc(_callback_g_sequence_iter_compare_func_)] iter_cmp 
  # @param [FFI::Pointer(Gpointer)] cmp_data 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_lookup_iter, :g_sequence_lookup_iter, [GSequence, :pointer, :g_sequence_iter_compare_func, :pointer], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_get(iter)
  # @param [GSequenceNode] iter 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_sequence_get, :g_sequence_get, [GSequenceNode], :pointer
  
  # (Not documented)
  # 
  # @method g_sequence_set(iter, data)
  # @param [GSequenceNode] iter 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_sequence_set, :g_sequence_set, [GSequenceNode, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_sequence_iter_is_begin(iter)
  # @param [GSequenceNode] iter 
  # @return [Integer] 
  # @scope class
  attach_function :g_sequence_iter_is_begin, :g_sequence_iter_is_begin, [GSequenceNode], :int
  
  # (Not documented)
  # 
  # @method g_sequence_iter_is_end(iter)
  # @param [GSequenceNode] iter 
  # @return [Integer] 
  # @scope class
  attach_function :g_sequence_iter_is_end, :g_sequence_iter_is_end, [GSequenceNode], :int
  
  # (Not documented)
  # 
  # @method g_sequence_iter_next(iter)
  # @param [GSequenceNode] iter 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_iter_next, :g_sequence_iter_next, [GSequenceNode], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_iter_prev(iter)
  # @param [GSequenceNode] iter 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_iter_prev, :g_sequence_iter_prev, [GSequenceNode], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_iter_get_position(iter)
  # @param [GSequenceNode] iter 
  # @return [Integer] 
  # @scope class
  attach_function :g_sequence_iter_get_position, :g_sequence_iter_get_position, [GSequenceNode], :int
  
  # (Not documented)
  # 
  # @method g_sequence_iter_move(iter, delta)
  # @param [GSequenceNode] iter 
  # @param [Integer] delta 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_iter_move, :g_sequence_iter_move, [GSequenceNode, :int], GSequenceNode
  
  # (Not documented)
  # 
  # @method g_sequence_iter_get_sequence(iter)
  # @param [GSequenceNode] iter 
  # @return [GSequence] 
  # @scope class
  attach_function :g_sequence_iter_get_sequence, :g_sequence_iter_get_sequence, [GSequenceNode], GSequence
  
  # (Not documented)
  # 
  # @method g_sequence_iter_compare(a, b)
  # @param [GSequenceNode] a 
  # @param [GSequenceNode] b 
  # @return [Integer] 
  # @scope class
  attach_function :g_sequence_iter_compare, :g_sequence_iter_compare, [GSequenceNode, GSequenceNode], :int
  
  # (Not documented)
  # 
  # @method g_sequence_range_get_midpoint(begin_, end_)
  # @param [GSequenceNode] begin_ 
  # @param [GSequenceNode] end_ 
  # @return [GSequenceNode] 
  # @scope class
  attach_function :g_sequence_range_get_midpoint, :g_sequence_range_get_midpoint, [GSequenceNode, GSequenceNode], GSequenceNode
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_shell_error).</em>
  # 
  # === Options:
  # :bad_quoting ::
  #   mismatched or otherwise mangled quoting
  # :empty_string ::
  #   string to be parsed was empty
  # :failed ::
  #   
  # 
  # @method _enum_g_shell_error_
  # @return [Symbol]
  # @scope class
  enum :g_shell_error, [
    :bad_quoting, 0,
    :empty_string, 1,
    :failed, 2
  ]
  
  # (Not documented)
  # 
  # @method g_shell_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_shell_error_quark, :g_shell_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_shell_quote(unquoted_string)
  # @param [String] unquoted_string 
  # @return [String] 
  # @scope class
  attach_function :g_shell_quote, :g_shell_quote, [:string], :string
  
  # (Not documented)
  # 
  # @method g_shell_unquote(quoted_string, error)
  # @param [String] quoted_string 
  # @param [FFI::Pointer(**GError)] error 
  # @return [String] 
  # @scope class
  attach_function :g_shell_unquote, :g_shell_unquote, [:string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_shell_parse_argv(command_line, argcp, argvp, error)
  # @param [String] command_line 
  # @param [FFI::Pointer(*Gint)] argcp 
  # @param [FFI::Pointer(***Gchar)] argvp 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_shell_parse_argv, :g_shell_parse_argv, [:string, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_slice_alloc(block_size)
  # @param [Integer] block_size 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_slice_alloc, :g_slice_alloc, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_slice_alloc0(block_size)
  # @param [Integer] block_size 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_slice_alloc0, :g_slice_alloc0, [:uint], :pointer
  
  # (Not documented)
  # 
  # @method g_slice_copy(block_size, mem_block)
  # @param [Integer] block_size 
  # @param [FFI::Pointer(Gconstpointer)] mem_block 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_slice_copy, :g_slice_copy, [:uint, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_slice_free1(block_size, mem_block)
  # @param [Integer] block_size 
  # @param [FFI::Pointer(Gpointer)] mem_block 
  # @return [nil] 
  # @scope class
  attach_function :g_slice_free1, :g_slice_free1, [:uint, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_slice_free_chain_with_offset(block_size, mem_chain, next_offset)
  # @param [Integer] block_size 
  # @param [FFI::Pointer(Gpointer)] mem_chain 
  # @param [Integer] next_offset 
  # @return [nil] 
  # @scope class
  attach_function :g_slice_free_chain_with_offset, :g_slice_free_chain_with_offset, [:uint, :pointer, :uint], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_slice_config).</em>
  # 
  # === Options:
  # :always_malloc ::
  #   
  # :bypass_magazines ::
  #   
  # :working_set_msecs ::
  #   
  # :color_increment ::
  #   
  # :chunk_sizes ::
  #   
  # :contention_counter ::
  #   
  # 
  # @method _enum_g_slice_config_
  # @return [Symbol]
  # @scope class
  enum :g_slice_config, [
    :always_malloc, 1,
    :bypass_magazines, 2,
    :working_set_msecs, 3,
    :color_increment, 4,
    :chunk_sizes, 5,
    :contention_counter, 6
  ]
  
  # (Not documented)
  # 
  # @method g_slice_set_config(ckey, value)
  # @param [Symbol from _enum_g_slice_config_] ckey 
  # @param [Integer] value 
  # @return [nil] 
  # @scope class
  attach_function :g_slice_set_config, :g_slice_set_config, [:g_slice_config, :long_long], :void
  
  # (Not documented)
  # 
  # @method g_slice_get_config(ckey)
  # @param [Symbol from _enum_g_slice_config_] ckey 
  # @return [Integer] 
  # @scope class
  attach_function :g_slice_get_config, :g_slice_get_config, [:g_slice_config], :long_long
  
  # (Not documented)
  # 
  # @method g_slice_get_config_state(ckey, address, n_values)
  # @param [Symbol from _enum_g_slice_config_] ckey 
  # @param [Integer] address 
  # @param [FFI::Pointer(*Guint)] n_values 
  # @return [FFI::Pointer(*Gint64)] 
  # @scope class
  attach_function :g_slice_get_config_state, :g_slice_get_config_state, [:g_slice_config, :long_long, :pointer], :pointer
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_spawn_error).</em>
  # 
  # === Options:
  # :fork ::
  #   
  # :read ::
  #   fork failed due to lack of memory
  # :chdir ::
  #   read or select on pipes failed
  # :acces ::
  #   changing to working dir failed
  # :perm ::
  #   execv() returned EACCES
  # :too_big ::
  #   execv() returned EPERM
  # :noexec ::
  #   
  # :nametoolong ::
  #   execv() returned ENOEXEC
  # :noent ::
  #   ""  "" ENAMETOOLONG
  # :nomem ::
  #   ""  "" ENOENT
  # :notdir ::
  #   ""  "" ENOMEM
  # :loop ::
  #   ""  "" ENOTDIR
  # :txtbusy ::
  #   ""  "" ELOOP  
  # :io ::
  #   ""  "" ETXTBUSY
  # :nfile ::
  #   ""  "" EIO
  # :mfile ::
  #   ""  "" ENFILE
  # :inval ::
  #   ""  "" EMFLE
  # :isdir ::
  #   ""  "" EINVAL
  # :libbad ::
  #   ""  "" EISDIR
  # :failed ::
  #   ""  "" ELIBBAD
  # 
  # @method _enum_g_spawn_error_
  # @return [Symbol]
  # @scope class
  enum :g_spawn_error, [
    :fork, 0,
    :read, 1,
    :chdir, 2,
    :acces, 3,
    :perm, 4,
    :too_big, 5,
    :noexec, 6,
    :nametoolong, 7,
    :noent, 8,
    :nomem, 9,
    :notdir, 10,
    :loop, 11,
    :txtbusy, 12,
    :io, 13,
    :nfile, 14,
    :mfile, 15,
    :inval, 16,
    :isdir, 17,
    :libbad, 18,
    :failed, 19
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_spawn_flags).</em>
  # 
  # === Options:
  # :leave_descriptors_open ::
  #   
  # :do_not_reap_child ::
  #   
  # :search_path ::
  #   look for argv(0) in the path i.e. use execvp()
  # :stdout_to_dev_null ::
  #   Dump output to /dev/null
  # :stderr_to_dev_null ::
  #   
  # :child_inherits_stdin ::
  #   
  # :file_and_argv_zero ::
  #   
  # :search_path_from_envp ::
  #   
  # 
  # @method _enum_g_spawn_flags_
  # @return [Symbol]
  # @scope class
  enum :g_spawn_flags, [
    :leave_descriptors_open, 1,
    :do_not_reap_child, 2,
    :search_path, 4,
    :stdout_to_dev_null, 8,
    :stderr_to_dev_null, 16,
    :child_inherits_stdin, 32,
    :file_and_argv_zero, 64,
    :search_path_from_envp, 128
  ]
  
  # (Not documented)
  # 
  # @method g_spawn_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_error_quark, :g_spawn_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_spawn_exit_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_exit_error_quark, :g_spawn_exit_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_spawn_async_utf8(working_directory, argv, envp, flags, child_setup, user_data, child_pid, error)
  # @param [String] working_directory 
  # @param [FFI::Pointer(**Gchar)] argv 
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [Symbol from _enum_g_spawn_flags_] flags 
  # @param [FFI::Pointer(GSpawnChildSetupFunc)] child_setup 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(*GPid)] child_pid 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_async_utf8, :g_spawn_async_utf8, [:string, :pointer, :pointer, :g_spawn_flags, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_async_with_pipes_utf8(working_directory, argv, envp, flags, child_setup, user_data, child_pid, standard_input, standard_output, standard_error, error)
  # @param [String] working_directory 
  # @param [FFI::Pointer(**Gchar)] argv 
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [Symbol from _enum_g_spawn_flags_] flags 
  # @param [FFI::Pointer(GSpawnChildSetupFunc)] child_setup 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(*GPid)] child_pid 
  # @param [FFI::Pointer(*Gint)] standard_input 
  # @param [FFI::Pointer(*Gint)] standard_output 
  # @param [FFI::Pointer(*Gint)] standard_error 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_async_with_pipes_utf8, :g_spawn_async_with_pipes_utf8, [:string, :pointer, :pointer, :g_spawn_flags, :pointer, :pointer, :pointer, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_sync_utf8(working_directory, argv, envp, flags, child_setup, user_data, standard_output, standard_error, exit_status, error)
  # @param [String] working_directory 
  # @param [FFI::Pointer(**Gchar)] argv 
  # @param [FFI::Pointer(**Gchar)] envp 
  # @param [Symbol from _enum_g_spawn_flags_] flags 
  # @param [FFI::Pointer(GSpawnChildSetupFunc)] child_setup 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [FFI::Pointer(**Gchar)] standard_output 
  # @param [FFI::Pointer(**Gchar)] standard_error 
  # @param [FFI::Pointer(*Gint)] exit_status 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_sync_utf8, :g_spawn_sync_utf8, [:string, :pointer, :pointer, :g_spawn_flags, :pointer, :pointer, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_command_line_sync_utf8(command_line, standard_output, standard_error, exit_status, error)
  # @param [String] command_line 
  # @param [FFI::Pointer(**Gchar)] standard_output 
  # @param [FFI::Pointer(**Gchar)] standard_error 
  # @param [FFI::Pointer(*Gint)] exit_status 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_command_line_sync_utf8, :g_spawn_command_line_sync_utf8, [:string, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_command_line_async_utf8(command_line, error)
  # @param [String] command_line 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_command_line_async_utf8, :g_spawn_command_line_async_utf8, [:string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_check_exit_status(exit_status, error)
  # @param [Integer] exit_status 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_spawn_check_exit_status, :g_spawn_check_exit_status, [:int, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_spawn_close_pid(pid)
  # @param [FFI::Pointer(GPid)] pid 
  # @return [nil] 
  # @scope class
  attach_function :g_spawn_close_pid, :g_spawn_close_pid, [:pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_ascii_type).</em>
  # 
  # === Options:
  # :alnum ::
  #   
  # :alpha ::
  #   
  # :cntrl ::
  #   
  # :digit ::
  #   
  # :graph ::
  #   
  # :lower ::
  #   
  # :print ::
  #   
  # :punct ::
  #   
  # :space ::
  #   
  # :upper ::
  #   
  # :xdigit ::
  #   
  # 
  # @method _enum_g_ascii_type_
  # @return [Symbol]
  # @scope class
  enum :g_ascii_type, [
    :alnum, 1,
    :alpha, 2,
    :cntrl, 4,
    :digit, 8,
    :graph, 16,
    :lower, 32,
    :print, 64,
    :punct, 128,
    :space, 256,
    :upper, 512,
    :xdigit, 1024
  ]
  
  # (Not documented)
  # 
  # @method g_ascii_tolower(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_tolower, :g_ascii_tolower, [:char], :char
  
  # (Not documented)
  # 
  # @method g_ascii_toupper(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_toupper, :g_ascii_toupper, [:char], :char
  
  # (Not documented)
  # 
  # @method g_ascii_digit_value(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_digit_value, :g_ascii_digit_value, [:char], :int
  
  # (Not documented)
  # 
  # @method g_ascii_xdigit_value(c)
  # @param [Integer] c 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_xdigit_value, :g_ascii_xdigit_value, [:char], :int
  
  # (Not documented)
  # 
  # @method g_strdelimit(string, delimiters, new_delimiter)
  # @param [String] string 
  # @param [String] delimiters 
  # @param [Integer] new_delimiter 
  # @return [String] 
  # @scope class
  attach_function :g_strdelimit, :g_strdelimit, [:string, :string, :char], :string
  
  # (Not documented)
  # 
  # @method g_strcanon(string, valid_chars, substitutor)
  # @param [String] string 
  # @param [String] valid_chars 
  # @param [Integer] substitutor 
  # @return [String] 
  # @scope class
  attach_function :g_strcanon, :g_strcanon, [:string, :string, :char], :string
  
  # (Not documented)
  # 
  # @method g_strerror(errnum)
  # @param [Integer] errnum 
  # @return [String] 
  # @scope class
  attach_function :g_strerror, :g_strerror, [:int], :string
  
  # (Not documented)
  # 
  # @method g_strsignal(signum)
  # @param [Integer] signum 
  # @return [String] 
  # @scope class
  attach_function :g_strsignal, :g_strsignal, [:int], :string
  
  # (Not documented)
  # 
  # @method g_strreverse(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_strreverse, :g_strreverse, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strlcpy(dest, src, dest_size)
  # @param [String] dest 
  # @param [String] src 
  # @param [Integer] dest_size 
  # @return [Integer] 
  # @scope class
  attach_function :g_strlcpy, :g_strlcpy, [:string, :string, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_strlcat(dest, src, dest_size)
  # @param [String] dest 
  # @param [String] src 
  # @param [Integer] dest_size 
  # @return [Integer] 
  # @scope class
  attach_function :g_strlcat, :g_strlcat, [:string, :string, :uint], :uint
  
  # (Not documented)
  # 
  # @method g_strstr_len(haystack, haystack_len, needle)
  # @param [String] haystack 
  # @param [Integer] haystack_len 
  # @param [String] needle 
  # @return [String] 
  # @scope class
  attach_function :g_strstr_len, :g_strstr_len, [:string, :int, :string], :string
  
  # (Not documented)
  # 
  # @method g_strrstr(haystack, needle)
  # @param [String] haystack 
  # @param [String] needle 
  # @return [String] 
  # @scope class
  attach_function :g_strrstr, :g_strrstr, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_strrstr_len(haystack, haystack_len, needle)
  # @param [String] haystack 
  # @param [Integer] haystack_len 
  # @param [String] needle 
  # @return [String] 
  # @scope class
  attach_function :g_strrstr_len, :g_strrstr_len, [:string, :int, :string], :string
  
  # (Not documented)
  # 
  # @method g_str_has_suffix(str, suffix)
  # @param [String] str 
  # @param [String] suffix 
  # @return [Integer] 
  # @scope class
  attach_function :g_str_has_suffix, :g_str_has_suffix, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_str_has_prefix(str, prefix)
  # @param [String] str 
  # @param [String] prefix 
  # @return [Integer] 
  # @scope class
  attach_function :g_str_has_prefix, :g_str_has_prefix, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_strtod(nptr, endptr)
  # @param [String] nptr 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @return [Float] 
  # @scope class
  attach_function :g_strtod, :g_strtod, [:string, :pointer], :double
  
  # (Not documented)
  # 
  # @method g_ascii_strtod(nptr, endptr)
  # @param [String] nptr 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @return [Float] 
  # @scope class
  attach_function :g_ascii_strtod, :g_ascii_strtod, [:string, :pointer], :double
  
  # (Not documented)
  # 
  # @method g_ascii_strtoull(nptr, endptr, base)
  # @param [String] nptr 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @param [Integer] base 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_strtoull, :g_ascii_strtoull, [:string, :pointer, :uint], :ulong_long
  
  # (Not documented)
  # 
  # @method g_ascii_strtoll(nptr, endptr, base)
  # @param [String] nptr 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @param [Integer] base 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_strtoll, :g_ascii_strtoll, [:string, :pointer, :uint], :long_long
  
  # (Not documented)
  # 
  # @method g_ascii_dtostr(buffer, buf_len, d)
  # @param [String] buffer 
  # @param [Integer] buf_len 
  # @param [Float] d 
  # @return [String] 
  # @scope class
  attach_function :g_ascii_dtostr, :g_ascii_dtostr, [:string, :int, :double], :string
  
  # (Not documented)
  # 
  # @method g_ascii_formatd(buffer, buf_len, format, d)
  # @param [String] buffer 
  # @param [Integer] buf_len 
  # @param [String] format 
  # @param [Float] d 
  # @return [String] 
  # @scope class
  attach_function :g_ascii_formatd, :g_ascii_formatd, [:string, :int, :string, :double], :string
  
  # (Not documented)
  # 
  # @method g_strchug(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_strchug, :g_strchug, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strchomp(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_strchomp, :g_strchomp, [:string], :string
  
  # (Not documented)
  # 
  # @method g_ascii_strcasecmp(s1, s2)
  # @param [String] s1 
  # @param [String] s2 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_strcasecmp, :g_ascii_strcasecmp, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_ascii_strncasecmp(s1, s2, n)
  # @param [String] s1 
  # @param [String] s2 
  # @param [Integer] n 
  # @return [Integer] 
  # @scope class
  attach_function :g_ascii_strncasecmp, :g_ascii_strncasecmp, [:string, :string, :uint], :int
  
  # (Not documented)
  # 
  # @method g_ascii_strdown(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_ascii_strdown, :g_ascii_strdown, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_ascii_strup(str, len)
  # @param [String] str 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_ascii_strup, :g_ascii_strup, [:string, :int], :string
  
  # (Not documented)
  # 
  # @method g_strcasecmp(s1, s2)
  # @param [String] s1 
  # @param [String] s2 
  # @return [Integer] 
  # @scope class
  attach_function :g_strcasecmp, :g_strcasecmp, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_strncasecmp(s1, s2, n)
  # @param [String] s1 
  # @param [String] s2 
  # @param [Integer] n 
  # @return [Integer] 
  # @scope class
  attach_function :g_strncasecmp, :g_strncasecmp, [:string, :string, :uint], :int
  
  # (Not documented)
  # 
  # @method g_strdown(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_strdown, :g_strdown, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strup(string)
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_strup, :g_strup, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strdup(str)
  # @param [String] str 
  # @return [String] 
  # @scope class
  attach_function :g_strdup, :g_strdup, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strdup_printf(format)
  # @param [String] format 
  # @return [String] 
  # @scope class
  attach_function :g_strdup_printf, :g_strdup_printf, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strdup_vprintf(format, args)
  # @param [String] format 
  # @param [String] args 
  # @return [String] 
  # @scope class
  attach_function :g_strdup_vprintf, :g_strdup_vprintf, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_strndup(str, n)
  # @param [String] str 
  # @param [Integer] n 
  # @return [String] 
  # @scope class
  attach_function :g_strndup, :g_strndup, [:string, :uint], :string
  
  # (Not documented)
  # 
  # @method g_strnfill(length, fill_char)
  # @param [Integer] length 
  # @param [Integer] fill_char 
  # @return [String] 
  # @scope class
  attach_function :g_strnfill, :g_strnfill, [:uint, :char], :string
  
  # (Not documented)
  # 
  # @method g_strconcat(string1)
  # @param [String] string1 
  # @return [String] 
  # @scope class
  attach_function :g_strconcat, :g_strconcat, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strjoin(separator)
  # @param [String] separator 
  # @return [String] 
  # @scope class
  attach_function :g_strjoin, :g_strjoin, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strcompress(source)
  # @param [String] source 
  # @return [String] 
  # @scope class
  attach_function :g_strcompress, :g_strcompress, [:string], :string
  
  # (Not documented)
  # 
  # @method g_strescape(source, exceptions)
  # @param [String] source 
  # @param [String] exceptions 
  # @return [String] 
  # @scope class
  attach_function :g_strescape, :g_strescape, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_memdup(mem, byte_size)
  # @param [FFI::Pointer(Gconstpointer)] mem 
  # @param [Integer] byte_size 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_memdup, :g_memdup, [:pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_strsplit(string, delimiter, max_tokens)
  # @param [String] string 
  # @param [String] delimiter 
  # @param [Integer] max_tokens 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_strsplit, :g_strsplit, [:string, :string, :int], :pointer
  
  # (Not documented)
  # 
  # @method g_strsplit_set(string, delimiters, max_tokens)
  # @param [String] string 
  # @param [String] delimiters 
  # @param [Integer] max_tokens 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_strsplit_set, :g_strsplit_set, [:string, :string, :int], :pointer
  
  # (Not documented)
  # 
  # @method g_strjoinv(separator, str_array)
  # @param [String] separator 
  # @param [FFI::Pointer(**Gchar)] str_array 
  # @return [String] 
  # @scope class
  attach_function :g_strjoinv, :g_strjoinv, [:string, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_strfreev(str_array)
  # @param [FFI::Pointer(**Gchar)] str_array 
  # @return [nil] 
  # @scope class
  attach_function :g_strfreev, :g_strfreev, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_strdupv(str_array)
  # @param [FFI::Pointer(**Gchar)] str_array 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_strdupv, :g_strdupv, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_strv_length(str_array)
  # @param [FFI::Pointer(**Gchar)] str_array 
  # @return [Integer] 
  # @scope class
  attach_function :g_strv_length, :g_strv_length, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_stpcpy(dest, src)
  # @param [String] dest 
  # @param [String] src 
  # @return [String] 
  # @scope class
  attach_function :g_stpcpy, :g_stpcpy, [:string, :string], :string
  
  # (Not documented)
  module GStringChunkWrappers
    # @return [nil] 
    def free()
      Glib.g_string_chunk_free(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_string_chunk_clear(self)
    end
    
    # @param [String] string 
    # @return [String] 
    def insert(string)
      Glib.g_string_chunk_insert(self, string)
    end
    
    # @param [String] string 
    # @param [Integer] len 
    # @return [String] 
    def insert_len(string, len)
      Glib.g_string_chunk_insert_len(self, string, len)
    end
    
    # @param [String] string 
    # @return [String] 
    def insert_const(string)
      Glib.g_string_chunk_insert_const(self, string)
    end
  end
  
  class GStringChunk < FFI::Struct
    include GStringChunkWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_string_chunk_new(size)
  # @param [Integer] size 
  # @return [GStringChunk] 
  # @scope class
  attach_function :g_string_chunk_new, :g_string_chunk_new, [:uint], GStringChunk
  
  # (Not documented)
  # 
  # @method g_string_chunk_free(chunk)
  # @param [GStringChunk] chunk 
  # @return [nil] 
  # @scope class
  attach_function :g_string_chunk_free, :g_string_chunk_free, [GStringChunk], :void
  
  # (Not documented)
  # 
  # @method g_string_chunk_clear(chunk)
  # @param [GStringChunk] chunk 
  # @return [nil] 
  # @scope class
  attach_function :g_string_chunk_clear, :g_string_chunk_clear, [GStringChunk], :void
  
  # (Not documented)
  # 
  # @method g_string_chunk_insert(chunk, string)
  # @param [GStringChunk] chunk 
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_string_chunk_insert, :g_string_chunk_insert, [GStringChunk, :string], :string
  
  # (Not documented)
  # 
  # @method g_string_chunk_insert_len(chunk, string, len)
  # @param [GStringChunk] chunk 
  # @param [String] string 
  # @param [Integer] len 
  # @return [String] 
  # @scope class
  attach_function :g_string_chunk_insert_len, :g_string_chunk_insert_len, [GStringChunk, :string, :int], :string
  
  # (Not documented)
  # 
  # @method g_string_chunk_insert_const(chunk, string)
  # @param [GStringChunk] chunk 
  # @param [String] string 
  # @return [String] 
  # @scope class
  attach_function :g_string_chunk_insert_const, :g_string_chunk_insert_const, [GStringChunk, :string], :string
  
  # (Not documented)
  class GTestCase < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  module GTestSuiteWrappers
    # @param [GTestCase] test_case 
    # @return [nil] 
    def add(test_case)
      Glib.g_test_suite_add(self, test_case)
    end
    
    # @param [FFI::Pointer(*GTestSuite)] nestedsuite 
    # @return [nil] 
    def add_suite(nestedsuite)
      Glib.g_test_suite_add_suite(self, nestedsuite)
    end
  end
  
  class GTestSuite < FFI::Struct
    include GTestSuiteWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_test_fixture_func_(user_data)
  # @param [FFI::Pointer(Gconstpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_test_fixture_func, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_strcmp0(str1, str2)
  # @param [String] str1 
  # @param [String] str2 
  # @return [Integer] 
  # @scope class
  attach_function :g_strcmp0, :g_strcmp0, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_test_minimized_result(minimized_quantity, format)
  # @param [Float] minimized_quantity 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_test_minimized_result, :g_test_minimized_result, [:double, :string], :void
  
  # (Not documented)
  # 
  # @method g_test_maximized_result(maximized_quantity, format)
  # @param [Float] maximized_quantity 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_test_maximized_result, :g_test_maximized_result, [:double, :string], :void
  
  # (Not documented)
  # 
  # @method g_test_init(argc, argv)
  # @param [FFI::Pointer(*Int)] argc 
  # @param [FFI::Pointer(***CharS)] argv 
  # @return [nil] 
  # @scope class
  attach_function :g_test_init, :g_test_init, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_run()
  # @return [Integer] 
  # @scope class
  attach_function :g_test_run, :g_test_run, [], :int
  
  # (Not documented)
  # 
  # @method g_test_add_func(testpath, test_func)
  # @param [String] testpath 
  # @param [FFI::Pointer(GTestFunc)] test_func 
  # @return [nil] 
  # @scope class
  attach_function :g_test_add_func, :g_test_add_func, [:string, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_add_data_func(testpath, test_data, test_func)
  # @param [String] testpath 
  # @param [FFI::Pointer(Gconstpointer)] test_data 
  # @param [FFI::Pointer(GTestDataFunc)] test_func 
  # @return [nil] 
  # @scope class
  attach_function :g_test_add_data_func, :g_test_add_data_func, [:string, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_add_data_func_full(testpath, test_data, test_func, data_free_func)
  # @param [String] testpath 
  # @param [FFI::Pointer(Gpointer)] test_data 
  # @param [FFI::Pointer(GTestDataFunc)] test_func 
  # @param [FFI::Pointer(GDestroyNotify)] data_free_func 
  # @return [nil] 
  # @scope class
  attach_function :g_test_add_data_func_full, :g_test_add_data_func_full, [:string, :pointer, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_fail()
  # @return [nil] 
  # @scope class
  attach_function :g_test_fail, :g_test_fail, [], :void
  
  # (Not documented)
  # 
  # @method g_test_message(format)
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_test_message, :g_test_message, [:string], :void
  
  # (Not documented)
  # 
  # @method g_test_bug_base(uri_pattern)
  # @param [String] uri_pattern 
  # @return [nil] 
  # @scope class
  attach_function :g_test_bug_base, :g_test_bug_base, [:string], :void
  
  # (Not documented)
  # 
  # @method g_test_bug(bug_uri_snippet)
  # @param [String] bug_uri_snippet 
  # @return [nil] 
  # @scope class
  attach_function :g_test_bug, :g_test_bug, [:string], :void
  
  # (Not documented)
  # 
  # @method g_test_timer_start()
  # @return [nil] 
  # @scope class
  attach_function :g_test_timer_start, :g_test_timer_start, [], :void
  
  # (Not documented)
  # 
  # @method g_test_timer_elapsed()
  # @return [Float] 
  # @scope class
  attach_function :g_test_timer_elapsed, :g_test_timer_elapsed, [], :double
  
  # (Not documented)
  # 
  # @method g_test_timer_last()
  # @return [Float] 
  # @scope class
  attach_function :g_test_timer_last, :g_test_timer_last, [], :double
  
  # (Not documented)
  # 
  # @method g_test_queue_free(gfree_pointer)
  # @param [FFI::Pointer(Gpointer)] gfree_pointer 
  # @return [nil] 
  # @scope class
  attach_function :g_test_queue_free, :g_test_queue_free, [:pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_queue_destroy(destroy_func, destroy_data)
  # @param [FFI::Pointer(GDestroyNotify)] destroy_func 
  # @param [FFI::Pointer(Gpointer)] destroy_data 
  # @return [nil] 
  # @scope class
  attach_function :g_test_queue_destroy, :g_test_queue_destroy, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_test_trap_flags).</em>
  # 
  # === Options:
  # :silence_stdout ::
  #   
  # :silence_stderr ::
  #   
  # :inherit_stdin ::
  #   
  # 
  # @method _enum_g_test_trap_flags_
  # @return [Symbol]
  # @scope class
  enum :g_test_trap_flags, [
    :silence_stdout, 128,
    :silence_stderr, 256,
    :inherit_stdin, 512
  ]
  
  # (Not documented)
  # 
  # @method g_test_trap_fork(usec_timeout, test_trap_flags)
  # @param [Integer] usec_timeout 
  # @param [Symbol from _enum_g_test_trap_flags_] test_trap_flags 
  # @return [Integer] 
  # @scope class
  attach_function :g_test_trap_fork, :g_test_trap_fork, [:ulong_long, :g_test_trap_flags], :int
  
  # (Not documented)
  # 
  # @method g_test_trap_has_passed()
  # @return [Integer] 
  # @scope class
  attach_function :g_test_trap_has_passed, :g_test_trap_has_passed, [], :int
  
  # (Not documented)
  # 
  # @method g_test_trap_reached_timeout()
  # @return [Integer] 
  # @scope class
  attach_function :g_test_trap_reached_timeout, :g_test_trap_reached_timeout, [], :int
  
  # (Not documented)
  # 
  # @method g_test_rand_int()
  # @return [Integer] 
  # @scope class
  attach_function :g_test_rand_int, :g_test_rand_int, [], :int
  
  # (Not documented)
  # 
  # @method g_test_rand_int_range(begin_, end_)
  # @param [Integer] begin_ 
  # @param [Integer] end_ 
  # @return [Integer] 
  # @scope class
  attach_function :g_test_rand_int_range, :g_test_rand_int_range, [:int, :int], :int
  
  # (Not documented)
  # 
  # @method g_test_rand_double()
  # @return [Float] 
  # @scope class
  attach_function :g_test_rand_double, :g_test_rand_double, [], :double
  
  # (Not documented)
  # 
  # @method g_test_rand_double_range(range_start, range_end)
  # @param [Float] range_start 
  # @param [Float] range_end 
  # @return [Float] 
  # @scope class
  attach_function :g_test_rand_double_range, :g_test_rand_double_range, [:double, :double], :double
  
  # (Not documented)
  # 
  # @method g_test_create_case(test_name, data_size, test_data, data_setup, data_test, data_teardown)
  # @param [String] test_name 
  # @param [Integer] data_size 
  # @param [FFI::Pointer(Gconstpointer)] test_data 
  # @param [Proc(_callback_g_test_fixture_func_)] data_setup 
  # @param [Proc(_callback_g_test_fixture_func_)] data_test 
  # @param [Proc(_callback_g_test_fixture_func_)] data_teardown 
  # @return [GTestCase] 
  # @scope class
  attach_function :g_test_create_case, :g_test_create_case, [:string, :uint, :pointer, :g_test_fixture_func, :g_test_fixture_func, :g_test_fixture_func], GTestCase
  
  # (Not documented)
  # 
  # @method g_test_create_suite(suite_name)
  # @param [String] suite_name 
  # @return [GTestSuite] 
  # @scope class
  attach_function :g_test_create_suite, :g_test_create_suite, [:string], GTestSuite
  
  # (Not documented)
  # 
  # @method g_test_get_root()
  # @return [GTestSuite] 
  # @scope class
  attach_function :g_test_get_root, :g_test_get_root, [], GTestSuite
  
  # (Not documented)
  # 
  # @method g_test_suite_add(suite, test_case)
  # @param [GTestSuite] suite 
  # @param [GTestCase] test_case 
  # @return [nil] 
  # @scope class
  attach_function :g_test_suite_add, :g_test_suite_add, [GTestSuite, GTestCase], :void
  
  # (Not documented)
  # 
  # @method g_test_suite_add_suite(suite, nestedsuite)
  # @param [GTestSuite] suite 
  # @param [GTestSuite] nestedsuite 
  # @return [nil] 
  # @scope class
  attach_function :g_test_suite_add_suite, :g_test_suite_add_suite, [GTestSuite, GTestSuite], :void
  
  # (Not documented)
  # 
  # @method g_test_run_suite(suite)
  # @param [GTestSuite] suite 
  # @return [Integer] 
  # @scope class
  attach_function :g_test_run_suite, :g_test_run_suite, [GTestSuite], :int
  
  # (Not documented)
  # 
  # @method g_test_trap_assertions(domain, file, line, func, assertion_flags, pattern)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [Integer] assertion_flags 
  # @param [String] pattern 
  # @return [nil] 
  # @scope class
  attach_function :g_test_trap_assertions, :g_test_trap_assertions, [:string, :string, :int, :string, :ulong_long, :string], :void
  
  # (Not documented)
  # 
  # @method g_assertion_message(domain, file, line, func, message)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [String] message 
  # @return [nil] 
  # @scope class
  attach_function :g_assertion_message, :g_assertion_message, [:string, :string, :int, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_assertion_message_expr(domain, file, line, func, expr)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [String] expr 
  # @return [nil] 
  # @scope class
  attach_function :g_assertion_message_expr, :g_assertion_message_expr, [:string, :string, :int, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp, arg2)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [String] expr 
  # @param [String] arg1 
  # @param [String] cmp 
  # @param [String] arg2 
  # @return [nil] 
  # @scope class
  attach_function :g_assertion_message_cmpstr, :g_assertion_message_cmpstr, [:string, :string, :int, :string, :string, :string, :string, :string], :void
  
  # (Not documented)
  # 
  # @method g_assertion_message_error(domain, file, line, func, expr, error, error_domain, error_code)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @param [String] expr 
  # @param [GError] error 
  # @param [Integer] error_domain 
  # @param [Integer] error_code 
  # @return [nil] 
  # @scope class
  attach_function :g_assertion_message_error, :g_assertion_message_error, [:string, :string, :int, :string, :string, GError, :uint, :int], :void
  
  # (Not documented)
  # 
  # @method g_test_add_vtable(testpath, data_size, test_data, data_setup, data_test, data_teardown)
  # @param [String] testpath 
  # @param [Integer] data_size 
  # @param [FFI::Pointer(Gconstpointer)] test_data 
  # @param [Proc(_callback_g_test_fixture_func_)] data_setup 
  # @param [Proc(_callback_g_test_fixture_func_)] data_test 
  # @param [Proc(_callback_g_test_fixture_func_)] data_teardown 
  # @return [nil] 
  # @scope class
  attach_function :g_test_add_vtable, :g_test_add_vtable, [:string, :uint, :pointer, :g_test_fixture_func, :g_test_fixture_func, :g_test_fixture_func], :void
  
  # (Not documented)
  # 
  # = Fields:
  # :test_initialized ::
  #   (Integer) 
  # :test_quick ::
  #   (Integer) disable thorough tests
  # :test_perf ::
  #   (Integer) run performance tests
  # :test_verbose ::
  #   (Integer) extra info
  # :test_quiet ::
  #   (Integer) reduce output
  # :test_undefined ::
  #   (Integer) run tests that are meant to assert
  class GTestConfig < FFI::Struct
    layout :test_initialized, :int,
           :test_quick, :int,
           :test_perf, :int,
           :test_verbose, :int,
           :test_quiet, :int,
           :test_undefined, :int
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_test_log_type).</em>
  # 
  # === Options:
  # :none ::
  #   
  # :error ::
  #   
  # :start_binary ::
  #   s:msg
  # :list_case ::
  #   s:binaryname s:seed
  # :skip_case ::
  #   s:testpath
  # :start_case ::
  #   s:testpath
  # :stop_case ::
  #   s:testpath
  # :min_result ::
  #   d:status d:nforks d:elapsed
  # :max_result ::
  #   s:blurb d:result
  # :message ::
  #   s:blurb d:result
  # 
  # @method _enum_g_test_log_type_
  # @return [Symbol]
  # @scope class
  enum :g_test_log_type, [
    :none, 0,
    :error, 1,
    :start_binary, 2,
    :list_case, 3,
    :skip_case, 4,
    :start_case, 5,
    :stop_case, 6,
    :min_result, 7,
    :max_result, 8,
    :message, 9
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :log_type ::
  #   (Symbol from _enum_g_test_log_type_) 
  # :n_strings ::
  #   (Integer) 
  # :strings ::
  #   (FFI::Pointer(**Gchar)) NULL terminated
  # :n_nums ::
  #   (Integer) 
  # :nums ::
  #   (FFI::Pointer(*LongDouble)) 
  module GTestLogMsgWrappers
    # @return [nil] 
    def free()
      Glib.g_test_log_msg_free(self)
    end
  end
  
  class GTestLogMsg < FFI::Struct
    include GTestLogMsgWrappers
    layout :log_type, :g_test_log_type,
           :n_strings, :uint,
           :strings, :pointer,
           :n_nums, :uint,
           :nums, :pointer
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :data ::
  #   (GString) < private >
  # :msgs ::
  #   (GSList) 
  module GTestLogBufferWrappers
    # @return [nil] 
    def free()
      Glib.g_test_log_buffer_free(self)
    end
    
    # @param [Integer] n_bytes 
    # @param [FFI::Pointer(*Guint8)] bytes 
    # @return [nil] 
    def push(n_bytes, bytes)
      Glib.g_test_log_buffer_push(self, n_bytes, bytes)
    end
    
    # @return [GTestLogMsg] 
    def pop()
      GTestLogMsg.new Glib.g_test_log_buffer_pop(self)
    end
  end
  
  class GTestLogBuffer < FFI::Struct
    include GTestLogBufferWrappers
    layout :data, GString,
           :msgs, GSList
  end
  
  # (Not documented)
  # 
  # @method g_test_log_type_name(log_type)
  # @param [Symbol from _enum_g_test_log_type_] log_type 
  # @return [String] 
  # @scope class
  attach_function :g_test_log_type_name, :g_test_log_type_name, [:g_test_log_type], :string
  
  # (Not documented)
  # 
  # @method g_test_log_buffer_new()
  # @return [GTestLogBuffer] 
  # @scope class
  attach_function :g_test_log_buffer_new, :g_test_log_buffer_new, [], GTestLogBuffer
  
  # (Not documented)
  # 
  # @method g_test_log_buffer_free(tbuffer)
  # @param [GTestLogBuffer] tbuffer 
  # @return [nil] 
  # @scope class
  attach_function :g_test_log_buffer_free, :g_test_log_buffer_free, [GTestLogBuffer], :void
  
  # (Not documented)
  # 
  # @method g_test_log_buffer_push(tbuffer, n_bytes, bytes)
  # @param [GTestLogBuffer] tbuffer 
  # @param [Integer] n_bytes 
  # @param [FFI::Pointer(*Guint8)] bytes 
  # @return [nil] 
  # @scope class
  attach_function :g_test_log_buffer_push, :g_test_log_buffer_push, [GTestLogBuffer, :uint, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_log_buffer_pop(tbuffer)
  # @param [GTestLogBuffer] tbuffer 
  # @return [GTestLogMsg] 
  # @scope class
  attach_function :g_test_log_buffer_pop, :g_test_log_buffer_pop, [GTestLogBuffer], GTestLogMsg
  
  # (Not documented)
  # 
  # @method g_test_log_msg_free(tmsg)
  # @param [GTestLogMsg] tmsg 
  # @return [nil] 
  # @scope class
  attach_function :g_test_log_msg_free, :g_test_log_msg_free, [GTestLogMsg], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_test_log_fatal_func_(log_domain, log_level, message, user_data)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] message 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [Integer] 
  # @scope class
  callback :g_test_log_fatal_func, [:string, :g_log_level_flags, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_test_log_set_fatal_handler(log_func, user_data)
  # @param [Proc(_callback_g_test_log_fatal_func_)] log_func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_test_log_set_fatal_handler, :g_test_log_set_fatal_handler, [:g_test_log_fatal_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_test_expect_message(log_domain, log_level, pattern)
  # @param [String] log_domain 
  # @param [Symbol from _enum_g_log_level_flags_] log_level 
  # @param [String] pattern 
  # @return [nil] 
  # @scope class
  attach_function :g_test_expect_message, :g_test_expect_message, [:string, :g_log_level_flags, :string], :void
  
  # (Not documented)
  # 
  # @method g_test_assert_expected_messages_internal(domain, file, line, func)
  # @param [String] domain 
  # @param [String] file 
  # @param [Integer] line 
  # @param [String] func 
  # @return [nil] 
  # @scope class
  attach_function :g_test_assert_expected_messages_internal, :g_test_assert_expected_messages_internal, [:string, :string, :int, :string], :void
  
  # (Not documented)
  # 
  # = Fields:
  # :func ::
  #   (Proc(_callback_g_func_)) 
  # :user_data ::
  #   (FFI::Pointer(Gpointer)) 
  # :exclusive ::
  #   (Integer) 
  module GThreadPoolWrappers
    # @param [Integer] immediate 
    # @param [Integer] wait 
    # @return [nil] 
    def free(immediate, wait)
      Glib.g_thread_pool_free(self, immediate, wait)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def push(data, error)
      Glib.g_thread_pool_push(self, data, error)
    end
    
    # @return [Integer] 
    def unprocessed()
      Glib.g_thread_pool_unprocessed(self)
    end
    
    # @param [Proc(_callback_g_compare_data_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def set_sort_function(func, user_data)
      Glib.g_thread_pool_set_sort_function(self, func, user_data)
    end
    
    # @param [Integer] max_threads 
    # @param [FFI::Pointer(**GError)] error 
    # @return [Integer] 
    def set_max_threads(max_threads, error)
      Glib.g_thread_pool_set_max_threads(self, max_threads, error)
    end
    
    # @return [Integer] 
    def get_max_threads()
      Glib.g_thread_pool_get_max_threads(self)
    end
    
    # @return [Integer] 
    def get_num_threads()
      Glib.g_thread_pool_get_num_threads(self)
    end
  end
  
  class GThreadPool < FFI::Struct
    include GThreadPoolWrappers
    layout :func, :g_func,
           :user_data, :pointer,
           :exclusive, :int
  end
  
  # (Not documented)
  # 
  # @method g_thread_pool_new(func, user_data, max_threads, exclusive, error)
  # @param [Proc(_callback_g_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @param [Integer] max_threads 
  # @param [Integer] exclusive 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GThreadPool] 
  # @scope class
  attach_function :g_thread_pool_new, :g_thread_pool_new, [:g_func, :pointer, :int, :int, :pointer], GThreadPool
  
  # (Not documented)
  # 
  # @method g_thread_pool_free(pool, immediate, wait)
  # @param [GThreadPool] pool 
  # @param [Integer] immediate 
  # @param [Integer] wait 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_pool_free, :g_thread_pool_free, [GThreadPool, :int, :int], :void
  
  # (Not documented)
  # 
  # @method g_thread_pool_push(pool, data, error)
  # @param [GThreadPool] pool 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_push, :g_thread_pool_push, [GThreadPool, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_thread_pool_unprocessed(pool)
  # @param [GThreadPool] pool 
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_unprocessed, :g_thread_pool_unprocessed, [GThreadPool], :uint
  
  # (Not documented)
  # 
  # @method g_thread_pool_set_sort_function(pool, func, user_data)
  # @param [GThreadPool] pool 
  # @param [Proc(_callback_g_compare_data_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_pool_set_sort_function, :g_thread_pool_set_sort_function, [GThreadPool, :g_compare_data_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_thread_pool_set_max_threads(pool, max_threads, error)
  # @param [GThreadPool] pool 
  # @param [Integer] max_threads 
  # @param [FFI::Pointer(**GError)] error 
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_set_max_threads, :g_thread_pool_set_max_threads, [GThreadPool, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_thread_pool_get_max_threads(pool)
  # @param [GThreadPool] pool 
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_get_max_threads, :g_thread_pool_get_max_threads, [GThreadPool], :int
  
  # (Not documented)
  # 
  # @method g_thread_pool_get_num_threads(pool)
  # @param [GThreadPool] pool 
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_get_num_threads, :g_thread_pool_get_num_threads, [GThreadPool], :uint
  
  # (Not documented)
  # 
  # @method g_thread_pool_set_max_unused_threads(max_threads)
  # @param [Integer] max_threads 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_pool_set_max_unused_threads, :g_thread_pool_set_max_unused_threads, [:int], :void
  
  # (Not documented)
  # 
  # @method g_thread_pool_get_max_unused_threads()
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_get_max_unused_threads, :g_thread_pool_get_max_unused_threads, [], :int
  
  # (Not documented)
  # 
  # @method g_thread_pool_get_num_unused_threads()
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_get_num_unused_threads, :g_thread_pool_get_num_unused_threads, [], :uint
  
  # (Not documented)
  # 
  # @method g_thread_pool_stop_unused_threads()
  # @return [nil] 
  # @scope class
  attach_function :g_thread_pool_stop_unused_threads, :g_thread_pool_stop_unused_threads, [], :void
  
  # (Not documented)
  # 
  # @method g_thread_pool_set_max_idle_time(interval)
  # @param [Integer] interval 
  # @return [nil] 
  # @scope class
  attach_function :g_thread_pool_set_max_idle_time, :g_thread_pool_set_max_idle_time, [:uint], :void
  
  # (Not documented)
  # 
  # @method g_thread_pool_get_max_idle_time()
  # @return [Integer] 
  # @scope class
  attach_function :g_thread_pool_get_max_idle_time, :g_thread_pool_get_max_idle_time, [], :uint
  
  # (Not documented)
  module GTimerWrappers
    # @return [nil] 
    def destroy()
      Glib.g_timer_destroy(self)
    end
    
    # @return [nil] 
    def start()
      Glib.g_timer_start(self)
    end
    
    # @return [nil] 
    def stop()
      Glib.g_timer_stop(self)
    end
    
    # @return [nil] 
    def reset()
      Glib.g_timer_reset(self)
    end
    
    # @return [nil] 
    def continue()
      Glib.g_timer_continue(self)
    end
    
    # @param [FFI::Pointer(*Gulong)] microseconds 
    # @return [Float] 
    def elapsed(microseconds)
      Glib.g_timer_elapsed(self, microseconds)
    end
  end
  
  class GTimer < FFI::Struct
    include GTimerWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_timer_new()
  # @return [GTimer] 
  # @scope class
  attach_function :g_timer_new, :g_timer_new, [], GTimer
  
  # (Not documented)
  # 
  # @method g_timer_destroy(timer)
  # @param [GTimer] timer 
  # @return [nil] 
  # @scope class
  attach_function :g_timer_destroy, :g_timer_destroy, [GTimer], :void
  
  # (Not documented)
  # 
  # @method g_timer_start(timer)
  # @param [GTimer] timer 
  # @return [nil] 
  # @scope class
  attach_function :g_timer_start, :g_timer_start, [GTimer], :void
  
  # (Not documented)
  # 
  # @method g_timer_stop(timer)
  # @param [GTimer] timer 
  # @return [nil] 
  # @scope class
  attach_function :g_timer_stop, :g_timer_stop, [GTimer], :void
  
  # (Not documented)
  # 
  # @method g_timer_reset(timer)
  # @param [GTimer] timer 
  # @return [nil] 
  # @scope class
  attach_function :g_timer_reset, :g_timer_reset, [GTimer], :void
  
  # (Not documented)
  # 
  # @method g_timer_continue(timer)
  # @param [GTimer] timer 
  # @return [nil] 
  # @scope class
  attach_function :g_timer_continue, :g_timer_continue, [GTimer], :void
  
  # (Not documented)
  # 
  # @method g_timer_elapsed(timer, microseconds)
  # @param [GTimer] timer 
  # @param [FFI::Pointer(*Gulong)] microseconds 
  # @return [Float] 
  # @scope class
  attach_function :g_timer_elapsed, :g_timer_elapsed, [GTimer, :pointer], :double
  
  # (Not documented)
  # 
  # @method g_usleep(microseconds)
  # @param [Integer] microseconds 
  # @return [nil] 
  # @scope class
  attach_function :g_usleep, :g_usleep, [:ulong], :void
  
  # (Not documented)
  # 
  # @method g_time_val_add(time, microseconds)
  # @param [GTimeVal] time 
  # @param [Integer] microseconds 
  # @return [nil] 
  # @scope class
  attach_function :g_time_val_add, :g_time_val_add, [GTimeVal, :long], :void
  
  # (Not documented)
  # 
  # @method g_time_val_from_iso8601(iso_date, time)
  # @param [String] iso_date 
  # @param [GTimeVal] time 
  # @return [Integer] 
  # @scope class
  attach_function :g_time_val_from_iso8601, :g_time_val_from_iso8601, [:string, GTimeVal], :int
  
  # (Not documented)
  # 
  # @method g_time_val_to_iso8601(time)
  # @param [GTimeVal] time 
  # @return [String] 
  # @scope class
  attach_function :g_time_val_to_iso8601, :g_time_val_to_iso8601, [GTimeVal], :string
  
  # (Not documented)
  # 
  # = Fields:
  # :next_ ::
  #   (FFI::Pointer(*GTrashStack)) 
  class GTrashStack < FFI::Struct
    layout :next_, :pointer
  end
  
  # (Not documented)
  # 
  # @method g_trash_stack_push(stack_p, data_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @param [FFI::Pointer(Gpointer)] data_p 
  # @return [nil] 
  # @scope class
  attach_function :g_trash_stack_push, :g_trash_stack_push, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_trash_stack_pop(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_trash_stack_pop, :g_trash_stack_pop, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_trash_stack_peek(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_trash_stack_peek, :g_trash_stack_peek, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_trash_stack_height(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [Integer] 
  # @scope class
  attach_function :g_trash_stack_height, :g_trash_stack_height, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_trash_stack_push(stack_p, data_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @param [FFI::Pointer(Gpointer)] data_p 
  # @return [nil] 
  # @scope class
  attach_function :g_trash_stack_push, :g_trash_stack_push, [:pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_trash_stack_pop(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_trash_stack_pop, :g_trash_stack_pop, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_trash_stack_peek(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_trash_stack_peek, :g_trash_stack_peek, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_trash_stack_height(stack_p)
  # @param [FFI::Pointer(**GTrashStack)] stack_p 
  # @return [Integer] 
  # @scope class
  attach_function :g_trash_stack_height, :g_trash_stack_height, [:pointer], :uint
  
  # (Not documented)
  module GTreeWrappers
    # @return [GTree] 
    def ref()
      GTree.new Glib.g_tree_ref(self)
    end
    
    # @return [nil] 
    def unref()
      Glib.g_tree_unref(self)
    end
    
    # @return [nil] 
    def destroy()
      Glib.g_tree_destroy(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] key 
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def insert(key, value)
      Glib.g_tree_insert(self, key, value)
    end
    
    # @param [FFI::Pointer(Gpointer)] key 
    # @param [FFI::Pointer(Gpointer)] value 
    # @return [nil] 
    def replace(key, value)
      Glib.g_tree_replace(self, key, value)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [Integer] 
    def remove(key)
      Glib.g_tree_remove(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [Integer] 
    def steal(key)
      Glib.g_tree_steal(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] key 
    # @return [FFI::Pointer(Gpointer)] 
    def lookup(key)
      Glib.g_tree_lookup(self, key)
    end
    
    # @param [FFI::Pointer(Gconstpointer)] lookup_key 
    # @param [FFI::Pointer(*Gpointer)] orig_key 
    # @param [FFI::Pointer(*Gpointer)] value 
    # @return [Integer] 
    def lookup_extended(lookup_key, orig_key, value)
      Glib.g_tree_lookup_extended(self, lookup_key, orig_key, value)
    end
    
    # @param [Proc(_callback_g_traverse_func_)] func 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def foreach(func, user_data)
      Glib.g_tree_foreach(self, func, user_data)
    end
    
    # @param [Proc(_callback_g_traverse_func_)] traverse_func 
    # @param [Symbol from _enum_g_traverse_type_] traverse_type 
    # @param [FFI::Pointer(Gpointer)] user_data 
    # @return [nil] 
    def traverse(traverse_func, traverse_type, user_data)
      Glib.g_tree_traverse(self, traverse_func, traverse_type, user_data)
    end
    
    # @param [Proc(_callback_g_compare_func_)] search_func 
    # @param [FFI::Pointer(Gconstpointer)] user_data 
    # @return [FFI::Pointer(Gpointer)] 
    def search(search_func, user_data)
      Glib.g_tree_search(self, search_func, user_data)
    end
    
    # @return [Integer] 
    def height()
      Glib.g_tree_height(self)
    end
    
    # @return [Integer] 
    def nnodes()
      Glib.g_tree_nnodes(self)
    end
  end
  
  class GTree < FFI::Struct
    include GTreeWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_traverse_func_(key, value, data)
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_traverse_func, [:pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_tree_new(key_compare_func)
  # @param [Proc(_callback_g_compare_func_)] key_compare_func 
  # @return [GTree] 
  # @scope class
  attach_function :g_tree_new, :g_tree_new, [:g_compare_func], GTree
  
  # (Not documented)
  # 
  # @method g_tree_new_with_data(key_compare_func, key_compare_data)
  # @param [Proc(_callback_g_compare_data_func_)] key_compare_func 
  # @param [FFI::Pointer(Gpointer)] key_compare_data 
  # @return [GTree] 
  # @scope class
  attach_function :g_tree_new_with_data, :g_tree_new_with_data, [:g_compare_data_func, :pointer], GTree
  
  # (Not documented)
  # 
  # @method g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func)
  # @param [Proc(_callback_g_compare_data_func_)] key_compare_func 
  # @param [FFI::Pointer(Gpointer)] key_compare_data 
  # @param [FFI::Pointer(GDestroyNotify)] key_destroy_func 
  # @param [FFI::Pointer(GDestroyNotify)] value_destroy_func 
  # @return [GTree] 
  # @scope class
  attach_function :g_tree_new_full, :g_tree_new_full, [:g_compare_data_func, :pointer, :pointer, :pointer], GTree
  
  # (Not documented)
  # 
  # @method g_tree_ref(tree)
  # @param [GTree] tree 
  # @return [GTree] 
  # @scope class
  attach_function :g_tree_ref, :g_tree_ref, [GTree], GTree
  
  # (Not documented)
  # 
  # @method g_tree_unref(tree)
  # @param [GTree] tree 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_unref, :g_tree_unref, [GTree], :void
  
  # (Not documented)
  # 
  # @method g_tree_destroy(tree)
  # @param [GTree] tree 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_destroy, :g_tree_destroy, [GTree], :void
  
  # (Not documented)
  # 
  # @method g_tree_insert(tree, key, value)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_insert, :g_tree_insert, [GTree, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_tree_replace(tree, key, value)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gpointer)] key 
  # @param [FFI::Pointer(Gpointer)] value 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_replace, :g_tree_replace, [GTree, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_tree_remove(tree, key)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  attach_function :g_tree_remove, :g_tree_remove, [GTree, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_tree_steal(tree, key)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [Integer] 
  # @scope class
  attach_function :g_tree_steal, :g_tree_steal, [GTree, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_tree_lookup(tree, key)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gconstpointer)] key 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_tree_lookup, :g_tree_lookup, [GTree, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_tree_lookup_extended(tree, lookup_key, orig_key, value)
  # @param [GTree] tree 
  # @param [FFI::Pointer(Gconstpointer)] lookup_key 
  # @param [FFI::Pointer(*Gpointer)] orig_key 
  # @param [FFI::Pointer(*Gpointer)] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_tree_lookup_extended, :g_tree_lookup_extended, [GTree, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_tree_foreach(tree, func, user_data)
  # @param [GTree] tree 
  # @param [Proc(_callback_g_traverse_func_)] func 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_foreach, :g_tree_foreach, [GTree, :g_traverse_func, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_tree_traverse(tree, traverse_func, traverse_type, user_data)
  # @param [GTree] tree 
  # @param [Proc(_callback_g_traverse_func_)] traverse_func 
  # @param [Symbol from _enum_g_traverse_type_] traverse_type 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [nil] 
  # @scope class
  attach_function :g_tree_traverse, :g_tree_traverse, [GTree, :g_traverse_func, :g_traverse_type, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_tree_search(tree, search_func, user_data)
  # @param [GTree] tree 
  # @param [Proc(_callback_g_compare_func_)] search_func 
  # @param [FFI::Pointer(Gconstpointer)] user_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :g_tree_search, :g_tree_search, [GTree, :g_compare_func, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_tree_height(tree)
  # @param [GTree] tree 
  # @return [Integer] 
  # @scope class
  attach_function :g_tree_height, :g_tree_height, [GTree], :int
  
  # (Not documented)
  # 
  # @method g_tree_nnodes(tree)
  # @param [GTree] tree 
  # @return [Integer] 
  # @scope class
  attach_function :g_tree_nnodes, :g_tree_nnodes, [GTree], :int
  
  # (Not documented)
  # 
  # @method g_uri_unescape_string(escaped_string, illegal_characters)
  # @param [String] escaped_string 
  # @param [String] illegal_characters 
  # @return [String] 
  # @scope class
  attach_function :g_uri_unescape_string, :g_uri_unescape_string, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_characters)
  # @param [String] escaped_string 
  # @param [String] escaped_string_end 
  # @param [String] illegal_characters 
  # @return [String] 
  # @scope class
  attach_function :g_uri_unescape_segment, :g_uri_unescape_segment, [:string, :string, :string], :string
  
  # (Not documented)
  # 
  # @method g_uri_parse_scheme(uri)
  # @param [String] uri 
  # @return [String] 
  # @scope class
  attach_function :g_uri_parse_scheme, :g_uri_parse_scheme, [:string], :string
  
  # (Not documented)
  # 
  # @method g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8)
  # @param [String] unescaped 
  # @param [String] reserved_chars_allowed 
  # @param [Integer] allow_utf8 
  # @return [String] 
  # @scope class
  attach_function :g_uri_escape_string, :g_uri_escape_string, [:string, :string, :int], :string
  
  # (Not documented)
  module GVariantTypeWrappers
    # @return [nil] 
    def free()
      Glib.g_variant_type_free(self)
    end
    
    # @return [GVariantType] 
    def copy()
      GVariantType.new Glib.g_variant_type_copy(self)
    end
    
    # @return [Integer] 
    def get_string_length()
      Glib.g_variant_type_get_string_length(self)
    end
    
    # @return [String] 
    def peek_string()
      Glib.g_variant_type_peek_string(self)
    end
    
    # @return [String] 
    def dup_string()
      Glib.g_variant_type_dup_string(self)
    end
    
    # @return [Integer] 
    def is_definite()
      Glib.g_variant_type_is_definite(self)
    end
    
    # @return [Integer] 
    def is_container()
      Glib.g_variant_type_is_container(self)
    end
    
    # @return [Integer] 
    def is_basic()
      Glib.g_variant_type_is_basic(self)
    end
    
    # @return [Integer] 
    def is_maybe()
      Glib.g_variant_type_is_maybe(self)
    end
    
    # @return [Integer] 
    def is_array()
      Glib.g_variant_type_is_array(self)
    end
    
    # @return [Integer] 
    def is_tuple()
      Glib.g_variant_type_is_tuple(self)
    end
    
    # @return [Integer] 
    def is_dict_entry()
      Glib.g_variant_type_is_dict_entry(self)
    end
    
    # @return [Integer] 
    def is_variant()
      Glib.g_variant_type_is_variant(self)
    end
    
    # @param [FFI::Pointer(*GVariantType)] supertype 
    # @return [Integer] 
    def is_subtype_of(supertype)
      Glib.g_variant_type_is_subtype_of(self, supertype)
    end
    
    # @return [GVariantType] 
    def element()
      GVariantType.new Glib.g_variant_type_element(self)
    end
    
    # @return [GVariantType] 
    def first()
      GVariantType.new Glib.g_variant_type_first(self)
    end
    
    # @return [GVariantType] 
    def next_()
      GVariantType.new Glib.g_variant_type_next(self)
    end
    
    # @return [Integer] 
    def n_items()
      Glib.g_variant_type_n_items(self)
    end
    
    # @return [GVariantType] 
    def key()
      GVariantType.new Glib.g_variant_type_key(self)
    end
    
    # @return [GVariantType] 
    def value()
      GVariantType.new Glib.g_variant_type_value(self)
    end
    
    # @return [GVariantType] 
    def new_array()
      GVariantType.new Glib.g_variant_type_new_array(self)
    end
    
    # @return [GVariantType] 
    def new_maybe()
      GVariantType.new Glib.g_variant_type_new_maybe(self)
    end
    
    # @param [FFI::Pointer(*GVariantType)] value 
    # @return [GVariantType] 
    def new_dict_entry(value)
      GVariantType.new Glib.g_variant_type_new_dict_entry(self, value)
    end
  end
  
  class GVariantType < FFI::Struct
    include GVariantTypeWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # @method g_variant_type_string_is_valid(type_string)
  # @param [String] type_string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_string_is_valid, :g_variant_type_string_is_valid, [:string], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_string_scan(string, limit, endptr)
  # @param [String] string 
  # @param [String] limit 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_string_scan, :g_variant_type_string_scan, [:string, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_free(type)
  # @param [GVariantType] type 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_type_free, :g_variant_type_free, [GVariantType], :void
  
  # (Not documented)
  # 
  # @method g_variant_type_copy(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_copy, :g_variant_type_copy, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_new(type_string)
  # @param [String] type_string 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_new, :g_variant_type_new, [:string], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_get_string_length(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_get_string_length, :g_variant_type_get_string_length, [GVariantType], :uint
  
  # (Not documented)
  # 
  # @method g_variant_type_peek_string(type)
  # @param [GVariantType] type 
  # @return [String] 
  # @scope class
  attach_function :g_variant_type_peek_string, :g_variant_type_peek_string, [GVariantType], :string
  
  # (Not documented)
  # 
  # @method g_variant_type_dup_string(type)
  # @param [GVariantType] type 
  # @return [String] 
  # @scope class
  attach_function :g_variant_type_dup_string, :g_variant_type_dup_string, [GVariantType], :string
  
  # (Not documented)
  # 
  # @method g_variant_type_is_definite(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_definite, :g_variant_type_is_definite, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_container(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_container, :g_variant_type_is_container, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_basic(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_basic, :g_variant_type_is_basic, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_maybe(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_maybe, :g_variant_type_is_maybe, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_array(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_array, :g_variant_type_is_array, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_tuple(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_tuple, :g_variant_type_is_tuple, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_dict_entry(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_dict_entry, :g_variant_type_is_dict_entry, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_variant(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_variant, :g_variant_type_is_variant, [GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_hash(type)
  # @param [FFI::Pointer(Gconstpointer)] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_hash, :g_variant_type_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_variant_type_equal(type1, type2)
  # @param [FFI::Pointer(Gconstpointer)] type1 
  # @param [FFI::Pointer(Gconstpointer)] type2 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_equal, :g_variant_type_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_is_subtype_of(type, supertype)
  # @param [GVariantType] type 
  # @param [GVariantType] supertype 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_is_subtype_of, :g_variant_type_is_subtype_of, [GVariantType, GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_type_element(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_element, :g_variant_type_element, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_first(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_first, :g_variant_type_first, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_next(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_next, :g_variant_type_next, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_n_items(type)
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_type_n_items, :g_variant_type_n_items, [GVariantType], :uint
  
  # (Not documented)
  # 
  # @method g_variant_type_key(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_key, :g_variant_type_key, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_value(type)
  # @param [GVariantType] type 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_value, :g_variant_type_value, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_new_array(element)
  # @param [GVariantType] element 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_new_array, :g_variant_type_new_array, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_new_maybe(element)
  # @param [GVariantType] element 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_new_maybe, :g_variant_type_new_maybe, [GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_new_tuple(items, length)
  # @param [FFI::Pointer(**GVariantType)] items 
  # @param [Integer] length 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_new_tuple, :g_variant_type_new_tuple, [:pointer, :int], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_new_dict_entry(key, value)
  # @param [GVariantType] key 
  # @param [GVariantType] value 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_new_dict_entry, :g_variant_type_new_dict_entry, [GVariantType, GVariantType], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_type_checked(string)
  # @param [String] string 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_type_checked, :g_variant_type_checked_, [:string], GVariantType
  
  # (Not documented)
  module GVariantWrappers
    # @return [nil] 
    def unref()
      Glib.g_variant_unref(self)
    end
    
    # @return [GVariant] 
    def ref()
      GVariant.new Glib.g_variant_ref(self)
    end
    
    # @return [GVariant] 
    def ref_sink()
      GVariant.new Glib.g_variant_ref_sink(self)
    end
    
    # @return [Integer] 
    def is_floating()
      Glib.g_variant_is_floating(self)
    end
    
    # @return [GVariant] 
    def take_ref()
      GVariant.new Glib.g_variant_take_ref(self)
    end
    
    # @return [GVariantType] 
    def get_type()
      GVariantType.new Glib.g_variant_get_type(self)
    end
    
    # @return [String] 
    def get_type_string()
      Glib.g_variant_get_type_string(self)
    end
    
    # @param [GVariantType] type 
    # @return [Integer] 
    def is_of_type(type)
      Glib.g_variant_is_of_type(self, type)
    end
    
    # @return [Integer] 
    def is_container()
      Glib.g_variant_is_container(self)
    end
    
    # @return [Symbol from _enum_g_variant_class_] 
    def classify()
      Glib.g_variant_classify(self)
    end
    
    # @return [GVariant] 
    def new_variant()
      GVariant.new Glib.g_variant_new_variant(self)
    end
    
    # @return [Integer] 
    def get_boolean()
      Glib.g_variant_get_boolean(self)
    end
    
    # @return [Integer] 
    def get_byte()
      Glib.g_variant_get_byte(self)
    end
    
    # @return [Integer] 
    def get_int16()
      Glib.g_variant_get_int16(self)
    end
    
    # @return [Integer] 
    def get_uint16()
      Glib.g_variant_get_uint16(self)
    end
    
    # @return [Integer] 
    def get_int32()
      Glib.g_variant_get_int32(self)
    end
    
    # @return [Integer] 
    def get_uint32()
      Glib.g_variant_get_uint32(self)
    end
    
    # @return [Integer] 
    def get_int64()
      Glib.g_variant_get_int64(self)
    end
    
    # @return [Integer] 
    def get_uint64()
      Glib.g_variant_get_uint64(self)
    end
    
    # @return [Integer] 
    def get_handle()
      Glib.g_variant_get_handle(self)
    end
    
    # @return [Float] 
    def get_double()
      Glib.g_variant_get_double(self)
    end
    
    # @return [GVariant] 
    def get_variant()
      GVariant.new Glib.g_variant_get_variant(self)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [String] 
    def get_string(length)
      Glib.g_variant_get_string(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [String] 
    def dup_string(length)
      Glib.g_variant_dup_string(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def get_strv(length)
      Glib.g_variant_get_strv(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def dup_strv(length)
      Glib.g_variant_dup_strv(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def get_objv(length)
      Glib.g_variant_get_objv(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def dup_objv(length)
      Glib.g_variant_dup_objv(self, length)
    end
    
    # @return [String] 
    def get_bytestring()
      Glib.g_variant_get_bytestring(self)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [String] 
    def dup_bytestring(length)
      Glib.g_variant_dup_bytestring(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def get_bytestring_array(length)
      Glib.g_variant_get_bytestring_array(self, length)
    end
    
    # @param [FFI::Pointer(*Gsize)] length 
    # @return [FFI::Pointer(**Gchar)] 
    def dup_bytestring_array(length)
      Glib.g_variant_dup_bytestring_array(self, length)
    end
    
    # @param [FFI::Pointer(*GVariant)] value 
    # @return [GVariant] 
    def new_dict_entry(value)
      GVariant.new Glib.g_variant_new_dict_entry(self, value)
    end
    
    # @return [GVariant] 
    def get_maybe()
      GVariant.new Glib.g_variant_get_maybe(self)
    end
    
    # @return [Integer] 
    def n_children()
      Glib.g_variant_n_children(self)
    end
    
    # @param [Integer] index 
    # @param [String] format_string 
    # @return [nil] 
    def get_child(index, format_string)
      Glib.g_variant_get_child(self, index, format_string)
    end
    
    # @param [Integer] index 
    # @return [GVariant] 
    def get_child_value(index)
      GVariant.new Glib.g_variant_get_child_value(self, index)
    end
    
    # @param [String] key 
    # @param [String] format_string 
    # @return [Integer] 
    def lookup(key, format_string)
      Glib.g_variant_lookup(self, key, format_string)
    end
    
    # @param [String] key 
    # @param [GVariantType] expected_type 
    # @return [GVariant] 
    def lookup_value(key, expected_type)
      GVariant.new Glib.g_variant_lookup_value(self, key, expected_type)
    end
    
    # @param [FFI::Pointer(*Gsize)] n_elements 
    # @param [Integer] element_size 
    # @return [FFI::Pointer(Gconstpointer)] 
    def get_fixed_array(n_elements, element_size)
      Glib.g_variant_get_fixed_array(self, n_elements, element_size)
    end
    
    # @return [Integer] 
    def get_size()
      Glib.g_variant_get_size(self)
    end
    
    # @return [FFI::Pointer(Gconstpointer)] 
    def get_data()
      Glib.g_variant_get_data(self)
    end
    
    # @param [FFI::Pointer(Gpointer)] data 
    # @return [nil] 
    def store(data)
      Glib.g_variant_store(self, data)
    end
    
    # @param [Integer] type_annotate 
    # @return [String] 
    def print(type_annotate)
      Glib.g_variant_print(self, type_annotate)
    end
    
    # @param [GString] string 
    # @param [Integer] type_annotate 
    # @return [GString] 
    def print_string(string, type_annotate)
      GString.new Glib.g_variant_print_string(self, string, type_annotate)
    end
    
    # @return [GVariant] 
    def get_normal_form()
      GVariant.new Glib.g_variant_get_normal_form(self)
    end
    
    # @return [Integer] 
    def is_normal_form()
      Glib.g_variant_is_normal_form(self)
    end
    
    # @return [GVariant] 
    def byteswap()
      GVariant.new Glib.g_variant_byteswap(self)
    end
    
    # @return [GVariantIter] 
    def iter_new()
      GVariantIter.new Glib.g_variant_iter_new(self)
    end
    
    # @param [String] format_string 
    # @return [nil] 
    def get(format_string)
      Glib.g_variant_get(self, format_string)
    end
    
    # @param [String] format_string 
    # @param [FFI::Pointer(**Gchar)] endptr 
    # @param [FFI::Pointer(*VaList)] app 
    # @return [nil] 
    def get_va(format_string, endptr, app)
      Glib.g_variant_get_va(self, format_string, endptr, app)
    end
    
    # @param [String] format_string 
    # @param [Integer] copy_only 
    # @return [Integer] 
    def check_format_string(format_string, copy_only)
      Glib.g_variant_check_format_string(self, format_string, copy_only)
    end
  end
  
  class GVariant < FFI::Struct
    include GVariantWrappers
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_variant_class).</em>
  # 
  # === Options:
  # :boolean ::
  #   
  # :byte ::
  #   
  # :int16 ::
  #   
  # :uint16 ::
  #   
  # :int32 ::
  #   
  # :uint32 ::
  #   
  # :int64 ::
  #   
  # :uint64 ::
  #   
  # :handle ::
  #   
  # :double ::
  #   
  # :string ::
  #   
  # :object_path ::
  #   
  # :signature ::
  #   
  # :variant ::
  #   
  # :maybe ::
  #   
  # :array ::
  #   
  # :tuple ::
  #   
  # :dict_entry ::
  #   
  # 
  # @method _enum_g_variant_class_
  # @return [Symbol]
  # @scope class
  enum :g_variant_class, [
    :boolean, 98,
    :byte, 121,
    :int16, 110,
    :uint16, 113,
    :int32, 105,
    :uint32, 117,
    :int64, 120,
    :uint64, 116,
    :handle, 104,
    :double, 100,
    :string, 115,
    :object_path, 111,
    :signature, 103,
    :variant, 118,
    :maybe, 109,
    :array, 97,
    :tuple, 40,
    :dict_entry, 123
  ]
  
  # (Not documented)
  # 
  # @method g_variant_unref(value)
  # @param [GVariant] value 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_unref, :g_variant_unref, [GVariant], :void
  
  # (Not documented)
  # 
  # @method g_variant_ref(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_ref, :g_variant_ref, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_ref_sink(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_ref_sink, :g_variant_ref_sink, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_is_floating(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_floating, :g_variant_is_floating, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_take_ref(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_take_ref, :g_variant_take_ref, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_type(value)
  # @param [GVariant] value 
  # @return [GVariantType] 
  # @scope class
  attach_function :g_variant_get_type, :g_variant_get_type, [GVariant], GVariantType
  
  # (Not documented)
  # 
  # @method g_variant_get_type_string(value)
  # @param [GVariant] value 
  # @return [String] 
  # @scope class
  attach_function :g_variant_get_type_string, :g_variant_get_type_string, [GVariant], :string
  
  # (Not documented)
  # 
  # @method g_variant_is_of_type(value, type)
  # @param [GVariant] value 
  # @param [GVariantType] type 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_of_type, :g_variant_is_of_type, [GVariant, GVariantType], :int
  
  # (Not documented)
  # 
  # @method g_variant_is_container(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_container, :g_variant_is_container, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_classify(value)
  # @param [GVariant] value 
  # @return [Symbol from _enum_g_variant_class_] 
  # @scope class
  attach_function :g_variant_classify, :g_variant_classify, [GVariant], :g_variant_class
  
  # (Not documented)
  # 
  # @method g_variant_new_boolean(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_boolean, :g_variant_new_boolean, [:int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_byte(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_byte, :g_variant_new_byte, [:uchar], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_int16(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_int16, :g_variant_new_int16, [:short], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_uint16(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_uint16, :g_variant_new_uint16, [:ushort], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_int32(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_int32, :g_variant_new_int32, [:int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_uint32(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_uint32, :g_variant_new_uint32, [:uint], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_int64(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_int64, :g_variant_new_int64, [:long_long], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_uint64(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_uint64, :g_variant_new_uint64, [:ulong_long], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_handle(value)
  # @param [Integer] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_handle, :g_variant_new_handle, [:int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_double(value)
  # @param [Float] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_double, :g_variant_new_double, [:double], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_string(string)
  # @param [String] string 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_string, :g_variant_new_string, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_object_path(object_path)
  # @param [String] object_path 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_object_path, :g_variant_new_object_path, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_is_object_path(string)
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_object_path, :g_variant_is_object_path, [:string], :int
  
  # (Not documented)
  # 
  # @method g_variant_new_signature(signature)
  # @param [String] signature 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_signature, :g_variant_new_signature, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_is_signature(string)
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_signature, :g_variant_is_signature, [:string], :int
  
  # (Not documented)
  # 
  # @method g_variant_new_variant(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_variant, :g_variant_new_variant, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_strv(strv, length)
  # @param [FFI::Pointer(**Gchar)] strv 
  # @param [Integer] length 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_strv, :g_variant_new_strv, [:pointer, :int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_objv(strv, length)
  # @param [FFI::Pointer(**Gchar)] strv 
  # @param [Integer] length 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_objv, :g_variant_new_objv, [:pointer, :int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_bytestring(string)
  # @param [String] string 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_bytestring, :g_variant_new_bytestring, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_bytestring_array(strv, length)
  # @param [FFI::Pointer(**Gchar)] strv 
  # @param [Integer] length 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_bytestring_array, :g_variant_new_bytestring_array, [:pointer, :int], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_fixed_array(element_type, elements, n_elements, element_size)
  # @param [GVariantType] element_type 
  # @param [FFI::Pointer(Gconstpointer)] elements 
  # @param [Integer] n_elements 
  # @param [Integer] element_size 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_fixed_array, :g_variant_new_fixed_array, [GVariantType, :pointer, :uint, :uint], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_boolean(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_boolean, :g_variant_get_boolean, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_get_byte(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_byte, :g_variant_get_byte, [GVariant], :uchar
  
  # (Not documented)
  # 
  # @method g_variant_get_int16(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_int16, :g_variant_get_int16, [GVariant], :short
  
  # (Not documented)
  # 
  # @method g_variant_get_uint16(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_uint16, :g_variant_get_uint16, [GVariant], :ushort
  
  # (Not documented)
  # 
  # @method g_variant_get_int32(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_int32, :g_variant_get_int32, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_get_uint32(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_uint32, :g_variant_get_uint32, [GVariant], :uint
  
  # (Not documented)
  # 
  # @method g_variant_get_int64(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_int64, :g_variant_get_int64, [GVariant], :long_long
  
  # (Not documented)
  # 
  # @method g_variant_get_uint64(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_uint64, :g_variant_get_uint64, [GVariant], :ulong_long
  
  # (Not documented)
  # 
  # @method g_variant_get_handle(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_handle, :g_variant_get_handle, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_get_double(value)
  # @param [GVariant] value 
  # @return [Float] 
  # @scope class
  attach_function :g_variant_get_double, :g_variant_get_double, [GVariant], :double
  
  # (Not documented)
  # 
  # @method g_variant_get_variant(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_get_variant, :g_variant_get_variant, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_string(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [String] 
  # @scope class
  attach_function :g_variant_get_string, :g_variant_get_string, [GVariant, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_variant_dup_string(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [String] 
  # @scope class
  attach_function :g_variant_dup_string, :g_variant_dup_string, [GVariant, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_variant_get_strv(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_get_strv, :g_variant_get_strv, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_dup_strv(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_dup_strv, :g_variant_dup_strv, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_get_objv(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_get_objv, :g_variant_get_objv, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_dup_objv(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_dup_objv, :g_variant_dup_objv, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_get_bytestring(value)
  # @param [GVariant] value 
  # @return [String] 
  # @scope class
  attach_function :g_variant_get_bytestring, :g_variant_get_bytestring, [GVariant], :string
  
  # (Not documented)
  # 
  # @method g_variant_dup_bytestring(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [String] 
  # @scope class
  attach_function :g_variant_dup_bytestring, :g_variant_dup_bytestring, [GVariant, :pointer], :string
  
  # (Not documented)
  # 
  # @method g_variant_get_bytestring_array(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_get_bytestring_array, :g_variant_get_bytestring_array, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_dup_bytestring_array(value, length)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] length 
  # @return [FFI::Pointer(**Gchar)] 
  # @scope class
  attach_function :g_variant_dup_bytestring_array, :g_variant_dup_bytestring_array, [GVariant, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_new_maybe(child_type, child)
  # @param [GVariantType] child_type 
  # @param [GVariant] child 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_maybe, :g_variant_new_maybe, [GVariantType, GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_array(child_type, children, n_children)
  # @param [GVariantType] child_type 
  # @param [FFI::Pointer(**GVariant)] children 
  # @param [Integer] n_children 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_array, :g_variant_new_array, [GVariantType, :pointer, :uint], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_tuple(children, n_children)
  # @param [FFI::Pointer(**GVariant)] children 
  # @param [Integer] n_children 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_tuple, :g_variant_new_tuple, [:pointer, :uint], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_dict_entry(key, value)
  # @param [GVariant] key 
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_dict_entry, :g_variant_new_dict_entry, [GVariant, GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_maybe(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_get_maybe, :g_variant_get_maybe, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_n_children(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_n_children, :g_variant_n_children, [GVariant], :uint
  
  # (Not documented)
  # 
  # @method g_variant_get_child(value, index, format_string)
  # @param [GVariant] value 
  # @param [Integer] index 
  # @param [String] format_string 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_get_child, :g_variant_get_child, [GVariant, :uint, :string], :void
  
  # (Not documented)
  # 
  # @method g_variant_get_child_value(value, index)
  # @param [GVariant] value 
  # @param [Integer] index 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_get_child_value, :g_variant_get_child_value, [GVariant, :uint], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_lookup(dictionary, key, format_string)
  # @param [GVariant] dictionary 
  # @param [String] key 
  # @param [String] format_string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_lookup, :g_variant_lookup, [GVariant, :string, :string], :int
  
  # (Not documented)
  # 
  # @method g_variant_lookup_value(dictionary, key, expected_type)
  # @param [GVariant] dictionary 
  # @param [String] key 
  # @param [GVariantType] expected_type 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_lookup_value, :g_variant_lookup_value, [GVariant, :string, GVariantType], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_fixed_array(value, n_elements, element_size)
  # @param [GVariant] value 
  # @param [FFI::Pointer(*Gsize)] n_elements 
  # @param [Integer] element_size 
  # @return [FFI::Pointer(Gconstpointer)] 
  # @scope class
  attach_function :g_variant_get_fixed_array, :g_variant_get_fixed_array, [GVariant, :pointer, :uint], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_get_size(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_get_size, :g_variant_get_size, [GVariant], :uint
  
  # (Not documented)
  # 
  # @method g_variant_get_data(value)
  # @param [GVariant] value 
  # @return [FFI::Pointer(Gconstpointer)] 
  # @scope class
  attach_function :g_variant_get_data, :g_variant_get_data, [GVariant], :pointer
  
  # (Not documented)
  # 
  # @method g_variant_store(value, data)
  # @param [GVariant] value 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_store, :g_variant_store, [GVariant, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_variant_print(value, type_annotate)
  # @param [GVariant] value 
  # @param [Integer] type_annotate 
  # @return [String] 
  # @scope class
  attach_function :g_variant_print, :g_variant_print, [GVariant, :int], :string
  
  # (Not documented)
  # 
  # @method g_variant_print_string(value, string, type_annotate)
  # @param [GVariant] value 
  # @param [GString] string 
  # @param [Integer] type_annotate 
  # @return [GString] 
  # @scope class
  attach_function :g_variant_print_string, :g_variant_print_string, [GVariant, GString, :int], GString
  
  # (Not documented)
  # 
  # @method g_variant_hash(value)
  # @param [FFI::Pointer(Gconstpointer)] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_hash, :g_variant_hash, [:pointer], :uint
  
  # (Not documented)
  # 
  # @method g_variant_equal(one, two)
  # @param [FFI::Pointer(Gconstpointer)] one 
  # @param [FFI::Pointer(Gconstpointer)] two 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_equal, :g_variant_equal, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_variant_get_normal_form(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_get_normal_form, :g_variant_get_normal_form, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_is_normal_form(value)
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_is_normal_form, :g_variant_is_normal_form, [GVariant], :int
  
  # (Not documented)
  # 
  # @method g_variant_byteswap(value)
  # @param [GVariant] value 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_byteswap, :g_variant_byteswap, [GVariant], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_from_data(type, data, size, trusted, notify, user_data)
  # @param [GVariantType] type 
  # @param [FFI::Pointer(Gconstpointer)] data 
  # @param [Integer] size 
  # @param [Integer] trusted 
  # @param [FFI::Pointer(GDestroyNotify)] notify 
  # @param [FFI::Pointer(Gpointer)] user_data 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_from_data, :g_variant_new_from_data, [GVariantType, :pointer, :uint, :int, :pointer, :pointer], GVariant
  
  # (Not documented)
  # 
  # = Fields:
  # :x ::
  #   (Array<Integer>) < private >
  module GVariantIterWrappers
    # @param [GVariant] value 
    # @return [Integer] 
    def init(value)
      Glib.g_variant_iter_init(self, value)
    end
    
    # @return [GVariantIter] 
    def copy()
      GVariantIter.new Glib.g_variant_iter_copy(self)
    end
    
    # @return [Integer] 
    def n_children()
      Glib.g_variant_iter_n_children(self)
    end
    
    # @return [nil] 
    def free()
      Glib.g_variant_iter_free(self)
    end
    
    # @return [GVariant] 
    def next_value()
      GVariant.new Glib.g_variant_iter_next_value(self)
    end
    
    # @param [String] format_string 
    # @return [Integer] 
    def next_(format_string)
      Glib.g_variant_iter_next(self, format_string)
    end
    
    # @param [String] format_string 
    # @return [Integer] 
    def loop(format_string)
      Glib.g_variant_iter_loop(self, format_string)
    end
  end
  
  class GVariantIter < FFI::Struct
    include GVariantIterWrappers
    layout :x, [:uint, 16]
  end
  
  # (Not documented)
  # 
  # @method g_variant_iter_new(value)
  # @param [GVariant] value 
  # @return [GVariantIter] 
  # @scope class
  attach_function :g_variant_iter_new, :g_variant_iter_new, [GVariant], GVariantIter
  
  # (Not documented)
  # 
  # @method g_variant_iter_init(iter, value)
  # @param [GVariantIter] iter 
  # @param [GVariant] value 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_iter_init, :g_variant_iter_init, [GVariantIter, GVariant], :uint
  
  # (Not documented)
  # 
  # @method g_variant_iter_copy(iter)
  # @param [GVariantIter] iter 
  # @return [GVariantIter] 
  # @scope class
  attach_function :g_variant_iter_copy, :g_variant_iter_copy, [GVariantIter], GVariantIter
  
  # (Not documented)
  # 
  # @method g_variant_iter_n_children(iter)
  # @param [GVariantIter] iter 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_iter_n_children, :g_variant_iter_n_children, [GVariantIter], :uint
  
  # (Not documented)
  # 
  # @method g_variant_iter_free(iter)
  # @param [GVariantIter] iter 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_iter_free, :g_variant_iter_free, [GVariantIter], :void
  
  # (Not documented)
  # 
  # @method g_variant_iter_next_value(iter)
  # @param [GVariantIter] iter 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_iter_next_value, :g_variant_iter_next_value, [GVariantIter], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_iter_next(iter, format_string)
  # @param [GVariantIter] iter 
  # @param [String] format_string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_iter_next, :g_variant_iter_next, [GVariantIter, :string], :int
  
  # (Not documented)
  # 
  # @method g_variant_iter_loop(iter, format_string)
  # @param [GVariantIter] iter 
  # @param [String] format_string 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_iter_loop, :g_variant_iter_loop, [GVariantIter, :string], :int
  
  # (Not documented)
  # 
  # = Fields:
  # :x ::
  #   (Array<Integer>) < private >
  module GVariantBuilderWrappers
    # @return [nil] 
    def unref()
      Glib.g_variant_builder_unref(self)
    end
    
    # @return [GVariantBuilder] 
    def ref()
      GVariantBuilder.new Glib.g_variant_builder_ref(self)
    end
    
    # @param [GVariantType] type 
    # @return [nil] 
    def init(type)
      Glib.g_variant_builder_init(self, type)
    end
    
    # @return [GVariant] 
    def end_()
      GVariant.new Glib.g_variant_builder_end(self)
    end
    
    # @return [nil] 
    def clear()
      Glib.g_variant_builder_clear(self)
    end
    
    # @param [GVariantType] type 
    # @return [nil] 
    def open(type)
      Glib.g_variant_builder_open(self, type)
    end
    
    # @return [nil] 
    def close()
      Glib.g_variant_builder_close(self)
    end
    
    # @param [GVariant] value 
    # @return [nil] 
    def add_value(value)
      Glib.g_variant_builder_add_value(self, value)
    end
    
    # @param [String] format_string 
    # @return [nil] 
    def add(format_string)
      Glib.g_variant_builder_add(self, format_string)
    end
    
    # @param [String] format 
    # @return [nil] 
    def add_parsed(format)
      Glib.g_variant_builder_add_parsed(self, format)
    end
  end
  
  class GVariantBuilder < FFI::Struct
    include GVariantBuilderWrappers
    layout :x, [:uint, 16]
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_variant_parse_error).</em>
  # 
  # === Options:
  # :failed ::
  #   
  # :basic_type_expected ::
  #   
  # :cannot_infer_type ::
  #   
  # :definite_type_expected ::
  #   
  # :input_not_at_end ::
  #   
  # :invalid_character ::
  #   
  # :invalid_format_string ::
  #   
  # :invalid_object_path ::
  #   
  # :invalid_signature ::
  #   
  # :invalid_type_string ::
  #   
  # :no_common_type ::
  #   
  # :number_out_of_range ::
  #   
  # :number_too_big ::
  #   
  # :type_error ::
  #   
  # :unexpected_token ::
  #   
  # :unknown_keyword ::
  #   
  # :unterminated_string_constant ::
  #   
  # :value_expected ::
  #   
  # 
  # @method _enum_g_variant_parse_error_
  # @return [Symbol]
  # @scope class
  enum :g_variant_parse_error, [
    :failed, 0,
    :basic_type_expected, 1,
    :cannot_infer_type, 2,
    :definite_type_expected, 3,
    :input_not_at_end, 4,
    :invalid_character, 5,
    :invalid_format_string, 6,
    :invalid_object_path, 7,
    :invalid_signature, 8,
    :invalid_type_string, 9,
    :no_common_type, 10,
    :number_out_of_range, 11,
    :number_too_big, 12,
    :type_error, 13,
    :unexpected_token, 14,
    :unknown_keyword, 15,
    :unterminated_string_constant, 16,
    :value_expected, 17
  ]
  
  # (Not documented)
  # 
  # @method g_variant_parser_get_error_quark()
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_parser_get_error_quark, :g_variant_parser_get_error_quark, [], :uint
  
  # (Not documented)
  # 
  # @method g_variant_builder_new(type)
  # @param [GVariantType] type 
  # @return [GVariantBuilder] 
  # @scope class
  attach_function :g_variant_builder_new, :g_variant_builder_new, [GVariantType], GVariantBuilder
  
  # (Not documented)
  # 
  # @method g_variant_builder_unref(builder)
  # @param [GVariantBuilder] builder 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_unref, :g_variant_builder_unref, [GVariantBuilder], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_ref(builder)
  # @param [GVariantBuilder] builder 
  # @return [GVariantBuilder] 
  # @scope class
  attach_function :g_variant_builder_ref, :g_variant_builder_ref, [GVariantBuilder], GVariantBuilder
  
  # (Not documented)
  # 
  # @method g_variant_builder_init(builder, type)
  # @param [GVariantBuilder] builder 
  # @param [GVariantType] type 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_init, :g_variant_builder_init, [GVariantBuilder, GVariantType], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_end(builder)
  # @param [GVariantBuilder] builder 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_builder_end, :g_variant_builder_end, [GVariantBuilder], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_builder_clear(builder)
  # @param [GVariantBuilder] builder 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_clear, :g_variant_builder_clear, [GVariantBuilder], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_open(builder, type)
  # @param [GVariantBuilder] builder 
  # @param [GVariantType] type 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_open, :g_variant_builder_open, [GVariantBuilder, GVariantType], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_close(builder)
  # @param [GVariantBuilder] builder 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_close, :g_variant_builder_close, [GVariantBuilder], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_add_value(builder, value)
  # @param [GVariantBuilder] builder 
  # @param [GVariant] value 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_add_value, :g_variant_builder_add_value, [GVariantBuilder, GVariant], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_add(builder, format_string)
  # @param [GVariantBuilder] builder 
  # @param [String] format_string 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_add, :g_variant_builder_add, [GVariantBuilder, :string], :void
  
  # (Not documented)
  # 
  # @method g_variant_builder_add_parsed(builder, format)
  # @param [GVariantBuilder] builder 
  # @param [String] format 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_builder_add_parsed, :g_variant_builder_add_parsed, [GVariantBuilder, :string], :void
  
  # (Not documented)
  # 
  # @method g_variant_new(format_string)
  # @param [String] format_string 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new, :g_variant_new, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get(value, format_string)
  # @param [GVariant] value 
  # @param [String] format_string 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_get, :g_variant_get, [GVariant, :string], :void
  
  # (Not documented)
  # 
  # @method g_variant_new_va(format_string, endptr, app)
  # @param [String] format_string 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @param [FFI::Pointer(*VaList)] app 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_va, :g_variant_new_va, [:string, :pointer, :pointer], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_get_va(value, format_string, endptr, app)
  # @param [GVariant] value 
  # @param [String] format_string 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @param [FFI::Pointer(*VaList)] app 
  # @return [nil] 
  # @scope class
  attach_function :g_variant_get_va, :g_variant_get_va, [GVariant, :string, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method g_variant_check_format_string(value, format_string, copy_only)
  # @param [GVariant] value 
  # @param [String] format_string 
  # @param [Integer] copy_only 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_check_format_string, :g_variant_check_format_string, [GVariant, :string, :int], :int
  
  # (Not documented)
  # 
  # @method g_variant_parse(type, text, limit, endptr, error)
  # @param [GVariantType] type 
  # @param [String] text 
  # @param [String] limit 
  # @param [FFI::Pointer(**Gchar)] endptr 
  # @param [FFI::Pointer(**GError)] error 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_parse, :g_variant_parse, [GVariantType, :string, :string, :pointer, :pointer], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_parsed(format)
  # @param [String] format 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_parsed, :g_variant_new_parsed, [:string], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_new_parsed_va(format, app)
  # @param [String] format 
  # @param [FFI::Pointer(*VaList)] app 
  # @return [GVariant] 
  # @scope class
  attach_function :g_variant_new_parsed_va, :g_variant_new_parsed_va, [:string, :pointer], GVariant
  
  # (Not documented)
  # 
  # @method g_variant_compare(one, two)
  # @param [FFI::Pointer(Gconstpointer)] one 
  # @param [FFI::Pointer(Gconstpointer)] two 
  # @return [Integer] 
  # @scope class
  attach_function :g_variant_compare, :g_variant_compare, [:pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method glib_check_version(required_major, required_minor, required_micro)
  # @param [Integer] required_major 
  # @param [Integer] required_minor 
  # @param [Integer] required_micro 
  # @return [String] 
  # @scope class
  attach_function :glib_check_version, :glib_check_version, [:uint, :uint, :uint], :string
  
  # (Not documented)
  # 
  # @method g_win32_ftruncate(f, size)
  # @param [Integer] f 
  # @param [Integer] size 
  # @return [Integer] 
  # @scope class
  attach_function :g_win32_ftruncate, :g_win32_ftruncate, [:int, :uint], :int
  
  # (Not documented)
  # 
  # @method g_win32_getlocale()
  # @return [String] 
  # @scope class
  attach_function :g_win32_getlocale, :g_win32_getlocale, [], :string
  
  # (Not documented)
  # 
  # @method g_win32_error_message(error)
  # @param [Integer] error 
  # @return [String] 
  # @scope class
  attach_function :g_win32_error_message, :g_win32_error_message, [:int], :string
  
  # (Not documented)
  # 
  # @method g_win32_get_package_installation_directory(package, dll_name)
  # @param [String] package 
  # @param [String] dll_name 
  # @return [String] 
  # @scope class
  attach_function :g_win32_get_package_installation_directory, :g_win32_get_package_installation_directory, [:string, :string], :string
  
  # (Not documented)
  # 
  # @method g_win32_get_package_installation_subdirectory(package, dll_name, subdir)
  # @param [String] package 
  # @param [String] dll_name 
  # @param [String] subdir 
  # @return [String] 
  # @scope class
  attach_function :g_win32_get_package_installation_subdirectory, :g_win32_get_package_installation_subdirectory, [:string, :string, :string], :string
  
  # (Not documented)
  # 
  # @method g_win32_get_package_installation_directory_of_module(hmodule)
  # @param [FFI::Pointer(Gpointer)] hmodule 
  # @return [String] 
  # @scope class
  attach_function :g_win32_get_package_installation_directory_of_module, :g_win32_get_package_installation_directory_of_module, [:pointer], :string
  
  # (Not documented)
  # 
  # @method g_win32_get_windows_version()
  # @return [Integer] 
  # @scope class
  attach_function :g_win32_get_windows_version, :g_win32_get_windows_version, [], :uint
  
  # (Not documented)
  # 
  # @method g_win32_locale_filename_from_utf8(utf8filename)
  # @param [String] utf8filename 
  # @return [String] 
  # @scope class
  attach_function :g_win32_locale_filename_from_utf8, :g_win32_locale_filename_from_utf8, [:string], :string
  
  # (Not documented)
  # 
  # @method g_printf(format)
  # @param [String] format 
  # @return [Integer] 
  # @scope class
  attach_function :g_printf, :g_printf, [:string], :int
  
  # (Not documented)
  # 
  # @method g_fprintf(file, format)
  # @param [FFI::Pointer(*FILE)] file 
  # @param [String] format 
  # @return [Integer] 
  # @scope class
  attach_function :g_fprintf, :g_fprintf, [:pointer, :string], :int
  
  # (Not documented)
  # 
  # @method g_sprintf(string, format)
  # @param [String] string 
  # @param [String] format 
  # @return [Integer] 
  # @scope class
  attach_function :g_sprintf, :g_sprintf, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_vprintf(format, args)
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_vprintf, :g_vprintf, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_vfprintf(file, format, args)
  # @param [FFI::Pointer(*FILE)] file 
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_vfprintf, :g_vfprintf, [:pointer, :string, :string], :int
  
  # (Not documented)
  # 
  # @method g_vsprintf(string, format, args)
  # @param [String] string 
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_vsprintf, :g_vsprintf, [:string, :string, :string], :int
  
  # (Not documented)
  # 
  # @method g_vasprintf(string, format, args)
  # @param [FFI::Pointer(**Gchar)] string 
  # @param [String] format 
  # @param [String] args 
  # @return [Integer] 
  # @scope class
  attach_function :g_vasprintf, :g_vasprintf, [:pointer, :string, :string], :int
  
  # Wrappers for C library functions that take pathname arguments. On
  # Unix, the pathname is a file name as it literally is in the file
  # system. On well-maintained systems with consistent users who know
  # what they are doing and no exchange of files with others this would
  # be a well-defined encoding, preferably UTF-8. On Windows, the
  # pathname is always in UTF-8, even if that is not the on-disk
  # encoding, and not the encoding accepted by the C library or Win32
  # API.
  # 
  # @method g_access(filename, mode)
  # @param [String] filename 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_access, :g_access, [:string, :int], :int
  
  # (Not documented)
  # 
  # @method g_chmod(filename, mode)
  # @param [String] filename 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_chmod, :g_chmod, [:string, :int], :int
  
  # (Not documented)
  # 
  # @method g_open(filename, flags, mode)
  # @param [String] filename 
  # @param [Integer] flags 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_open, :g_open, [:string, :int, :int], :int
  
  # (Not documented)
  # 
  # @method g_creat(filename, mode)
  # @param [String] filename 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_creat, :g_creat, [:string, :int], :int
  
  # (Not documented)
  # 
  # @method g_rename(oldfilename, newfilename)
  # @param [String] oldfilename 
  # @param [String] newfilename 
  # @return [Integer] 
  # @scope class
  attach_function :g_rename, :g_rename, [:string, :string], :int
  
  # (Not documented)
  # 
  # @method g_mkdir(filename, mode)
  # @param [String] filename 
  # @param [Integer] mode 
  # @return [Integer] 
  # @scope class
  attach_function :g_mkdir, :g_mkdir, [:string, :int], :int
  
  # (Not documented)
  # 
  # @method g_chdir(path)
  # @param [String] path 
  # @return [Integer] 
  # @scope class
  attach_function :g_chdir, :g_chdir, [:string], :int
  
  # (Not documented)
  # 
  # @method g_stat(filename, buf)
  # @param [String] filename 
  # @param [FFI::Pointer(*GStatBuf)] buf 
  # @return [Integer] 
  # @scope class
  attach_function :g_stat, :g_stat, [:string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_lstat(filename, buf)
  # @param [String] filename 
  # @param [FFI::Pointer(*GStatBuf)] buf 
  # @return [Integer] 
  # @scope class
  attach_function :g_lstat, :g_lstat, [:string, :pointer], :int
  
  # (Not documented)
  # 
  # @method g_unlink(filename)
  # @param [String] filename 
  # @return [Integer] 
  # @scope class
  attach_function :g_unlink, :g_unlink, [:string], :int
  
  # (Not documented)
  # 
  # @method g_remove(filename)
  # @param [String] filename 
  # @return [Integer] 
  # @scope class
  attach_function :g_remove, :g_remove, [:string], :int
  
  # (Not documented)
  # 
  # @method g_rmdir(filename)
  # @param [String] filename 
  # @return [Integer] 
  # @scope class
  attach_function :g_rmdir, :g_rmdir, [:string], :int
  
  # (Not documented)
  # 
  # @method g_fopen(filename, mode)
  # @param [String] filename 
  # @param [String] mode 
  # @return [FFI::Pointer(*FILE)] 
  # @scope class
  attach_function :g_fopen, :g_fopen, [:string, :string], :pointer
  
  # (Not documented)
  # 
  # @method g_freopen(filename, mode, stream)
  # @param [String] filename 
  # @param [String] mode 
  # @param [FFI::Pointer(*FILE)] stream 
  # @return [FFI::Pointer(*FILE)] 
  # @scope class
  attach_function :g_freopen, :g_freopen, [:string, :string, :pointer], :pointer
  
  # (Not documented)
  class Utimbuf < FFI::Struct
    layout :dummy, :char
  end
  
  # Don't need the real definition of struct utimbuf when just
  # including this header.
  # 
  # @method g_utime(filename, utb)
  # @param [String] filename 
  # @param [Utimbuf] utb 
  # @return [Integer] 
  # @scope class
  attach_function :g_utime, :g_utime, [:string, Utimbuf], :int
  
end
