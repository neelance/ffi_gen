# Generated by ffi-gen. Please do not change this file by hand.

require 'ffi'

module LibSSH2
  extend FFI::Library
  ffi_lib 'libssh2'
  
  def self.attach_function(name, *_)
    begin; super; rescue FFI::NotFoundError => e
      (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
    end
  end
  
  H = 1
  
  COPYRIGHT = "2004-2010 The libssh2 project and its contributors."
  
  VERSION = "1.2.8"
  
  VERSION_MAJOR = 1
  
  VERSION_MINOR = 2
  
  VERSION_PATCH = 8
  
  VERSION_NUM = 0x010208
  
  TIMESTAMP = "Tue Apr  5 17:15:42 UTC 2011"
  
  INVALID_SOCKET = -1
  
  SSH_BANNER = "SSH-2.0-libssh2_"LIBSSH2_VERSION
  
  SSH_DEFAULT_BANNER = LIBSSH2_SSH_BANNER
  
  SSH_DEFAULT_BANNER_WITH_CRLF = LIBSSH2_SSH_DEFAULT_BANNER"\r\n"
  
  DH_GEX_MINGROUP = 1024
  
  DH_GEX_OPTGROUP = 1536
  
  DH_GEX_MAXGROUP = 2048
  
  TERM_WIDTH = 80
  
  TERM_HEIGHT = 24
  
  TERM_WIDTH_PX = 0
  
  TERM_HEIGHT_PX = 0
  
  SOCKET_POLL_UDELAY = 250000
  
  SOCKET_POLL_MAXLOOPS = 120
  
  PACKET_MAXCOMP = 32000
  
  PACKET_MAXDECOMP = 40000
  
  PACKET_MAXPAYLOAD = 40000
  
  CALLBACK_IGNORE = 0
  
  CALLBACK_DEBUG = 1
  
  CALLBACK_DISCONNECT = 2
  
  CALLBACK_MACERROR = 3
  
  CALLBACK_X11 = 4
  
  METHOD_KEX = 0
  
  METHOD_HOSTKEY = 1
  
  METHOD_CRYPT_CS = 2
  
  METHOD_CRYPT_SC = 3
  
  METHOD_MAC_CS = 4
  
  METHOD_MAC_SC = 5
  
  METHOD_COMP_CS = 6
  
  METHOD_COMP_SC = 7
  
  METHOD_LANG_CS = 8
  
  METHOD_LANG_SC = 9
  
  FLAG_SIGPIPE = 1
  
  FLAG_COMPRESS = 2
  
  POLLFD_SOCKET = 1
  
  POLLFD_CHANNEL = 2
  
  POLLFD_LISTENER = 3
  
  POLLFD_POLLIN = 0x0001
  
  POLLFD_POLLPRI = 0x0002
  
  POLLFD_POLLEXT = 0x0002
  
  POLLFD_POLLOUT = 0x0004
  
  POLLFD_POLLERR = 0x0008
  
  POLLFD_POLLHUP = 0x0010
  
  POLLFD_SESSION_CLOSED = 0x0010
  
  POLLFD_POLLNVAL = 0x0020
  
  POLLFD_POLLEX = 0x0040
  
  POLLFD_CHANNEL_CLOSED = 0x0080
  
  POLLFD_LISTENER_CLOSED = 0x0080
  
  SESSION_BLOCK_INBOUND = 0x0001
  
  SESSION_BLOCK_OUTBOUND = 0x0002
  
  HOSTKEY_HASH_MD5 = 1
  
  HOSTKEY_HASH_SHA1 = 2
  
  HOSTKEY_TYPE_UNKNOWN = 0
  
  HOSTKEY_TYPE_RSA = 1
  
  HOSTKEY_TYPE_DSS = 2
  
  SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT = 1
  
  SSH_DISCONNECT_PROTOCOL_ERROR = 2
  
  SSH_DISCONNECT_KEY_EXCHANGE_FAILED = 3
  
  SSH_DISCONNECT_RESERVED = 4
  
  SSH_DISCONNECT_MAC_ERROR = 5
  
  SSH_DISCONNECT_COMPRESSION_ERROR = 6
  
  SSH_DISCONNECT_SERVICE_NOT_AVAILABLE = 7
  
  SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED = 8
  
  SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE = 9
  
  SSH_DISCONNECT_CONNECTION_LOST = 10
  
  SSH_DISCONNECT_BY_APPLICATION = 11
  
  SSH_DISCONNECT_TOO_MANY_CONNECTIONS = 12
  
  SSH_DISCONNECT_AUTH_CANCELLED_BY_USER = 13
  
  SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE = 14
  
  SSH_DISCONNECT_ILLEGAL_USER_NAME = 15
  
  ERROR_NONE = 0
  
  ERROR_SOCKET_NONE = -1
  
  ERROR_BANNER_RECV = -2
  
  ERROR_BANNER_SEND = -3
  
  ERROR_INVALID_MAC = -4
  
  ERROR_KEX_FAILURE = -5
  
  ERROR_ALLOC = -6
  
  ERROR_SOCKET_SEND = -7
  
  ERROR_KEY_EXCHANGE_FAILURE = -8
  
  ERROR_TIMEOUT = -9
  
  ERROR_HOSTKEY_INIT = -10
  
  ERROR_HOSTKEY_SIGN = -11
  
  ERROR_DECRYPT = -12
  
  ERROR_SOCKET_DISCONNECT = -13
  
  ERROR_PROTO = -14
  
  ERROR_PASSWORD_EXPIRED = -15
  
  ERROR_FILE = -16
  
  ERROR_METHOD_NONE = -17
  
  ERROR_AUTHENTICATION_FAILED = -18
  
  ERROR_PUBLICKEY_UNRECOGNIZED = LIBSSH2_ERROR_AUTHENTICATION_FAILED
  
  ERROR_PUBLICKEY_UNVERIFIED = -19
  
  ERROR_CHANNEL_OUTOFORDER = -20
  
  ERROR_CHANNEL_FAILURE = -21
  
  ERROR_CHANNEL_REQUEST_DENIED = -22
  
  ERROR_CHANNEL_UNKNOWN = -23
  
  ERROR_CHANNEL_WINDOW_EXCEEDED = -24
  
  ERROR_CHANNEL_PACKET_EXCEEDED = -25
  
  ERROR_CHANNEL_CLOSED = -26
  
  ERROR_CHANNEL_EOF_SENT = -27
  
  ERROR_SCP_PROTOCOL = -28
  
  ERROR_ZLIB = -29
  
  ERROR_SOCKET_TIMEOUT = -30
  
  ERROR_SFTP_PROTOCOL = -31
  
  ERROR_REQUEST_DENIED = -32
  
  ERROR_METHOD_NOT_SUPPORTED = -33
  
  ERROR_INVAL = -34
  
  ERROR_INVALID_POLL_TYPE = -35
  
  ERROR_PUBLICKEY_PROTOCOL = -36
  
  ERROR_EAGAIN = -37
  
  ERROR_BUFFER_TOO_SMALL = -38
  
  ERROR_BAD_USE = -39
  
  ERROR_COMPRESS = -40
  
  ERROR_OUT_OF_BOUNDARY = -41
  
  ERROR_AGENT_PROTOCOL = -42
  
  ERROR_SOCKET_RECV = -43
  
  ERROR_ENCRYPT = -44
  
  ERROR_BAD_SOCKET = -45
  
  ERROR_BANNER_NONE = LIBSSH2_ERROR_BANNER_RECV
  
  INIT_NO_CRYPTO = 0x0001
  
  def session_init()
    session_init_ex(nil, nil, nil, nil)
  end
  
  def session_disconnect(session, description)
    session_disconnect_ex(session, SSH_DISCONNECT_BY_APPLICATION, description, "")
  end
  
  def userauth_password(session, username, password)
    userauth_password_ex(session, username, username.length, password, password.length, nil)
  end
  
  def userauth_publickey_fromfile(session, username, publickey, privatekey, passphrase)
    userauth_publickey_fromfile_ex(session, username, username.length, publickey, privatekey, passphrase)
  end
  
  def userauth_hostbased_fromfile(session, username, publickey, privatekey, passphrase, hostname)
    userauth_hostbased_fromfile_ex(session, username, username.length, publickey, privatekey, passphrase, hostname, hostname.length, username, username.length)
  end
  
  def userauth_keyboard_interactive(session, username, response_callback)
    userauth_keyboard_interactive_ex(session, username, username.length, response_callback)
  end
  
  CHANNEL_WINDOW_DEFAULT = 65536
  
  CHANNEL_PACKET_DEFAULT = 32768
  
  CHANNEL_MINADJUST = 1024
  
  CHANNEL_EXTENDED_DATA_NORMAL = 0
  
  CHANNEL_EXTENDED_DATA_IGNORE = 1
  
  CHANNEL_EXTENDED_DATA_MERGE = 2
  
  SSH_EXTENDED_DATA_STDERR = 1
  
  CHANNEL_EAGAIN = LIBSSH2_ERROR_EAGAIN
  def channel_open_session(session)
    channel_open_ex(session, "session", "session".length-1, CHANNEL_WINDOW_DEFAULT, CHANNEL_PACKET_DEFAULT, nil, 0)
  end
  
  def channel_direct_tcpip(session, host, port)
    channel_direct_tcpip_ex(session, host, port, "127.0.0.1", 22)
  end
  
  def channel_forward_listen(session, port)
    channel_forward_listen_ex(session, nil, port, nil, 16)
  end
  
  def channel_setenv(channel, varname, value)
    channel_setenv_ex(channel, varname, varname.length, value, value.length)
  end
  
  def channel_request_pty(channel, term)
    channel_request_pty_ex(channel, term, term.length, nil, 0, TERM_WIDTH, TERM_HEIGHT, TERM_WIDTH_PX, TERM_HEIGHT_PX)
  end
  
  def channel_request_pty_size(channel, width, height)
    channel_request_pty_size_ex(channel, width, height, 0, 0)
  end
  
  def channel_x11_req(channel, screen_number)
    channel_x11_req_ex(channel, 0, nil, nil, screen_number)
  end
  
  def channel_shell(channel)
    channel_process_startup(channel, "shell", "shell".length-1, nil, 0)
  end
  
  def channel_exec(channel, command)
    channel_process_startup(channel, "exec", "exec".length-1, command, command.length)
  end
  
  def channel_subsystem(channel, subsystem)
    channel_process_startup(channel, "subsystem", "subsystem".length-1, subsystem, subsystem.length)
  end
  
  def channel_read(channel, buf, buflen)
    channel_read_ex(channel, 0, buf, buflen)
  end
  
  def channel_read_stderr(channel, buf, buflen)
    channel_read_ex(channel, SSH_EXTENDED_DATA_STDERR, buf, buflen)
  end
  
  def channel_window_read(channel)
    channel_window_read_ex(channel, nil, nil)
  end
  
  def channel_write(channel, buf, buflen)
    channel_write_ex(channel, 0, buf, buflen)
  end
  
  def channel_write_stderr(channel, buf, buflen)
    channel_write_ex(channel, SSH_EXTENDED_DATA_STDERR, buf, buflen)
  end
  
  def channel_window_write(channel)
    channel_window_write_ex(channel, nil)
  end
  
  CHANNEL_FLUSH_EXTENDED_DATA = -1
  
  CHANNEL_FLUSH_ALL = -2
  
  def channel_flush(channel)
    channel_flush_ex(channel, 0)
  end
  
  def channel_flush_stderr(channel)
    channel_flush_ex(channel, SSH_EXTENDED_DATA_STDERR)
  end
  
  def scp_send(session, path, mode, size)
    scp_send_ex(session, path, mode, size, 0, 0)
  end
  
  HAVE_LIBSSH2_KNOWNHOST_API = 0x010101
  
  HAVE_LIBSSH2_VERSION_API = 0x010100
  
  KNOWNHOST_TYPE_MASK = 0xffff
  
  KNOWNHOST_TYPE_PLAIN = 1
  
  KNOWNHOST_TYPE_SHA1 = 2
  
  KNOWNHOST_TYPE_CUSTOM = 3
  
  KNOWNHOST_KEYENC_MASK = (3<<16)
  
  KNOWNHOST_KEYENC_RAW = (1<<16)
  
  KNOWNHOST_KEYENC_BASE64 = (2<<16)
  
  KNOWNHOST_KEY_MASK = (3<<18)
  
  KNOWNHOST_KEY_SHIFT = 18
  
  KNOWNHOST_KEY_RSA1 = (1<<18)
  
  KNOWNHOST_KEY_SSHRSA = (2<<18)
  
  KNOWNHOST_KEY_SSHDSS = (3<<18)
  
  KNOWNHOST_CHECK_MATCH = 0
  
  KNOWNHOST_CHECK_MISMATCH = 1
  
  KNOWNHOST_CHECK_NOTFOUND = 2
  
  KNOWNHOST_CHECK_FAILURE = 3
  
  KNOWNHOST_FILE_OPENSSH = 1
  
  HAVE_LIBSSH2_AGENT_API = 0x010202
  
  TRACE_TRANS = (1<<1)
  
  TRACE_KEX = (1<<2)
  
  TRACE_AUTH = (1<<3)
  
  TRACE_CONN = (1<<4)
  
  TRACE_SCP = (1<<5)
  
  TRACE_SFTP = (1<<6)
  
  TRACE_ERROR = (1<<7)
  
  TRACE_PUBLICKEY = (1<<8)
  
  TRACE_SOCKET = (1<<9)
  
  # Malloc callbacks
  # 
  # = Fields:
  # :text ::
  #   (String) 
  # :length ::
  #   (Integer) 
  # :echo ::
  #   (Integer) 
  class LIBSSH2USERAUTHKBDINTPROMPT < FFI::Struct
    layout :text, :string,
           :length, :uint,
           :echo, :uchar
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :text ::
  #   (String) 
  # :length ::
  #   (Integer) 
  class LIBSSH2USERAUTHKBDINTRESPONSE < FFI::Struct
    layout :text, :string,
           :length, :uint
  end
  
  # flags
  class LIBSSH2SESSION < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  class LIBSSH2CHANNEL < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  class LIBSSH2LISTENER < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  class LIBSSH2KNOWNHOSTS < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  class LIBSSH2AGENT < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :socket ::
  #   (Integer) File descriptors -- examined with system select() call
  # :channel ::
  #   (LIBSSH2CHANNEL) Examined by checking internal state
  # :listener ::
  #   (LIBSSH2LISTENER) Read polls only -- are inbound
  #                                          connections waiting to be accepted?
  class LIBSSH2POLLFDFd < FFI::Union
    layout :socket, :int,
           :channel, LIBSSH2CHANNEL,
           :listener, LIBSSH2LISTENER
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :type ::
  #   (Integer) LIBSSH2_POLLFD_* below
  # :fd ::
  #   (LIBSSH2POLLFDFd) 
  # :events ::
  #   (Integer) Requested Events
  # :revents ::
  #   (Integer) Returned Events
  class LIBSSH2POLLFD < FFI::Struct
    layout :type, :uchar,
           :fd, LIBSSH2POLLFDFd.by_value,
           :events, :ulong,
           :revents, :ulong
  end
  
  # libssh2_init()
  # 
  # Initialize the libssh2 functions.  This typically initialize the
  # crypto library.  It uses a global state, and is not thread safe --
  # you must make sure this function is not called concurrently.
  # 
  # Flags can be:
  # 0:                              Normal initialize
  # LIBSSH2_INIT_NO_CRYPTO:         Do not initialize the crypto library (ie.
  #                                 OPENSSL_add_cipher_algoritms() for OpenSSL
  # 
  # Returns 0 if succeeded, or a negative value for error.
  # 
  # @method init(flags)
  # @param [Integer] flags 
  # @return [Integer] 
  # @scope class
  attach_function :init, :libssh2_init, [:int], :int
  
  # libssh2_exit()
  # 
  # Exit the libssh2 functions and free's all memory used internal.
  # 
  # @method exit()
  # @return [nil] 
  # @scope class
  attach_function :exit, :libssh2_exit, [], :void
  
  # libssh2_free()
  # 
  # Deallocate memory allocated by earlier call to libssh2 functions.
  # 
  # @method free(session, ptr)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(*Void)] ptr 
  # @return [nil] 
  # @scope class
  attach_function :free, :libssh2_free, [LIBSSH2SESSION, :pointer], :void
  
  # Session API
  # 
  # @method session_init_ex(my_alloc, my_free, my_realloc, abstract)
  # @param [FFI::Pointer(*)] my_alloc 
  # @param [FFI::Pointer(*)] my_free 
  # @param [FFI::Pointer(*)] my_realloc 
  # @param [FFI::Pointer(*Void)] abstract 
  # @return [LIBSSH2SESSION] 
  # @scope class
  attach_function :session_init_ex, :libssh2_session_init_ex, [:pointer, :pointer, :pointer, :pointer], LIBSSH2SESSION
  
  # (Not documented)
  # 
  # @method session_abstract(session)
  # @param [LIBSSH2SESSION] session 
  # @return [FFI::Pointer(**Void)] 
  # @scope class
  attach_function :session_abstract, :libssh2_session_abstract, [LIBSSH2SESSION], :pointer
  
  # (Not documented)
  # 
  # @method session_callback_set(session, cbtype, callback)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] cbtype 
  # @param [FFI::Pointer(*Void)] callback 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :session_callback_set, :libssh2_session_callback_set, [LIBSSH2SESSION, :int, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method banner_set(session, banner)
  # @param [LIBSSH2SESSION] session 
  # @param [String] banner 
  # @return [Integer] 
  # @scope class
  attach_function :banner_set, :libssh2_banner_set, [LIBSSH2SESSION, :string], :int
  
  # (Not documented)
  # 
  # @method session_startup(session, sock)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] sock 
  # @return [Integer] 
  # @scope class
  attach_function :session_startup, :libssh2_session_startup, [LIBSSH2SESSION, :int], :int
  
  # (Not documented)
  # 
  # @method session_handshake(session, sock)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] sock 
  # @return [Integer] 
  # @scope class
  attach_function :session_handshake, :libssh2_session_handshake, [LIBSSH2SESSION, :int], :int
  
  # (Not documented)
  # 
  # @method session_disconnect_ex(session, reason, description, lang)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] reason 
  # @param [String] description 
  # @param [String] lang 
  # @return [Integer] 
  # @scope class
  attach_function :session_disconnect_ex, :libssh2_session_disconnect_ex, [LIBSSH2SESSION, :int, :string, :string], :int
  
  # (Not documented)
  # 
  # @method session_free(session)
  # @param [LIBSSH2SESSION] session 
  # @return [Integer] 
  # @scope class
  attach_function :session_free, :libssh2_session_free, [LIBSSH2SESSION], :int
  
  # (Not documented)
  # 
  # @method hostkey_hash(session, hash_type)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] hash_type 
  # @return [String] 
  # @scope class
  attach_function :hostkey_hash, :libssh2_hostkey_hash, [LIBSSH2SESSION, :int], :string
  
  # (Not documented)
  # 
  # @method session_hostkey(session, len, type)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(*SizeT)] len 
  # @param [FFI::Pointer(*Int)] type 
  # @return [String] 
  # @scope class
  attach_function :session_hostkey, :libssh2_session_hostkey, [LIBSSH2SESSION, :pointer, :pointer], :string
  
  # (Not documented)
  # 
  # @method session_method_pref(session, method_type, prefs)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] method_type 
  # @param [String] prefs 
  # @return [Integer] 
  # @scope class
  attach_function :session_method_pref, :libssh2_session_method_pref, [LIBSSH2SESSION, :int, :string], :int
  
  # (Not documented)
  # 
  # @method session_methods(session, method_type)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] method_type 
  # @return [String] 
  # @scope class
  attach_function :session_methods, :libssh2_session_methods, [LIBSSH2SESSION, :int], :string
  
  # (Not documented)
  # 
  # @method session_last_error(session, errmsg, errmsg_len, want_buf)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(**CharS)] errmsg 
  # @param [FFI::Pointer(*Int)] errmsg_len 
  # @param [Integer] want_buf 
  # @return [Integer] 
  # @scope class
  attach_function :session_last_error, :libssh2_session_last_error, [LIBSSH2SESSION, :pointer, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method session_last_errno(session)
  # @param [LIBSSH2SESSION] session 
  # @return [Integer] 
  # @scope class
  attach_function :session_last_errno, :libssh2_session_last_errno, [LIBSSH2SESSION], :int
  
  # (Not documented)
  # 
  # @method session_block_directions(session)
  # @param [LIBSSH2SESSION] session 
  # @return [Integer] 
  # @scope class
  attach_function :session_block_directions, :libssh2_session_block_directions, [LIBSSH2SESSION], :int
  
  # (Not documented)
  # 
  # @method session_flag(session, flag, value)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] flag 
  # @param [Integer] value 
  # @return [Integer] 
  # @scope class
  attach_function :session_flag, :libssh2_session_flag, [LIBSSH2SESSION, :int, :int], :int
  
  # Userauth API
  # 
  # @method userauth_list(session, username, username_len)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [Integer] username_len 
  # @return [String] 
  # @scope class
  attach_function :userauth_list, :libssh2_userauth_list, [LIBSSH2SESSION, :string, :uint], :string
  
  # (Not documented)
  # 
  # @method userauth_authenticated(session)
  # @param [LIBSSH2SESSION] session 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_authenticated, :libssh2_userauth_authenticated, [LIBSSH2SESSION], :int
  
  # (Not documented)
  # 
  # @method userauth_password_ex(session, username, username_len, password, password_len, passwd_change_cb)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [Integer] username_len 
  # @param [String] password 
  # @param [Integer] password_len 
  # @param [FFI::Pointer(*)] passwd_change_cb 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_password_ex, :libssh2_userauth_password_ex, [LIBSSH2SESSION, :string, :uint, :string, :uint, :pointer], :int
  
  # (Not documented)
  # 
  # @method userauth_publickey_fromfile_ex(session, username, username_len, publickey, privatekey, passphrase)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [Integer] username_len 
  # @param [String] publickey 
  # @param [String] privatekey 
  # @param [String] passphrase 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_publickey_fromfile_ex, :libssh2_userauth_publickey_fromfile_ex, [LIBSSH2SESSION, :string, :uint, :string, :string, :string], :int
  
  # (Not documented)
  # 
  # @method userauth_publickey(session, username, pubkeydata, pubkeydata_len, sign_callback, abstract)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [FFI::Pointer(*UChar)] pubkeydata 
  # @param [Integer] pubkeydata_len 
  # @param [FFI::Pointer(*)] sign_callback 
  # @param [FFI::Pointer(**Void)] abstract 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_publickey, :libssh2_userauth_publickey, [LIBSSH2SESSION, :string, :pointer, :ulong, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method userauth_hostbased_fromfile_ex(session, username, username_len, publickey, privatekey, passphrase, hostname, hostname_len, local_username, local_username_len)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [Integer] username_len 
  # @param [String] publickey 
  # @param [String] privatekey 
  # @param [String] passphrase 
  # @param [String] hostname 
  # @param [Integer] hostname_len 
  # @param [String] local_username 
  # @param [Integer] local_username_len 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_hostbased_fromfile_ex, :libssh2_userauth_hostbased_fromfile_ex, [LIBSSH2SESSION, :string, :uint, :string, :string, :string, :string, :uint, :string, :uint], :int
  
  # response_callback is provided with filled by library prompts array,
  # but client must allocate and fill individual responses. Responses
  # array is already allocated. Responses data will be freed by libssh2
  # after callback return, but before subsequent callback invokation.
  # 
  # @method userauth_keyboard_interactive_ex(session, username, username_len, response_callback)
  # @param [LIBSSH2SESSION] session 
  # @param [String] username 
  # @param [Integer] username_len 
  # @param [FFI::Pointer(*)] response_callback 
  # @return [Integer] 
  # @scope class
  attach_function :userauth_keyboard_interactive_ex, :libssh2_userauth_keyboard_interactive_ex, [LIBSSH2SESSION, :string, :uint, :pointer], :int
  
  # (Not documented)
  # 
  # @method poll(fds, nfds, timeout)
  # @param [LIBSSH2POLLFD] fds 
  # @param [Integer] nfds 
  # @param [Integer] timeout 
  # @return [Integer] 
  # @scope class
  attach_function :poll, :libssh2_poll, [LIBSSH2POLLFD, :uint, :long], :int
  
  # Returned by any function that would block during a read/write opperation
  # 
  # @method channel_open_ex(session, channel_type, channel_type_len, window_size, packet_size, message, message_len)
  # @param [LIBSSH2SESSION] session 
  # @param [String] channel_type 
  # @param [Integer] channel_type_len 
  # @param [Integer] window_size 
  # @param [Integer] packet_size 
  # @param [String] message 
  # @param [Integer] message_len 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :channel_open_ex, :libssh2_channel_open_ex, [LIBSSH2SESSION, :string, :uint, :uint, :uint, :string, :uint], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method channel_direct_tcpip_ex(session, host, port, shost, sport)
  # @param [LIBSSH2SESSION] session 
  # @param [String] host 
  # @param [Integer] port 
  # @param [String] shost 
  # @param [Integer] sport 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :channel_direct_tcpip_ex, :libssh2_channel_direct_tcpip_ex, [LIBSSH2SESSION, :string, :int, :string, :int], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method channel_forward_listen_ex(session, host, port, bound_port, queue_maxsize)
  # @param [LIBSSH2SESSION] session 
  # @param [String] host 
  # @param [Integer] port 
  # @param [FFI::Pointer(*Int)] bound_port 
  # @param [Integer] queue_maxsize 
  # @return [LIBSSH2LISTENER] 
  # @scope class
  attach_function :channel_forward_listen_ex, :libssh2_channel_forward_listen_ex, [LIBSSH2SESSION, :string, :int, :pointer, :int], LIBSSH2LISTENER
  
  # (Not documented)
  # 
  # @method channel_forward_cancel(listener)
  # @param [LIBSSH2LISTENER] listener 
  # @return [Integer] 
  # @scope class
  attach_function :channel_forward_cancel, :libssh2_channel_forward_cancel, [LIBSSH2LISTENER], :int
  
  # (Not documented)
  # 
  # @method channel_forward_accept(listener)
  # @param [LIBSSH2LISTENER] listener 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :channel_forward_accept, :libssh2_channel_forward_accept, [LIBSSH2LISTENER], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method channel_setenv_ex(channel, varname, varname_len, value, value_len)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [String] varname 
  # @param [Integer] varname_len 
  # @param [String] value 
  # @param [Integer] value_len 
  # @return [Integer] 
  # @scope class
  attach_function :channel_setenv_ex, :libssh2_channel_setenv_ex, [LIBSSH2CHANNEL, :string, :uint, :string, :uint], :int
  
  # (Not documented)
  # 
  # @method channel_request_pty_ex(channel, term, term_len, modes, modes_len, width, height, width_px, height_px)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [String] term 
  # @param [Integer] term_len 
  # @param [String] modes 
  # @param [Integer] modes_len 
  # @param [Integer] width 
  # @param [Integer] height 
  # @param [Integer] width_px 
  # @param [Integer] height_px 
  # @return [Integer] 
  # @scope class
  attach_function :channel_request_pty_ex, :libssh2_channel_request_pty_ex, [LIBSSH2CHANNEL, :string, :uint, :string, :uint, :int, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method channel_request_pty_size_ex(channel, width, height, width_px, height_px)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] width 
  # @param [Integer] height 
  # @param [Integer] width_px 
  # @param [Integer] height_px 
  # @return [Integer] 
  # @scope class
  attach_function :channel_request_pty_size_ex, :libssh2_channel_request_pty_size_ex, [LIBSSH2CHANNEL, :int, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method channel_x11_req_ex(channel, single_connection, auth_proto, auth_cookie, screen_number)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] single_connection 
  # @param [String] auth_proto 
  # @param [String] auth_cookie 
  # @param [Integer] screen_number 
  # @return [Integer] 
  # @scope class
  attach_function :channel_x11_req_ex, :libssh2_channel_x11_req_ex, [LIBSSH2CHANNEL, :int, :string, :string, :int], :int
  
  # (Not documented)
  # 
  # @method channel_process_startup(channel, request, request_len, message, message_len)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [String] request 
  # @param [Integer] request_len 
  # @param [String] message 
  # @param [Integer] message_len 
  # @return [Integer] 
  # @scope class
  attach_function :channel_process_startup, :libssh2_channel_process_startup, [LIBSSH2CHANNEL, :string, :uint, :string, :uint], :int
  
  # (Not documented)
  # 
  # @method channel_read_ex(channel, stream_id, buf, buflen)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] stream_id 
  # @param [String] buf 
  # @param [Integer] buflen 
  # @return [Integer] 
  # @scope class
  attach_function :channel_read_ex, :libssh2_channel_read_ex, [LIBSSH2CHANNEL, :int, :string, :ulong], :long
  
  # (Not documented)
  # 
  # @method poll_channel_read(channel, extended)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] extended 
  # @return [Integer] 
  # @scope class
  attach_function :poll_channel_read, :libssh2_poll_channel_read, [LIBSSH2CHANNEL, :int], :int
  
  # (Not documented)
  # 
  # @method channel_window_read_ex(channel, read_avail, window_size_initial)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [FFI::Pointer(*ULong)] read_avail 
  # @param [FFI::Pointer(*ULong)] window_size_initial 
  # @return [Integer] 
  # @scope class
  attach_function :channel_window_read_ex, :libssh2_channel_window_read_ex, [LIBSSH2CHANNEL, :pointer, :pointer], :ulong
  
  # libssh2_channel_receive_window_adjust is DEPRECATED, do not use!
  # 
  # @method channel_receive_window_adjust(channel, adjustment, force)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] adjustment 
  # @param [Integer] force 
  # @return [Integer] 
  # @scope class
  attach_function :channel_receive_window_adjust, :libssh2_channel_receive_window_adjust, [LIBSSH2CHANNEL, :ulong, :uchar], :ulong
  
  # (Not documented)
  # 
  # @method channel_receive_window_adjust2(channel, adjustment, force, storewindow)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] adjustment 
  # @param [Integer] force 
  # @param [FFI::Pointer(*UInt)] storewindow 
  # @return [Integer] 
  # @scope class
  attach_function :channel_receive_window_adjust2, :libssh2_channel_receive_window_adjust2, [LIBSSH2CHANNEL, :ulong, :uchar, :pointer], :int
  
  # (Not documented)
  # 
  # @method channel_write_ex(channel, stream_id, buf, buflen)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] stream_id 
  # @param [String] buf 
  # @param [Integer] buflen 
  # @return [Integer] 
  # @scope class
  attach_function :channel_write_ex, :libssh2_channel_write_ex, [LIBSSH2CHANNEL, :int, :string, :ulong], :long
  
  # (Not documented)
  # 
  # @method channel_window_write_ex(channel, window_size_initial)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [FFI::Pointer(*ULong)] window_size_initial 
  # @return [Integer] 
  # @scope class
  attach_function :channel_window_write_ex, :libssh2_channel_window_write_ex, [LIBSSH2CHANNEL, :pointer], :ulong
  
  # (Not documented)
  # 
  # @method session_set_blocking(session, blocking)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] blocking 
  # @return [nil] 
  # @scope class
  attach_function :session_set_blocking, :libssh2_session_set_blocking, [LIBSSH2SESSION, :int], :void
  
  # (Not documented)
  # 
  # @method session_get_blocking(session)
  # @param [LIBSSH2SESSION] session 
  # @return [Integer] 
  # @scope class
  attach_function :session_get_blocking, :libssh2_session_get_blocking, [LIBSSH2SESSION], :int
  
  # (Not documented)
  # 
  # @method channel_set_blocking(channel, blocking)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] blocking 
  # @return [nil] 
  # @scope class
  attach_function :channel_set_blocking, :libssh2_channel_set_blocking, [LIBSSH2CHANNEL, :int], :void
  
  # libssh2_channel_handle_extended_data is DEPRECATED, do not use!
  # 
  # @method channel_handle_extended_data(channel, ignore_mode)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] ignore_mode 
  # @return [nil] 
  # @scope class
  attach_function :channel_handle_extended_data, :libssh2_channel_handle_extended_data, [LIBSSH2CHANNEL, :int], :void
  
  # (Not documented)
  # 
  # @method channel_handle_extended_data2(channel, ignore_mode)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] ignore_mode 
  # @return [Integer] 
  # @scope class
  attach_function :channel_handle_extended_data2, :libssh2_channel_handle_extended_data2, [LIBSSH2CHANNEL, :int], :int
  
  # DEPRECATED
  # 
  # @method channel_flush_ex(channel, streamid)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [Integer] streamid 
  # @return [Integer] 
  # @scope class
  attach_function :channel_flush_ex, :libssh2_channel_flush_ex, [LIBSSH2CHANNEL, :int], :int
  
  # (Not documented)
  # 
  # @method channel_get_exit_status(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_get_exit_status, :libssh2_channel_get_exit_status, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_get_exit_signal(channel, exitsignal, exitsignal_len, errmsg, errmsg_len, langtag, langtag_len)
  # @param [LIBSSH2CHANNEL] channel 
  # @param [FFI::Pointer(**CharS)] exitsignal 
  # @param [FFI::Pointer(*SizeT)] exitsignal_len 
  # @param [FFI::Pointer(**CharS)] errmsg 
  # @param [FFI::Pointer(*SizeT)] errmsg_len 
  # @param [FFI::Pointer(**CharS)] langtag 
  # @param [FFI::Pointer(*SizeT)] langtag_len 
  # @return [Integer] 
  # @scope class
  attach_function :channel_get_exit_signal, :libssh2_channel_get_exit_signal, [LIBSSH2CHANNEL, :pointer, :pointer, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method channel_send_eof(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_send_eof, :libssh2_channel_send_eof, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_eof(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_eof, :libssh2_channel_eof, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_wait_eof(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_wait_eof, :libssh2_channel_wait_eof, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_close(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_close, :libssh2_channel_close, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_wait_closed(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_wait_closed, :libssh2_channel_wait_closed, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method channel_free(channel)
  # @param [LIBSSH2CHANNEL] channel 
  # @return [Integer] 
  # @scope class
  attach_function :channel_free, :libssh2_channel_free, [LIBSSH2CHANNEL], :int
  
  # (Not documented)
  # 
  # @method scp_recv(session, path, sb)
  # @param [LIBSSH2SESSION] session 
  # @param [String] path 
  # @param [FFI::Pointer(*Stat)] sb 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :scp_recv, :libssh2_scp_recv, [LIBSSH2SESSION, :string, :pointer], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method scp_send_ex(session, path, mode, size, mtime, atime)
  # @param [LIBSSH2SESSION] session 
  # @param [String] path 
  # @param [Integer] mode 
  # @param [Integer] size 
  # @param [Integer] mtime 
  # @param [Integer] atime 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :scp_send_ex, :libssh2_scp_send_ex, [LIBSSH2SESSION, :string, :int, :ulong, :long, :long], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method scp_send64(session, path, mode, size, mtime, atime)
  # @param [LIBSSH2SESSION] session 
  # @param [String] path 
  # @param [Integer] mode 
  # @param [Integer] size 
  # @param [Integer] mtime 
  # @param [Integer] atime 
  # @return [LIBSSH2CHANNEL] 
  # @scope class
  attach_function :scp_send64, :libssh2_scp_send64, [LIBSSH2SESSION, :string, :int, :long_long, :long, :long], LIBSSH2CHANNEL
  
  # (Not documented)
  # 
  # @method base64_decode(session, dest, dest_len, src, src_len)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(**CharS)] dest 
  # @param [FFI::Pointer(*UInt)] dest_len 
  # @param [String] src 
  # @param [Integer] src_len 
  # @return [Integer] 
  # @scope class
  attach_function :base64_decode, :libssh2_base64_decode, [LIBSSH2SESSION, :pointer, :pointer, :string, :uint], :int
  
  # (Not documented)
  # 
  # @method version(req_version_num)
  # @param [Integer] req_version_num 
  # @return [String] 
  # @scope class
  attach_function :version, :libssh2_version, [:int], :string
  
  # libssh2_version since 1.1
  # 
  # = Fields:
  # :magic ::
  #   (Integer) magic stored by the library
  # :node ::
  #   (FFI::Pointer(*Void)) handle to the internal representation of this host
  # :name ::
  #   (String) this is NULL if no plain text host name exists
  # :key ::
  #   (String) key in base64/printable format
  # :typemask ::
  #   (Integer) 
  class Knownhost < FFI::Struct
    layout :magic, :uint,
           :node, :pointer,
           :name, :string,
           :key, :string,
           :typemask, :int
  end
  
  # libssh2_knownhost_init
  # 
  # Init a collection of known hosts. Returns the pointer to a collection.
  # 
  # @method knownhost_init(session)
  # @param [LIBSSH2SESSION] session 
  # @return [LIBSSH2KNOWNHOSTS] 
  # @scope class
  attach_function :knownhost_init, :libssh2_knownhost_init, [LIBSSH2SESSION], LIBSSH2KNOWNHOSTS
  
  # type of key (2 bits)
  # 
  # @method knownhost_add(hosts, host, salt, key, keylen, typemask, store)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] host 
  # @param [String] salt 
  # @param [String] key 
  # @param [Integer] keylen 
  # @param [Integer] typemask 
  # @param [FFI::Pointer(**Knownhost)] store 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_add, :libssh2_knownhost_add, [LIBSSH2KNOWNHOSTS, :string, :string, :string, :ulong, :int, :pointer], :int
  
  # libssh2_knownhost_addc
  # 
  # Add a host and its associated key to the collection of known hosts.
  # 
  # Takes a comment argument that may be NULL.  A NULL comment indicates
  # there is no comment and the entry will end directly after the key
  # when written out to a file.  An empty string "" comment will indicate an
  # empty comment which will cause a single space to be written after the key.
  # 
  # The 'type' argument specifies on what format the given host and keys are:
  # 
  # plain  - ascii "hostname.domain.tld"
  # sha1   - SHA1(<salt> <host>) base64-encoded!
  # custom - another hash
  # 
  # If 'sha1' is selected as type, the salt must be provided to the salt
  # argument. This too base64 encoded.
  # 
  # The SHA-1 hash is what OpenSSH can be told to use in known_hosts files.  If
  # a custom type is used, salt is ignored and you must provide the host
  # pre-hashed when checking for it in the libssh2_knownhost_check() function.
  # 
  # The keylen parameter may be omitted (zero) if the key is provided as a
  # NULL-terminated base64-encoded string.
  # 
  # @method knownhost_addc(hosts, host, salt, key, keylen, comment, commentlen, typemask, store)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] host 
  # @param [String] salt 
  # @param [String] key 
  # @param [Integer] keylen 
  # @param [String] comment 
  # @param [Integer] commentlen 
  # @param [Integer] typemask 
  # @param [FFI::Pointer(**Knownhost)] store 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_addc, :libssh2_knownhost_addc, [LIBSSH2KNOWNHOSTS, :string, :string, :string, :ulong, :string, :ulong, :int, :pointer], :int
  
  # libssh2_knownhost_check
  # 
  # Check a host and its associated key against the collection of known hosts.
  # 
  # The type is the type/format of the given host name.
  # 
  # plain  - ascii "hostname.domain.tld"
  # custom - prehashed base64 encoded. Note that this cannot use any salts.
  # 
  # 
  # 'knownhost' may be set to NULL if you don't care about that info.
  # 
  # Returns:
  # 
  # LIBSSH2_KNOWNHOST_CHECK_* values, see below
  # 
  # @method knownhost_check(hosts, host, key, keylen, typemask, knownhost)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] host 
  # @param [String] key 
  # @param [Integer] keylen 
  # @param [Integer] typemask 
  # @param [FFI::Pointer(**Knownhost)] knownhost 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_check, :libssh2_knownhost_check, [LIBSSH2KNOWNHOSTS, :string, :string, :ulong, :int, :pointer], :int
  
  # this function is identital to the above one, but also takes a port
  #    argument that allows libssh2 to do a better check
  # 
  # @method knownhost_checkp(hosts, host, port, key, keylen, typemask, knownhost)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] host 
  # @param [Integer] port 
  # @param [String] key 
  # @param [Integer] keylen 
  # @param [Integer] typemask 
  # @param [FFI::Pointer(**Knownhost)] knownhost 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_checkp, :libssh2_knownhost_checkp, [LIBSSH2KNOWNHOSTS, :string, :int, :string, :ulong, :int, :pointer], :int
  
  # libssh2_knownhost_del
  # 
  # Remove a host from the collection of known hosts. The 'entry' struct is
  # retrieved by a call to libssh2_knownhost_check().
  # 
  # @method knownhost_del(hosts, entry)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [Knownhost] entry 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_del, :libssh2_knownhost_del, [LIBSSH2KNOWNHOSTS, Knownhost], :int
  
  # libssh2_knownhost_free
  # 
  # Free an entire collection of known hosts.
  # 
  # @method knownhost_free(hosts)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @return [nil] 
  # @scope class
  attach_function :knownhost_free, :libssh2_knownhost_free, [LIBSSH2KNOWNHOSTS], :void
  
  # libssh2_knownhost_readline()
  # 
  # Pass in a line of a file of 'type'. It makes libssh2 read this line.
  # 
  # LIBSSH2_KNOWNHOST_FILE_OPENSSH is the only supported type.
  # 
  # @method knownhost_readline(hosts, line, len, type)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] line 
  # @param [Integer] len 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_readline, :libssh2_knownhost_readline, [LIBSSH2KNOWNHOSTS, :string, :ulong, :int], :int
  
  # libssh2_knownhost_readfile
  # 
  # Add hosts+key pairs from a given file.
  # 
  # Returns a negative value for error or number of successfully added hosts.
  # 
  # This implementation currently only knows one 'type' (openssh), all others
  # are reserved for future use.
  # 
  # @method knownhost_readfile(hosts, filename, type)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] filename 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_readfile, :libssh2_knownhost_readfile, [LIBSSH2KNOWNHOSTS, :string, :int], :int
  
  # libssh2_knownhost_writeline()
  # 
  # Ask libssh2 to convert a known host to an output line for storage.
  # 
  # Note that this function returns LIBSSH2_ERROR_BUFFER_TOO_SMALL if the given
  # output buffer is too small to hold the desired output.
  # 
  # This implementation currently only knows one 'type' (openssh), all others
  # are reserved for future use.
  # 
  # @method knownhost_writeline(hosts, known, buffer, buflen, outlen, type)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [Knownhost] known 
  # @param [String] buffer 
  # @param [Integer] buflen 
  # @param [FFI::Pointer(*SizeT)] outlen 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_writeline, :libssh2_knownhost_writeline, [LIBSSH2KNOWNHOSTS, Knownhost, :string, :ulong, :pointer, :int], :int
  
  # libssh2_knownhost_writefile
  # 
  # Write hosts+key pairs to a given file.
  # 
  # This implementation currently only knows one 'type' (openssh), all others
  # are reserved for future use.
  # 
  # @method knownhost_writefile(hosts, filename, type)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [String] filename 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_writefile, :libssh2_knownhost_writefile, [LIBSSH2KNOWNHOSTS, :string, :int], :int
  
  # libssh2_knownhost_get()
  # 
  # Traverse the internal list of known hosts. Pass NULL to 'prev' to get
  # the first one. Or pass a poiner to the previously returned one to get the
  # next.
  # 
  # Returns:
  # 0 if a fine host was stored in 'store'
  # 1 if end of hosts
  # (negative) on errors
  # 
  # @method knownhost_get(hosts, store, prev)
  # @param [LIBSSH2KNOWNHOSTS] hosts 
  # @param [FFI::Pointer(**Knownhost)] store 
  # @param [Knownhost] prev 
  # @return [Integer] 
  # @scope class
  attach_function :knownhost_get, :libssh2_knownhost_get, [LIBSSH2KNOWNHOSTS, :pointer, Knownhost], :int
  
  # since 1.2.2
  # 
  # = Fields:
  # :magic ::
  #   (Integer) magic stored by the library
  # :node ::
  #   (FFI::Pointer(*Void)) handle to the internal representation of key
  # :blob ::
  #   (FFI::Pointer(*UChar)) public key blob
  # :blob_len ::
  #   (Integer) length of the public key blob
  # :comment ::
  #   (String) comment in printable format
  class AgentPublickey < FFI::Struct
    layout :magic, :uint,
           :node, :pointer,
           :blob, :pointer,
           :blob_len, :ulong,
           :comment, :string
  end
  
  # libssh2_agent_init
  # 
  # Init an ssh-agent handle. Returns the pointer to the handle.
  # 
  # @method agent_init(session)
  # @param [LIBSSH2SESSION] session 
  # @return [LIBSSH2AGENT] 
  # @scope class
  attach_function :agent_init, :libssh2_agent_init, [LIBSSH2SESSION], LIBSSH2AGENT
  
  # libssh2_agent_connect()
  # 
  # Connect to an ssh-agent.
  # 
  # Returns 0 if succeeded, or a negative value for error.
  # 
  # @method agent_connect(agent)
  # @param [LIBSSH2AGENT] agent 
  # @return [Integer] 
  # @scope class
  attach_function :agent_connect, :libssh2_agent_connect, [LIBSSH2AGENT], :int
  
  # libssh2_agent_list_identities()
  # 
  # Request an ssh-agent to list identities.
  # 
  # Returns 0 if succeeded, or a negative value for error.
  # 
  # @method agent_list_identities(agent)
  # @param [LIBSSH2AGENT] agent 
  # @return [Integer] 
  # @scope class
  attach_function :agent_list_identities, :libssh2_agent_list_identities, [LIBSSH2AGENT], :int
  
  # libssh2_agent_get_identity()
  # 
  # Traverse the internal list of public keys. Pass NULL to 'prev' to get
  # the first one. Or pass a poiner to the previously returned one to get the
  # next.
  # 
  # Returns:
  # 0 if a fine public key was stored in 'store'
  # 1 if end of public keys
  # (negative) on errors
  # 
  # @method agent_get_identity(agent, store, prev)
  # @param [LIBSSH2AGENT] agent 
  # @param [FFI::Pointer(**AgentPublickey)] store 
  # @param [AgentPublickey] prev 
  # @return [Integer] 
  # @scope class
  attach_function :agent_get_identity, :libssh2_agent_get_identity, [LIBSSH2AGENT, :pointer, AgentPublickey], :int
  
  # libssh2_agent_userauth()
  # 
  # Do publickey user authentication with the help of ssh-agent.
  # 
  # Returns 0 if succeeded, or a negative value for error.
  # 
  # @method agent_userauth(agent, username, identity)
  # @param [LIBSSH2AGENT] agent 
  # @param [String] username 
  # @param [AgentPublickey] identity 
  # @return [Integer] 
  # @scope class
  attach_function :agent_userauth, :libssh2_agent_userauth, [LIBSSH2AGENT, :string, AgentPublickey], :int
  
  # libssh2_agent_disconnect()
  # 
  # Close a connection to an ssh-agent.
  # 
  # Returns 0 if succeeded, or a negative value for error.
  # 
  # @method agent_disconnect(agent)
  # @param [LIBSSH2AGENT] agent 
  # @return [Integer] 
  # @scope class
  attach_function :agent_disconnect, :libssh2_agent_disconnect, [LIBSSH2AGENT], :int
  
  # libssh2_agent_free()
  # 
  # Free an ssh-agent handle.  This function also frees the internal
  # collection of public keys.
  # 
  # @method agent_free(agent)
  # @param [LIBSSH2AGENT] agent 
  # @return [nil] 
  # @scope class
  attach_function :agent_free, :libssh2_agent_free, [LIBSSH2AGENT], :void
  
  # libssh2_keepalive_config()
  # 
  # Set how often keepalive messages should be sent.  WANT_REPLY
  # indicates whether the keepalive messages should request a response
  # from the server.  INTERVAL is number of seconds that can pass
  # without any I/O, use 0 (the default) to disable keepalives.  To
  # avoid some busy-loop corner-cases, if you specify an interval of 1
  # it will be treated as 2.
  # 
  # Note that non-blocking applications are responsible for sending the
  # keepalive messages using libssh2_keepalive_send().
  # 
  # @method keepalive_config(session, want_reply, interval)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] want_reply 
  # @param [Integer] interval 
  # @return [nil] 
  # @scope class
  attach_function :keepalive_config, :libssh2_keepalive_config, [LIBSSH2SESSION, :int, :uint], :void
  
  # libssh2_keepalive_send()
  # 
  # Send a keepalive message if needed.  SECONDS_TO_NEXT indicates how
  # many seconds you can sleep after this call before you need to call
  # it again.  Returns 0 on success, or LIBSSH2_ERROR_SOCKET_SEND on
  # I/O errors.
  # 
  # @method keepalive_send(session, seconds_to_next)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(*Int)] seconds_to_next 
  # @return [Integer] 
  # @scope class
  attach_function :keepalive_send, :libssh2_keepalive_send, [LIBSSH2SESSION, :pointer], :int
  
  # NOTE NOTE NOTE
  #    libssh2_trace() has no function in builds that aren't built with debug
  #    enabled
  # 
  # @method trace(session, bitmask)
  # @param [LIBSSH2SESSION] session 
  # @param [Integer] bitmask 
  # @return [Integer] 
  # @scope class
  attach_function :trace, :libssh2_trace, [LIBSSH2SESSION, :int], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_trace_handler_func_(void, string, u_long)
  # @param [FFI::Pointer(*Void)] void 
  # @param [String] string 
  # @param [Integer] u_long 
  # @return [LIBSSH2SESSION] 
  # @scope class
  callback :trace_handler_func, [:pointer, :string, :ulong], LIBSSH2SESSION
  
  # (Not documented)
  # 
  # @method trace_sethandler(session, context, callback)
  # @param [LIBSSH2SESSION] session 
  # @param [FFI::Pointer(*Void)] context 
  # @param [Proc(_callback_trace_handler_func_)] callback 
  # @return [Integer] 
  # @scope class
  attach_function :trace_sethandler, :libssh2_trace_sethandler, [LIBSSH2SESSION, :pointer, :trace_handler_func], :int
  
end
